<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邹雷</title>
  <subtitle>刨过的坑,自己慢慢来填</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zoulei.net/"/>
  <updated>2017-12-25T12:40:40.772Z</updated>
  <id>https://www.zoulei.net/</id>
  
  <author>
    <name>ficapy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开始gitlab CI/CD</title>
    <link href="https://www.zoulei.net/2017/12/25/GitLabCICD_quickstart/"/>
    <id>https://www.zoulei.net/2017/12/25/GitLabCICD_quickstart/</id>
    <published>2017-12-25T12:38:35.000Z</published>
    <updated>2017-12-25T12:40:40.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitLabCI-CD流程"><a href="#GitLabCI-CD流程" class="headerlink" title="GitLabCI/CD流程"></a>GitLabCI/CD流程</h3><p>gitlab如果没有和Docker很好的结合。那么它会是一个很平凡的产品。但是有了CI对比其他产品Gogs、github等它还算可堪一用。上一篇文章写了gitlab_ci.yml配置文件的一些参数的含义。本篇文章记录一下如何从零在Gitlab上完成简单的CI/CD流程。基础流程如下Build流程构建我们需要的镜像上传到镜像仓库。部署的时候从镜像仓库直接拉取重启容器<br><img src="https://ficapy.b0.upaiyun.com/blogimg/GitlabCI.jpg" alt="GitlabCI"><br><a id="more"></a></p>
<h3 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h3><p>这个没什么好说的。无脑apt就好了。安装完毕后需要将本地用户加入到Docker用户组。方便命令的执行。在生产环境下需要注意的是最好修改它的默认配置，/etc/docker/daemon.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;data-root&quot;: &quot;/data/docker&quot;,</div><div class="line">    &quot;registry-mirrors&quot;: [&quot;https://xxx.mirror.aliyuncs.com&quot;],</div><div class="line">    &quot;log-opts&quot;: &#123;</div><div class="line">        &quot;max-size&quot;: &quot;50m&quot;,</div><div class="line">        &quot;max-file&quot;: &quot;3&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>现在云主机都是低容量系统盘外加高容量挂载盘组成。修改一下默认的根目录会比较好</li>
<li>没个镜像源下载dockerhub镜像不明智啊</li>
<li>限定一下最大日志量总没错。否则时间太长日志多了也很烦人</li>
</ol>
<h2 id="2-搭建Docker镜像仓库"><a href="#2-搭建Docker镜像仓库" class="headerlink" title="2. 搭建Docker镜像仓库"></a>2. 搭建Docker镜像仓库</h2><p>我使用的是Vmware出品的<a href="https://github.com/vmware/harbor">Harbor</a>。安装中遇到了以下几个坑</p>
<ol>
<li>按照文档从源码安装失败。直接下载八百多兆的离线安装包安装好歹算是成功了</li>
<li>我将HTTPS放到负载均衡上面。实际请求到后端的是http协议。所以我将配置修改为http。但是登陆失败。查了下将common/config/registry/config.yml的token由http改成https可以登陆了。解决了这个然后还不能push…没办法。我将负载均衡改成TCP端口转发。直接将证书放在harbor上。可算是没毛病了</li>
<li>以前配置过一次Harbor。导致了历史遗留文件。再次安装结果并不会覆盖掉以前的配置也不会做任何提示。</li>
<li>配置文件里面我改了一下secretkey_path地址。结果无法使用，无奈又改回来了</li>
</ol>
<p>总结。在Harbor作为宣称的企业级Docker镜像工具。杀手级功能是异地复制，镜像验证。安全扫描啥的。如果只是要搞个基础的镜像仓库。最后想了想还不如折腾Gitlab的Docker仓库。说不定在权限上和Gitlab结合的更好</p>
<h2 id="3-注册Gitlab-runner"><a href="#3-注册Gitlab-runner" class="headerlink" title="3. 注册Gitlab-runner"></a>3. 注册Gitlab-runner</h2><p>这应该算是CI强大的地方了。它和Gitlab本身松耦合。客户端建立长连接和Gitlab服务器保持通信。当满足条件的时候由Gitlab对Runner进行调度。Gitlab-runner是使用Go编写的，便于部署。当Runner接收到请求的时候它会执行shell脚本。想象一下python界的fabric。依次执行Bash命令。Runner也是差不多的套路。多条Bash命令间是没有相关性的。比如你上一条执行<code>cd demo</code>下一条<code>pwd</code>得到的还是本地用户目录，并不是demo。</p>
<ol>
<li>启动gitlab-runner Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d --name gitlab-runner --restart always \</div><div class="line">  -v /var/gitlab-runner/config:/etc/gitlab-runner \</div><div class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</div><div class="line">  gitlab/gitlab-runner:latest</div></pre></td></tr></table></figure>
<p>顺便说一下。要是执行gitlab-runner看它的命令行参数还挺多。其实是自身设计的不太好。显得好像很复杂，很多命令需要被<a href="https://docs.gitlab.com/runner/commands/README.html#service-related-commands">废弃了</a>.它的使用其实还是很简单的。如果你需要看帮助。那么执行<code>gitlab-runner register -h</code>还有点用</p>
<ol>
<li>添加Runner</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker exec -it gitlab-runner gitlab-runner register -n --tag-list &quot;name&quot; \</div><div class="line">    -r &quot;token&quot; --name &quot;BigBrother&quot; -u https://gitlab.company.com \</div><div class="line">    --executor &quot;docker&quot; --docker-image &quot;default_image&quot; \</div><div class="line">    --docker-volumes /var/run/docker.sock:/var/run/docker.sock</div></pre></td></tr></table></figure>
<ul>
<li>n 表示非交互模式</li>
<li>tag-list表示该Runner的标签(单独的项目用单独的tag也挺好。互不干扰)</li>
<li>r 该项目的token</li>
<li>name 名称标识</li>
<li>u Gitlab地址</li>
<li>executor 和上面说的执行bash命令。有多种方式。无脑用docker挺好</li>
<li>docker-image executor选择了docker之后,需要选择默认的镜像</li>
<li>docker-volumes 这个是为了在docker里面<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html">使用Docker构建镜像</a></li>
</ul>
<p>以上两步完成后就能够在Gitlab后台看到正常状态的Runner了</p>
<h3 id="4-编写-gitlab-ci-yml文件"><a href="#4-编写-gitlab-ci-yml文件" class="headerlink" title="4. 编写.gitlab-ci.yml文件"></a>4. 编写.gitlab-ci.yml文件</h3><p>如果你有丰富的Docker使用经验，这一步实际上没有太大的问题。本例中我只是通过docker build构建了镜像。然后上传到仓库。需要部署的时候使用SSH连接到远程机器上使用<code>docker-compose up --build -d</code>更新程序<br>Demo项目目录如下。正常本地启动执行python main.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── README.md</div><div class="line">├── conf.py</div><div class="line">├── deploy</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── prod_env</div><div class="line">│   ├── docker-compose.yml</div><div class="line">│   └── stage_env</div><div class="line">├── main.py</div><div class="line">├── .gitlab-ci.yml</div><div class="line">└── requirements.txt</div></pre></td></tr></table></figure>
<p>Dockerfile如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">FROM ficapy/python35_alpine</div><div class="line"></div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">ENV PYTHONPATH=/app</div><div class="line"></div><div class="line">COPY ./requirements.txt /app/requirements.txt</div><div class="line">RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</div><div class="line"></div><div class="line">COPY . /app</div><div class="line"></div><div class="line">CMD [&quot;python&quot;, &quot;main.py&quot;]</div></pre></td></tr></table></figure>
<p>docker-compose.yml如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line"></div><div class="line">services:</div><div class="line">  Name:</div><div class="line">    image: registry.company.com/repos/projectname:$&#123;TAG&#125;</div><div class="line">    restart: always</div><div class="line">    env_file:</div><div class="line">      - $&#123;ENV&#125;_env</div></pre></td></tr></table></figure>
<p>.gitlab-ci.yml如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">image: ficapy/docker:latest</div><div class="line"></div><div class="line">variables:</div><div class="line">  SSH: &quot;Host xxxxx&quot;</div><div class="line"></div><div class="line">stages:</div><div class="line">  - build</div><div class="line">  - deploy</div><div class="line"></div><div class="line">build:</div><div class="line">  stage: build</div><div class="line">  only:</div><div class="line">    - master</div><div class="line">  tags:</div><div class="line">    - tag</div><div class="line">  script:</div><div class="line">      - export DOCKER_TAG=$(env TZ=&apos;Asia/Shanghai&apos; date -d @$(git log -n1 $CI_COMMIT_SHA --format=&quot;%at&quot;) +%Y_%m_%d_%H%M%S)</div><div class="line">      - echo $DOCKER_TAG</div><div class="line">      - docker login -u deploy -p $DOCKER_PWD registry.company.com</div><div class="line">      - docker build -t registry.company.com/repos/must_lower_case:$DOCKER_TAG -f deploy/Dockerfile .</div><div class="line">      - docker push registry.company.com/repos/must_lower_case:$DOCKER_TAG</div><div class="line"></div><div class="line">cmbc_deploy:</div><div class="line">  stage: deploy</div><div class="line">  only:</div><div class="line">    - master</div><div class="line">  tags:</div><div class="line">    - tag</div><div class="line">  when: manual</div><div class="line">  variables:</div><div class="line">    SERVER: ssh_name</div><div class="line">  before_script:</div><div class="line">    - export DOCKER_TAG=$(env TZ=&apos;Asia/Shanghai&apos; date -d @$(git log -n1 $CI_COMMIT_SHA --format=&quot;%at&quot;) +%Y_%m_%d_%H%M%S)</div><div class="line">    - echo $DOCKER_TAG</div><div class="line">    - eval $(ssh-agent -s)</div><div class="line">    - bash -c &quot;ssh-add &lt;(echo &apos;$SSH_PRIVATE_KEY&apos;)&quot;</div><div class="line">    - mkdir -p ~/.ssh</div><div class="line">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;$SSH&quot; &gt; ~/.ssh/config&apos;</div><div class="line">  script:</div><div class="line">    - ssh $SERVER &quot;mkdir -p ~/$CI_PROJECT_NAME || true&quot;</div><div class="line">    - rsync -r deploy $SERVER:~/$CI_PROJECT_NAME</div><div class="line">    - ssh $SERVER &quot;docker login -u deploy -p $DOCKER_PWD registry.company.com&quot;</div><div class="line">    - ssh $SERVER &quot;cd $CI_PROJECT_NAME/deploy &amp;&amp; TAG=$DOCKER_TAG ENV=prod docker-compose up --build -d&quot;</div><div class="line">  environment:</div><div class="line">    name: PROD</div></pre></td></tr></table></figure>
<p>整个过程看配置文件应该还是比较容易理解的。如果有些参数不太明白请查看前一篇gitlabci yml笔记。因为它只是个Demo。所以我让他在每次master分支提交的时候都进行触发。整个部署流程实际上就是使用了SSH远程连接之后操作docker-compose进行更新。过程中感觉让我比较难以决断的是如何搞一个好的TAG方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完成上述过程之后我做一个自我总结。所谓CI/CD不过是将我们懒得输入的命令组合形成文件。让它依次执行Test-&gt;Build-&gt;Deploy。该方案几乎使用了全套Docker.从gitlab-runner、build到镜像仓库到生产环境的部署。在项目比较多的时候它是有好处的。比如有十个项目需要更新。每个项目需要更新到多个环境下。那么使用这种自动化还是有优势的。如果就一两个项目，而且只需要更新到测试和生产环境。个人觉得fabric就够了。而且该方案有一个缺点就是部署速度较慢。Gitlab每次执行任务速度并不是想象的那么快。最后生成镜像，上传，再拉取到正式环境。如果镜像过大就更慢了。而如果不使用Docker镜像的方式。直接git pull拉取源码。再supervisorctl更新程序。时间基本是秒级的。在频繁更新的测试环境它可能更高效。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GitLabCI-CD流程&quot;&gt;&lt;a href=&quot;#GitLabCI-CD流程&quot; class=&quot;headerlink&quot; title=&quot;GitLabCI/CD流程&quot;&gt;&lt;/a&gt;GitLabCI/CD流程&lt;/h3&gt;&lt;p&gt;gitlab如果没有和Docker很好的结合。那么它会是一个很平凡的产品。但是有了CI对比其他产品Gogs、github等它还算可堪一用。上一篇文章写了gitlab_ci.yml配置文件的一些参数的含义。本篇文章记录一下如何从零在Gitlab上完成简单的CI/CD流程。基础流程如下Build流程构建我们需要的镜像上传到镜像仓库。部署的时候从镜像仓库直接拉取重启容器&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/blogimg/GitlabCI.jpg&quot; alt=&quot;GitlabCI&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>gitlabci yml 笔记</title>
    <link href="https://www.zoulei.net/2017/12/25/gitlabciyml_note/"/>
    <id>https://www.zoulei.net/2017/12/25/gitlabciyml_note/</id>
    <published>2017-12-25T04:17:56.000Z</published>
    <updated>2017-12-25T06:10:56.899Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容来自GitlabCI官方文档</p>
<h2 id="最基础的"><a href="#最基础的" class="headerlink" title="最基础的"></a>最基础的</h2><ul>
<li><p>jobs作为最顶级的元素。每个job至少包含一个script</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">job1:</div><div class="line">    script1: pwd</div></pre></td></tr></table></figure>
<p>  每个job的执行都是完全独立于其他的job</p>
</li>
</ul>
<a id="more"></a>
<h2 id="关于Docker-Image和Service的使用"><a href="#关于Docker-Image和Service的使用" class="headerlink" title="关于Docker Image和Service的使用"></a>关于Docker Image和Service的使用</h2><ul>
<li><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html">Using Docker Build</a>。主要讲述怎么在Docker里面使用Docker构建镜像。(最简单的是在注册Runner的时候共享/var/run/docker.sock)</li>
<li><p><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html">Using Docker images</a>。</p>
</li>
<li><p>注册的时候可以同时运行Services。这样在任务执行期间可以访问services</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo gitlab-runner register \</div><div class="line">    --url &quot;https://gitlab.example.com/&quot; \</div><div class="line">    --registration-token &quot;PROJECT_REGISTRATION_TOKEN&quot; \</div><div class="line">    --description &quot;docker-ruby-2.1&quot; \</div><div class="line">    --executor &quot;docker&quot; \</div><div class="line">    --docker-image ruby:2.1 \</div><div class="line">    --docker-postgres latest \</div><div class="line">    --docker-mysql latest</div></pre></td></tr></table></figure>
</li>
<li><p>service就是任务执行的时候能够访问到别的容器。比如Mysql、Postgresql、Redis、Rabbitmq啥的</p>
</li>
<li>访问service就和我们使用docker-compose差不多</li>
</ul>
<h2 id="其他的一些Top-Level设置"><a href="#其他的一些Top-Level设置" class="headerlink" title="其他的一些Top-Level设置"></a>其他的一些Top-Level设置</h2><ul>
<li>before_script: 在每个任务执行前执行.比如配置好ssh config</li>
<li>after_script: 在每个任务执行完成后执行.好像用处不大</li>
<li>stages: <span style="color:red"><strong> 每个任务都可以属于一个stage.同一个stage的job是并行的.但是只有一个stage所有都执行完毕才会执行下一个stage</strong></span></li>
<li>variables: 每个job都可以使用的环境变量。此处只能进行很简单的设置。比如我希望将当前日期用一个固定的格式表达(需要用date命令进行转换),在这里是行不通的</li>
<li>cache: </li>
</ul>
<h2 id="可选项最多的Jobs配置来了"><a href="#可选项最多的Jobs配置来了" class="headerlink" title="可选项最多的Jobs配置来了"></a>可选项最多的Jobs配置来了</h2><ul>
<li>jobs: 必须要有独立的名称</li>
</ul>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>script</td>
<td>定义shell脚本</td>
</tr>
<tr>
<td>image</td>
<td>使用的image.可以覆盖掉全局的</td>
</tr>
<tr>
<td>services</td>
<td>使用docker services,覆盖掉全局</td>
</tr>
<tr>
<td>stage</td>
<td>属于哪个阶段</td>
</tr>
<tr>
<td>variables</td>
<td>定义job的环境变量</td>
</tr>
<tr>
<td>only</td>
<td>只有满足某条件的时候才会被执行</td>
</tr>
<tr>
<td>except</td>
<td>满足某条件的时候不执行</td>
</tr>
<tr>
<td>tags</td>
<td>哪些Runners能够执行该任务</td>
</tr>
<tr>
<td>allow_failure</td>
<td>允许任务失败。正常情况下失败则会不进行后续步骤</td>
</tr>
<tr>
<td>when</td>
<td>定义任务什么时候执行。manual手动还挺有用┑(￣Д ￣)┍</td>
</tr>
<tr>
<td>artifacts</td>
<td>将构建生成的文件上传到gitlab。允许从gitlab后台进行下载</td>
</tr>
<tr>
<td>dependencies</td>
<td>配合artifacts使用。将生成的artifacts文件跨job使用    </td>
</tr>
<tr>
<td>cache</td>
<td>缓存文件给后续job使用</td>
</tr>
<tr>
<td>before_script</td>
<td>覆盖全局</td>
</tr>
<tr>
<td>after_script</td>
<td>覆盖全局</td>
</tr>
<tr>
<td>environment</td>
<td><a href="https://docs.gitlab.com/ee/ci/environments.html">文档</a></td>
</tr>
<tr>
<td>coverage</td>
<td>代码覆盖率设置</td>
</tr>
<tr>
<td>retry</td>
<td>如果失败则重试几次</td>
</tr>
</tbody>
</table>
<p>额外说明:</p>
<ol>
<li>environment配合deploy使用.部署的时候人为标记是部署到了哪个环境。方便在gitlab后台查看历史记录。同时方便错误的时候可以直接在gitlab后台回滚部署。其实这个参数不要也是可以的。添加上去只是更方便一点</li>
<li>artifacts和cache的区别.<ul>
<li>cache可以在全局使用也可以在job内部使用.但是artifacts只能在job内部使用</li>
<li><span style="color:red"><strong>特别注意</strong></span> cache跨越该项目的整个生命周期。跨越不同的pipeline.job开始之前会先解压已有的cache.而artifacts只会再单个pipeline周期。且某个stage创建之后。在后续的stage中才能够使用。artifacts会同时上传文件到gitlab(上传步骤还是必须的)。</li>
</ul>
</li>
</ol>
<h2 id="YAML特殊语法"><a href="#YAML特殊语法" class="headerlink" title="YAML特殊语法"></a>YAML特殊语法</h2><ul>
<li><p>用anchors(&amp;)、aliases(*)、merging(&lt;&lt;) 来简化编写(大多数情况下应该没啥用)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.job_template: &amp;job_definition  # Hidden key that defines an anchor named &apos;job_definition&apos;</div><div class="line">image: ruby:2.1</div><div class="line">services:</div><div class="line">    - postgres</div><div class="line">    - redis</div><div class="line"></div><div class="line">test1:</div><div class="line">&lt;&lt;: *job_definition           # Merge the contents of the &apos;job_definition&apos; alias</div><div class="line">script:</div><div class="line">    - test1 project</div><div class="line"></div><div class="line">test2:</div><div class="line">&lt;&lt;: *job_definition           # Merge the contents of the &apos;job_definition&apos; alias</div><div class="line">script:</div><div class="line">    - test2 project</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://docs.gitlab.com/ee/ci/yaml/README.html">Configuration of your jobs with .gitlab-ci.yml </a><br><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html">Using Docker images</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容来自GitlabCI官方文档&lt;/p&gt;
&lt;h2 id=&quot;最基础的&quot;&gt;&lt;a href=&quot;#最基础的&quot; class=&quot;headerlink&quot; title=&quot;最基础的&quot;&gt;&lt;/a&gt;最基础的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;jobs作为最顶级的元素。每个job至少包含一个script&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;job1:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    script1: pwd&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  每个job的执行都是完全独立于其他的job&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>influxdb 专业术语</title>
    <link href="https://www.zoulei.net/2017/12/09/influxdb_glossary/"/>
    <id>https://www.zoulei.net/2017/12/09/influxdb_glossary/</id>
    <published>2017-12-09T00:02:41.000Z</published>
    <updated>2017-12-09T08:52:51.153Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基本全篇摘抄自v1.3的官方文档,先从理解下面这张两张图开始<br><img src="https://ficapy.b0.upaiyun.com/capture/influxdb_glossary.jpg" alt="influxdb_glossary"><br><img src="https://ficapy.b0.upaiyun.com/capture/influxdb_field.jpg" alt="influxdb"><br><a id="more"></a></p>
<h3 id="aggregation-聚合"><a href="#aggregation-聚合" class="headerlink" title="aggregation 聚合"></a>aggregation 聚合</h3><p>使用聚合函数对points中的set返回聚合结果</p>
<ul>
<li>count 返回非null的field values个数</li>
<li>distinct  返回唯一field values列表</li>
<li>integral 由过滤条件组成的积分</li>
<li>mean  返回field values的算术平均值</li>
<li>median 返回field values排序后的中位数</li>
<li>mode  从field values列表中返回最常用的值</li>
<li>spread 最大减去最小</li>
<li>stddev 标准差</li>
<li>sum 求和</li>
</ul>
<h3 id="batch-批量"><a href="#batch-批量" class="headerlink" title="batch 批量"></a>batch 批量</h3><p>为了减少influxdb的负载，建议对point的集合进行上传。使用\n做分割。建议每批包含五千到一万个point</p>
<h3 id="continuous-query-CQ-持续查询"><a href="#continuous-query-CQ-持续查询" class="headerlink" title="continuous query(CQ) 持续查询"></a>continuous query(CQ) 持续查询</h3><p>定期执行自动查询并将结果持久化到数据库</p>
<h3 id="database-数据库"><a href="#database-数据库" class="headerlink" title="database 数据库"></a>database 数据库</h3><p>和关系型数据库差不多吧。</p>
<table>
<thead>
<tr>
<th>关系型数据库</th>
<th>influxdb</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>database</td>
</tr>
<tr>
<td>table</td>
<td>measurement</td>
</tr>
<tr>
<td>row</td>
<td>point</td>
</tr>
</tbody>
</table>
<p>特别点的就是。influxdb有保留策略</p>
<h3 id="duration-持续时间"><a href="#duration-持续时间" class="headerlink" title="duration 持续时间"></a>duration 持续时间</h3><p>保留策略的一个属性表示数据会保存多久。数据过期会被执行自动删除</p>
<h3 id="field-字段"><a href="#field-字段" class="headerlink" title="field 字段"></a>field 字段</h3><p>对比tag来说field没有被索引。在一段时间范围内查询field的值需要扫描所有的point得到结果。性能没有tag好</p>
<h3 id="field-key-字段的key"><a href="#field-key-字段的key" class="headerlink" title="field key 字段的key"></a>field key 字段的key</h3><p>在key-value对中表示field字段的key.只能是string类型。存储到metadata中</p>
<h3 id="field-set-字段的集合"><a href="#field-set-字段的集合" class="headerlink" title="field set 字段的集合"></a>field set 字段的集合</h3><p>所有field key的集合</p>
<h3 id="field-value-字段的值"><a href="#field-value-字段的值" class="headerlink" title="field value 字段的值"></a>field value 字段的值</h3><p>field的value。类型可以是strings、float、integers、booleans。field的值始终与时间戳相关</p>
<h3 id="function-函数"><a href="#function-函数" class="headerlink" title="function 函数"></a>function 函数</h3><p>分三类，聚合、选择、转换</p>
<h3 id="identifier-标识"><a href="#identifier-标识" class="headerlink" title="identifier 标识"></a>identifier 标识</h3><p>emmm…持续查询名称、数据库名称、field字段、度量名称、保留策略名称、订阅名称、标签名称、用户名</p>
<h3 id="line-protocol-行协议"><a href="#line-protocol-行协议" class="headerlink" title="line protocol 行协议"></a>line protocol 行协议</h3><p>基于文本格式写入到influxdb</p>
<h3 id="measurement-度量"><a href="#measurement-度量" class="headerlink" title="measurement 度量"></a>measurement 度量</h3><p>emmm…可以类比到关系型数据库的table</p>
<h3 id="metastore-元数据存储"><a href="#metastore-元数据存储" class="headerlink" title="metastore  元数据存储"></a>metastore  元数据存储</h3><p>包含内部系统的状态信息。元素据存储包含了用户信息、数据库信息、保留侧列、分片元数据、持续查询和订阅</p>
<h3 id="node-节点"><a href="#node-节点" class="headerlink" title="node 节点"></a>node 节点</h3><p>一个独立的influxd进程</p>
<h3 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h3><p>本地的纳秒时间戳</p>
<h3 id="point-点"><a href="#point-点" class="headerlink" title="point 点"></a>point 点</h3><ul>
<li>在serises中由fields组成的单个数据。<code>每个point由它的series和时间戳组成唯一标识</code>(重点)</li>
<li>对于一个相同的时间戳和相同的series只能保存一个point.如果相同则新的field set覆盖掉旧的</li>
</ul>
<h3 id="query-查询"><a href="#query-查询" class="headerlink" title="query 查询"></a>query 查询</h3><p>从influxdb中查询到相关数据的操作</p>
<h3 id="replication-factor-复制因子"><a href="#replication-factor-复制因子" class="headerlink" title="replication factor 复制因子"></a>replication factor 复制因子</h3><p>对集群有用。O__O “…可是集群并不是免费功能,将一份数据保留到集群上多份</p>
<h3 id="retention-policy-RP-保留策略"><a href="#retention-policy-RP-保留策略" class="headerlink" title="retention policy(RP) 保留策略"></a>retention policy(RP) 保留策略</h3><p>以数据库作为单位，分三个方面。保留时长，数据多久进行一次分片操作。数据设置多少个副本。默认autogen表示永不删除、一个副本集(表示没副本)、七天进行一次分片</p>
<h3 id="schema-模式"><a href="#schema-模式" class="headerlink" title="schema 模式"></a>schema 模式</h3><p>如何组织数据到influxdb。包含databases、retention policies、series、measurements、tag keys、tag values、field keys</p>
<h3 id="selector-选择器"><a href="#selector-选择器" class="headerlink" title="selector 选择器"></a>selector 选择器</h3><p>一个函数，从特定范围的point中返回单个</p>
<ul>
<li>bottom 返回N个最小的field value</li>
<li>first  返回最开始时间的field value</li>
<li>last  返回最近时间的field value</li>
<li>max  返回最大的field value</li>
<li>min  返回最小的field value</li>
<li>percentile 根据百分比返回</li>
<li>sample  随机返回</li>
<li>top  返回最大的N个field value</li>
</ul>
<h3 id="series-序列"><a href="#series-序列" class="headerlink" title="series 序列"></a>series 序列</h3><p>由measurement、tag set、retention policy组成(<code>注意:field set不在里面</code>)</p>
<h3 id="series-cardinality-序列基数"><a href="#series-cardinality-序列基数" class="headerlink" title="series cardinality 序列基数"></a>series cardinality 序列基数</h3><p>唯一的series数，如果一个measurement有2个tag key。1个有三个唯一的值。另一个有两个。那么序列基数为6.因为tag集合是保存在内存中的。在配置里面也有默认的数量限制</p>
<h3 id="server-服务器"><a href="#server-服务器" class="headerlink" title="server 服务器"></a>server 服务器</h3><p>运行influxdb的环境。应该一台服务器只运行一个influxdb进程</p>
<h3 id="shard-分片"><a href="#shard-分片" class="headerlink" title="shard 分片"></a>shard 分片</h3><p>包含编码和压缩数据，作为TSM文件保存到磁盘。每个分片属于唯一的一个shard group。每个分片包含了特定的series</p>
<h3 id="shard-duration-分片持续时间"><a href="#shard-duration-分片持续时间" class="headerlink" title="shard duration 分片持续时间"></a>shard duration 分片持续时间</h3><p>由保留策略中的shard duration决定。</p>
<h3 id="shard-group-分片组"><a href="#shard-group-分片组" class="headerlink" title="shard group 分片组"></a>shard group 分片组</h3><p>分片组(保留策略)-&gt;shard-&gt;data.为了自动删除搞出了这么多概念┑(￣Д ￣)┍</p>
<h3 id="subscription-订阅"><a href="#subscription-订阅" class="headerlink" title="subscription 订阅"></a>subscription 订阅</h3><p>O__O “… 好像并没有什么用。搭配kapactior使用。订阅它的数据进行存储</p>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>对比field。tag是有索引的</p>
<h3 id="tag-key"><a href="#tag-key" class="headerlink" title="tag key"></a>tag key</h3><p>略</p>
<h3 id="tag-set"><a href="#tag-set" class="headerlink" title="tag set"></a>tag set</h3><p>略</p>
<h3 id="tag-value"><a href="#tag-value" class="headerlink" title="tag value"></a>tag value</h3><p>只能为数字。存储到metadata</p>
<h3 id="timestamp-时间戳"><a href="#timestamp-时间戳" class="headerlink" title="timestamp 时间戳"></a>timestamp 时间戳</h3><p>和point关联的时间戳，可以有多种时间格式存储和查询</p>
<h3 id="transformation-变换"><a href="#transformation-变换" class="headerlink" title="transformation 变换"></a>transformation 变换</h3><p>特定的点返回值和集合，得到的结果不能用来再次聚合</p>
<ul>
<li>ceiling 目前还不支持(ceil,floor)</li>
<li>cumulative_sum 将列表变成累加和列表(原有1,1,2,2变成1,2,4,6)  </li>
<li>derivative 导数</li>
<li>difference 和第一个结果相减得到不同</li>
<li>elapsed  得到时间戳的不同</li>
<li>floor  目前还不支持</li>
<li>histogram 目前还不支持</li>
<li>moving_average 滚动平均值(原有1,2,3得到1.5,2.5)</li>
<li>non_negative_derivative 非负导数</li>
<li>non_negative_difference 非负不同</li>
</ul>
<h3 id="tsm-Time-Structured-Merge-tree"><a href="#tsm-Time-Structured-Merge-tree" class="headerlink" title="tsm(Time Structured Merge tree)"></a>tsm(Time Structured Merge tree)</h3><p>influxdb的专用存储格式。允许高压缩和高速写入读取速度要高于已存在的B+树或者LSM树</p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><ul>
<li>admin用户具有读写所有数据库的权限并且可以管理用户</li>
<li>非admin有每个数据库的读写权限(被admin分配)</li>
</ul>
<h3 id="value-per-second"><a href="#value-per-second" class="headerlink" title="value per second"></a>value per second</h3><p>度量写入速度,比如每个point有四个field,每批有5000个point.写入速度为每秒10个。那么values per second速率为<code>4*5000*10</code></p>
<h3 id="WAL-write-ahead-log-预写日志"><a href="#WAL-write-ahead-log-预写日志" class="headerlink" title="WAL(write ahead log) 预写日志"></a>WAL(write ahead log) 预写日志</h3><p>略</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基本全篇摘抄自v1.3的官方文档,先从理解下面这张两张图开始&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/capture/influxdb_glossary.jpg&quot; alt=&quot;influxdb_glossary&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/capture/influxdb_field.jpg&quot; alt=&quot;influxdb&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记</title>
    <link href="https://www.zoulei.net/2017/12/07/ELK/"/>
    <id>https://www.zoulei.net/2017/12/07/ELK/</id>
    <published>2017-12-07T01:18:08.000Z</published>
    <updated>2017-12-07T01:34:28.783Z</updated>
    
    <content type="html"><![CDATA[<p>以下是看<a href="https://www.udemy.com/complete-elasticsearch-masterclass-with-kibana-and-logstash/">udemy的Elasticsearch入门教程</a>做的简短笔记</p>
<a id="more"></a>
<ol>
<li><p>基础知识、下载、配置(1-3)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">brew cask install java</div><div class="line">下载elasticsearch、kibana</div><div class="line">config/kibana 配置文件</div><div class="line">bin/elasticsearch   (9200)</div><div class="line">bin/kibana  启动(5601端口)</div></pre></td></tr></table></figure>
<p> Elasticsearch is Document Oriented</p>
<ul>
<li>insert Documents</li>
<li>Delete Documents</li>
<li>Retrieve Documents</li>
<li>Analyze Documents</li>
<li><p>Search Documents</p>
<h4 id="inverted-index"><a href="#inverted-index" class="headerlink" title="inverted index"></a>inverted index</h4><h4 id="JSON对象-经典数据库的Table模型转变为JSON模型"><a href="#JSON对象-经典数据库的Table模型转变为JSON模型" class="headerlink" title="JSON对象(经典数据库的Table模型转变为JSON模型)"></a>JSON对象(经典数据库的Table模型转变为JSON模型)</h4><p>ElasticSearch | Relational DB<br>— | —<br>Field   | Column<br>Document    | Row<br>Type    |   Table<br>Index   |   Database</p>
</li>
</ul>
</li>
<li><p>数据存储引擎、分布式工作引擎集群，shard(4-7)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</div><div class="line">&#123;</div><div class="line">    &quot;field1&quot;: &quot;value1&quot;,</div><div class="line">    &quot;field2&quot;: &quot;value2&quot;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">相同的id插入会生成不同的版本号</div><div class="line">更新数据的原理是读取数据合并再put.只支持row级别，不支持字段级别</div><div class="line">DELETE /vehicles/car/123</div><div class="line">&#123;</div><div class="line">    &quot;_index&quot;: &quot;vehicles&quot;,</div><div class="line">    &quot;_type&quot;: &quot;car&quot;,</div><div class="line">    &quot;_id&quot;: &quot;123&quot;,</div><div class="line">    &quot;_version&quot;: 13,</div><div class="line">    &quot;result&quot;: &quot;deleted&quot;,</div><div class="line">    &quot;_shards&quot;: &#123;</div><div class="line">        &quot;total&quot;: 2,</div><div class="line">        &quot;successful&quot;: 1,</div><div class="line">        &quot;failed&quot;: 0</div><div class="line">    &#125;,</div><div class="line">    &quot;_seq_no&quot;: 12,</div><div class="line">    &quot;_primary_term&quot;: 1</div><div class="line">&#125;</div><div class="line">即使删除同样也不会真的删除数据只会进行标记。磁盘空间不会立即释放</div></pre></td></tr></table></figure>
<p> mappings and settings.mappings类似与数据库中的schema</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&quot;settings&quot;: &#123;</div><div class="line">  &quot;index&quot;: &#123;</div><div class="line">    &quot;creation_date&quot;: &quot;1512370059209&quot;,</div><div class="line">    &quot;number_of_shards&quot;: &quot;5&quot;,</div><div class="line">    &quot;number_of_replicas&quot;: &quot;1&quot;,</div><div class="line">    &quot;uuid&quot;: &quot;Obppoj9yT4eQg5oq6Zv5IA&quot;,</div><div class="line">    &quot;version&quot;: &#123;</div><div class="line">      &quot;created&quot;: &quot;6000099&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;provided_name&quot;: &quot;vehicles&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>GET business/_search</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET business/building/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;:&#123;</div><div class="line">        &quot;term&quot;:&#123;&quot;address&quot;:&quot;pen&quot;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">PUT数据后经过分析进行分词写入内存。到达一定数量后持久化写入磁盘。组成segment。且不可变</div><div class="line">tokenization -&gt; filter</div><div class="line">1. Remove Stop Words</div><div class="line">2. Lowercasing</div><div class="line">3. Stemming</div><div class="line">4. Synonyms</div></pre></td></tr></table></figure>
<p> Token | Exists in<br> — | —<br> token   |   1</p>
<p> <img src="https://ficapy.b0.upaiyun.com/capture/elasticsearch_analyzer.jpeg" alt="elasticsearch_analyzer"></p>
</li>
</ol>
<ol>
<li><p>inverted index(8-9)</p>
<p> Data Types for Document Fields</p>
<p> String Fields: text,keyword<br> Numeric Fields: long,integer,short,byte,double,float<br> Date Fields: text,keyword<br> True/False Fields: boolean<br> Binary Fields: binary</p>
<p> - 注意。和教程不一致了。教程使用的5版本，新版本6进行了破坏性升级。以前index/type/documents的概念后续会去掉type。在6里面单个index里面无法存储多个type。故也无法设置多个mapping</p>
<ul>
<li>关闭写入内容时自动生成mappings(dynamic:false/strict)</li>
<li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html">各种analyzer测试</a></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">POST _analyze</div><div class="line">&#123;</div><div class="line">&quot;analyzer&quot;: &quot;simple&quot;,</div><div class="line">&quot;text&quot;: &quot;The 2 QUICK Brown-Foxes jumped over the lazy dog&apos;s bone.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>search DSL (10-14)</p>
<ul>
<li>Domain Specific Language</li>
<li><p>Query Context &amp; Filter Context</p>
<ol>
<li><p>Query</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">match_all</div><div class="line">&quot;match&quot;: &#123;&quot;name&quot;: &quot;computer&quot;&#125; </div><div class="line">这查询语法简直让人有种生不如死的感觉</div><div class="line">GET /courses/_search</div><div class="line">&#123;</div><div class="line">&quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">    &quot;must&quot;: [&#123;&quot;match&quot;: &#123;&quot;room&quot;: &quot;c8&quot;&#125;&#125;,</div><div class="line">        &#123;&quot;match&quot;: &#123;&quot;name&quot;: &quot;computer&quot;&#125;&#125;]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">must/must_not/should/minimun_should_match</div><div class="line">multi_match/match_phrase /match_phrase_prefix</div><div class="line">range</div></pre></td></tr></table></figure>
</li>
<li><p>Filter</p>
<ul>
<li>不能单独使用</li>
<li>不进行评分</li>
<li>ElasticSearch会对结果进行缓存</li>
<li>可以先常规查询得到评分。再使用filter对结果过滤</li>
</ul>
</li>
<li><p>Aggregation</p>
<ul>
<li>endpoint-&gt;_search/_count</li>
<li>bulk indexing</li>
<li>terms:field类似与group、aggs来聚合、avg、max、min函数(如果需要根据聚合的结果来排序怎么办)</li>
<li>先执行query。后面根据结果进行聚合</li>
<li>stats(min、max、avg、sum)</li>
<li>bucket和metric的概念。range  <ul>
<li>对于group by得到的结果再次使用range(from、to)进行二次分组。分组后可以嵌套使用agg聚合</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>logstash and kibana (15-17)</p>
<ol>
<li><p>logstash</p>
<ul>
<li>input、filter、output(ruby语法)</li>
</ul>
</li>
<li><p>Kibana</p>
<ul>
<li>kibana需要先设置默认index</li>
<li>Visualize新建单个视图、Dashboard组合它们</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是看&lt;a href=&quot;https://www.udemy.com/complete-elasticsearch-masterclass-with-kibana-and-logstash/&quot;&gt;udemy的Elasticsearch入门教程&lt;/a&gt;做的简短笔记&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>influxdb配置文件</title>
    <link href="https://www.zoulei.net/2017/12/01/influxdb_config/"/>
    <id>https://www.zoulei.net/2017/12/01/influxdb_config/</id>
    <published>2017-12-01T14:38:46.000Z</published>
    <updated>2017-12-08T23:59:26.538Z</updated>
    
    <content type="html"><![CDATA[<p>开始一个软件,从读懂它的配置文件开始。以下是读取<a href="https://docs.influxdata.com/influxdb/v1.3/administration/config/">3.1配置文档</a>的笔记<br>总结来说，influxdb的配置文件可配置的地方几乎没有。参数性能调优貌似不存在，其中是否开启，是否记录日志都占据了好多部分。额外需要关注的是data章节有一些关于fsync的设置默认是0，还有默认的max-series-per-database和max-value-per-tag默认都存在限制。暂时不太清楚原理是什么(更新:因为influxdb最大的软肋就在series的数量上。tag的数据都保存在内存。所以有极大的限制。可以看到<a href="https://docs.influxdata.com/influxdb/v1.3/guides/hardware_sizing/#general-hardware-guidelines-for-a-cluster">官方硬件要求</a>,100万的series需要4-6核心CPU,8-32GB内存，iops要求1000+。对比一下influxdb提供的<a href="https://cloud.influxdata.com/plan-picker">云服务</a>，100万的series需要每月1500刀!!!)。当保存大量数据的时候肯定会报错,另外默认的慢查询日志是没有打开的。对于请求。默认没有限制最大的返回内容数。以及限制单个查询响应的时间</p>
<a id="more"></a>
<h1 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h1><ul>
<li>使用<code>influxd config</code>查看默认的配置</li>
<li>使用<code>influxd -config config_path</code>或者<code>INFLUXDB_CONFIG_PATH</code>启动</li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>配置优先级为: 环境变量 &gt; 文件配置 &gt; 默认设置</p>
<h2 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h2><ol>
<li>reporting-disabled  发送数据统计给influxdb</li>
<li>bind-address        绑定监听地址(RPC)</li>
<li>GOMAXPROCS          最大进程数</li>
</ol>
<h2 id="meta"><a href="#meta" class="headerlink" title="[meta]"></a>[meta]</h2><ol>
<li>dir   meta数据保存地址(一般设置一个base_dir)</li>
<li>retention-autocreate 自动创建保留策略。默认永久保留</li>
<li>logging-enabled  开启meta日志记录</li>
</ol>
<h2 id="data"><a href="#data" class="headerlink" title="[data]"></a>[data]</h2><ol>
<li>dir  数据保存地址</li>
<li>index-version 决定分片索引保存内存还是磁盘</li>
<li>wal-dir  预写日志保存地址</li>
<li>wal-fsync-delay  预写日志刷新延迟(非ssd磁盘建议0-100ms)</li>
<li>trace-logging-enabled TSM引擎和WAL日志</li>
<li>query-log-enabled   是否记录查询日志</li>
<li>cache-max-memory-size    最大缓存容量,占满会拒绝写入</li>
<li>cache-snapshot-memory-size 缓存快照大小。满后会将内存内容写入到TSM文件</li>
<li>cache-snapshot-write-cold-duration 如果一个分片没有被写入或者删除会被写入到TSM文件的时间</li>
<li>compact-full-write-cold-duration 同上，没有写入或者删除的压缩时间</li>
<li>max-concurrent-compactions  并发压缩进程数</li>
<li>max-series-per-database   每个数据库最大的series数量。超过会500错误。0表示无限制(为什么需要限制呢？)</li>
<li>max-values-per-tag 每个tag索引的值个数(同疑问为什么限制为十万)</li>
</ol>
<h2 id="coordinator"><a href="#coordinator" class="headerlink" title="[coordinator]"></a>[coordinator]</h2><ol>
<li>write-timeout    写入超时时间10秒</li>
<li>max-concurrent-queries  最大并发查询数默认无限制</li>
<li>query-timeout   查询超时时间默认无限制</li>
<li>log-queries-after 慢查询检测。为慢查询则记录日志</li>
<li>max-select-point 最大的points数量。默认无限制</li>
<li>max-select-series  最大的series数量。默认无限制</li>
<li>max-select-buckets   最大的GROUP BY time()数量。默认无限制</li>
</ol>
<h2 id="retention"><a href="#retention" class="headerlink" title="[retention]"></a>[retention]</h2><ol>
<li>enable  设置为false则禁止删除数据</li>
<li>check-interval  检查周期默认三十分钟</li>
</ol>
<h2 id="shard-precreation"><a href="#shard-precreation" class="headerlink" title="[shard-precreation]"></a>[shard-precreation]</h2><ol>
<li>enable 开启数据到达前先创建shard</li>
<li>check-interval  检查周期</li>
<li>advance-period  预创建shard的最大时间</li>
</ol>
<h2 id="admin"><a href="#admin" class="headerlink" title="[admin]"></a>[admin]</h2><p>官方完全废弃，不可用。由xx替代(注:还是用grafana吧)</p>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="[monitor]"></a>[monitor]</h2><p>系统自身监控。默认数据会保存到_internal数据库</p>
<ol>
<li>store-enabled  是否存储监控信息</li>
<li>store-database 保存数据库的名称</li>
<li>store-interval  记录间隔。默认十秒</li>
</ol>
<h2 id="subscriber"><a href="#subscriber" class="headerlink" title="[subscriber]"></a>[subscriber]</h2><p>这个部分是控制Kapacitor如何接收数据。应该没什么用处</p>
<ol>
<li>enabled</li>
<li>http-timeout</li>
<li>insecure-skip-verify</li>
<li>ca-certs</li>
<li>write-concurrency</li>
<li>write-buffer-size</li>
</ol>
<h2 id="http"><a href="#http" class="headerlink" title="[http]"></a>[http]</h2><p>除了RPC调用。就是RESTFUL方式的api读写了</p>
<ol>
<li>enable  是否打开</li>
<li>bind-address 绑定地址</li>
<li>auth-enabled 打开验证</li>
<li>realm  JWT验证相关</li>
<li>log-enabled 记录日志</li>
<li>write-tracing 应该是调试使用。会记录写入的payload</li>
<li>pprof-enabled 开启性能记录</li>
<li>https-enabled  开启https</li>
<li>https-certificate https证书</li>
<li>https-private-key  https私钥</li>
<li>shared-secret  用于JWT的签名。想想单机应该是用不到的</li>
<li>max-row-limit  最大单次可以上传的point，默认无限制</li>
<li>max-connection-limit 最大可连接数，默认无限制</li>
<li>unix-socket-enabled  开启unix域连接</li>
<li>bind-socket  绑定socket域</li>
<li>max-body-size  最大body长度,默认25MB，超过大小返回http413请求实体过大错误</li>
</ol>
<h2 id="graphite"><a href="#graphite" class="headerlink" title="[[graphite]]"></a>[[graphite]]</h2><p>(service plugin)设置一个或多个graphite数据监听器</p>
<ol>
<li>enabled 启用graphite</li>
<li>database   数据库名称</li>
<li>retention-policy 保留策略</li>
<li>bind-address  绑定地址</li>
<li>protocol     协议tcp或udp</li>
<li>consistency-level   一致性级别</li>
<li>batch-size</li>
<li>batch-pending</li>
<li>batch-timeout</li>
<li>udp-read-buffer</li>
<li>separator</li>
</ol>
<h2 id="collectd"><a href="#collectd" class="headerlink" title="[[collectd]]"></a>[[collectd]]</h2><p>(service plugin)同上，设置监听collectd数据</p>
<ol>
<li>enabled</li>
<li>bind-address</li>
<li>database</li>
<li>retention-policy</li>
<li>typesdb</li>
<li>security-level</li>
<li>auth-file</li>
<li>batch-size</li>
<li>batch-pending</li>
<li>batch-timeout</li>
<li>read-buffer</li>
</ol>
<h2 id="opentsdb"><a href="#opentsdb" class="headerlink" title="[[opentsdb]]"></a>[[opentsdb]]</h2><p>(service plugin)同上，设置监听opentsdb数据</p>
<ol>
<li>enabled</li>
<li>bind-address</li>
<li>database</li>
<li>retention-policy</li>
<li>consistency-level</li>
<li>tls-enabled</li>
<li>certificate</li>
<li>log-point-errors</li>
<li>batch-size</li>
<li>batch-pending</li>
<li>batch-timeout</li>
</ol>
<h2 id="udp"><a href="#udp" class="headerlink" title="[[udp]]"></a>[[udp]]</h2><p>(service plugin)除了RPC、HTTP、附带UDP</p>
<ol>
<li>enabled</li>
<li>bind-address</li>
<li>database</li>
<li>retention-policy</li>
<li>batch-size</li>
<li>batch-pending</li>
<li>batch-timeout</li>
<li>read-buffer</li>
<li>precision</li>
</ol>
<h1 id="continuous-queries"><a href="#continuous-queries" class="headerlink" title="[continuous_queries]"></a>[continuous_queries]</h1><p>持续查询</p>
<ol>
<li>enabled  开启</li>
<li>query-stats-enabled  默认关闭，将执行统计写入到默认的监控数据库  </li>
<li>log-enabled  记录日志</li>
<li>run-interval  查找执行间隔</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始一个软件,从读懂它的配置文件开始。以下是读取&lt;a href=&quot;https://docs.influxdata.com/influxdb/v1.3/administration/config/&quot;&gt;3.1配置文档&lt;/a&gt;的笔记&lt;br&gt;总结来说，influxdb的配置文件可配置的地方几乎没有。参数性能调优貌似不存在，其中是否开启，是否记录日志都占据了好多部分。额外需要关注的是data章节有一些关于fsync的设置默认是0，还有默认的max-series-per-database和max-value-per-tag默认都存在限制。暂时不太清楚原理是什么(更新:因为influxdb最大的软肋就在series的数量上。tag的数据都保存在内存。所以有极大的限制。可以看到&lt;a href=&quot;https://docs.influxdata.com/influxdb/v1.3/guides/hardware_sizing/#general-hardware-guidelines-for-a-cluster&quot;&gt;官方硬件要求&lt;/a&gt;,100万的series需要4-6核心CPU,8-32GB内存，iops要求1000+。对比一下influxdb提供的&lt;a href=&quot;https://cloud.influxdata.com/plan-picker&quot;&gt;云服务&lt;/a&gt;，100万的series需要每月1500刀!!!)。当保存大量数据的时候肯定会报错,另外默认的慢查询日志是没有打开的。对于请求。默认没有限制最大的返回内容数。以及限制单个查询响应的时间&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>ansible笔记</title>
    <link href="https://www.zoulei.net/2017/11/28/ansible-note/"/>
    <id>https://www.zoulei.net/2017/11/28/ansible-note/</id>
    <published>2017-11-28T03:28:42.000Z</published>
    <updated>2017-11-28T03:57:18.299Z</updated>
    
    <content type="html"><![CDATA[<p>以下为观看<a href="https://www.youtube.com/playlist?list=PL7hgvWUGJtUsT74AXZgVhr37riphKjzkD">Ansible-Configuration Management</a>的笔记。不适合初学者查看。可以作为温习使用</p>
<a id="more"></a>
<h2 id="Ansible总结"><a href="#Ansible总结" class="headerlink" title="Ansible总结"></a>Ansible总结</h2><ol>
<li>单个Module是基石，将机器分组，严重依靠变量</li>
<li>task组成任务</li>
<li>全部的task组成playbooks.将所有的机器定义到一个确定的状态</li>
<li>使用role对playbooks进行拆分.role有约定好的目录结构</li>
<li>ansible galaxy来分享role.使用时完全使用变量来覆盖原有变量,严重依赖社区水平(比如国情安装许多软件都需要使用镜像,而外国作者编写role并不会考虑这些)</li>
</ol>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>change management(定义一个特定的系统状态，change_event用于回调)</li>
<li>Provisioning(role。服务划分。比如一个webserver会依次执行某些步骤)</li>
<li>Automation(playbook同时设置上千台)</li>
<li>Orchestration(编排多个tasks让其协调coordinates执行。多个系统配置。解决task间的依赖性)</li>
</ul>
<h2 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h2><ul>
<li>No agents</li>
<li>No database</li>
<li>No residual software</li>
<li>No complex upgrades</li>
<li>题外话。使用yaml文件描述而无法使用编程控制。我认为迟早药丸。只不过目前还没找到更好的替代品</li>
<li>ssh/root/encrypted vault(共享到github仓库成标配了,几乎所有的软件都是这个套路)</li>
<li>easy to extend:http call、shell commands(挺有用)、scripts(暂时不太懂，感觉是扩充model)、Ansible-Galaxy</li>
</ul>
<h2 id="Ansible-架构"><a href="#Ansible-架构" class="headerlink" title="Ansible 架构"></a>Ansible 架构</h2><p><img src="https://ficapy.b0.upaiyun.com/capture/ansible_arch.jpg" alt="Ansible 架构"></p>
<p>Variables:</p>
<ul>
<li>Host Variables: 在资产中给host或者group设置的变量</li>
<li>Facts: ansible进行的第一步就是setup。获取机器的基础信息。比如内网ip</li>
<li>Dynamic Variables: 收集tasks数据或者运行时获取？比如将上一个task的结果作为参数</li>
</ul>
<p>执行过程中将model发送到远方机器临时目录执行。返回json结果。然后删除临时目录内容</p>
<h2 id="学习环境搭建-视频19"><a href="#学习环境搭建-视频19" class="headerlink" title="学习环境搭建(视频19)"></a>学习环境搭建(视频19)</h2><ul>
<li>Vagrant、Virtualbox、Ansible</li>
<li>Remote、Local(基本不使用Local模式。仅有一次无法远程ssh我用过)</li>
</ul>
<h2 id="Inventory-Features"><a href="#Inventory-Features" class="headerlink" title="Inventory Features"></a>Inventory Features</h2><ul>
<li>Behavioral Parameters</li>
<li>Groups</li>
<li>Groups of Groups</li>
<li>Assign Variables</li>
<li>Scaling out using multiple files</li>
<li>Static/Dynamic<br>分组、组合、赋予变量(和python里面变量作用域LEGB差不多)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[db]</div><div class="line">db1.company.com ansible_ssh_user=aarom xx=xx</div><div class="line">db2.company.com</div><div class="line"></div><div class="line">[datacenter-west:children]</div><div class="line">db</div><div class="line"></div><div class="line">[datacenter-west:vars]</div><div class="line">ansible_ssh_user=ansible_user</div><div class="line">xx=xx</div></pre></td></tr></table></figure>
<p>分组的套路(group_vars、host_vars下面的文件必须和inventory相对应)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">├── group_vars   # 全局</div><div class="line">│   ├── all</div><div class="line">│   ├── db</div><div class="line">├── host_vars   # 单个host</div><div class="line">│   └── web1</div><div class="line">├── inventory_prod</div><div class="line">├── inventory_test</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># variable file example</div><div class="line">---     # 标记</div><div class="line"># key-value pairs</div><div class="line">ntp:  ntp-west.company.com</div><div class="line">syslog: logger-west.company.com</div></pre></td></tr></table></figure>
<h2 id="Ad-Hoc-临时使用"><a href="#Ad-Hoc-临时使用" class="headerlink" title="Ad-Hoc 临时使用"></a>Ad-Hoc 临时使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ansible -m ping all</div><div class="line">ansible -m shell -a &quot;hostname&quot; all</div><div class="line">ansible -m shell -a &quot;getent passwd | grep deploy&quot; all</div><div class="line">ansible -b -K -m shell -a &quot;whoami&quot; all -vvv -T 30 -c paramiko</div></pre></td></tr></table></figure>
<p>参数注解</p>
<ul>
<li>-b become变成某用户一般是root</li>
<li>-K 配合-b输入密码</li>
<li>-m 使用某个模块</li>
<li>-vvv 和ssh -vvv一样查看详细日志</li>
<li>-T timeout 设置超时</li>
<li>-c 选择连接的模块. 3.5使用默认值搞sudo可能会有问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">使用变量(估计使用janja2模板引擎是会python的人使用ansible的唯一优势了-_-)</div><div class="line">ansible webservers -i inventory_prod -m user -a &quot;name=&#123;&#123;username&#125;&#125; password=1234 -b&quot;</div></pre></td></tr></table></figure>
<p>ansible-doc可以查看文档  </p>
<h2 id="Host-Group-Target-Patterns"><a href="#Host-Group-Target-Patterns" class="headerlink" title="Host/Group Target Patterns"></a>Host/Group Target Patterns</h2><ul>
<li>OR (group1:group2)</li>
<li>NOT (!group2)</li>
<li>Wildcard (web*.ex.com)</li>
<li>Regex (~web[0-9]+)</li>
<li>Complex Patterns AND (group1:&amp;group2) # 求交集、中间出现一个:有点奇葩</li>
</ul>
<h2 id="Anaible-Playbooks"><a href="#Anaible-Playbooks" class="headerlink" title="Anaible Playbooks"></a>Anaible Playbooks</h2><ul>
<li>组合ansible modules组成play,多个play组成playbooks</li>
<li>logic controls &amp; error handle</li>
<li>include 合并多个</li>
<li>Grab output of task for another task(register)</li>
<li>Debug Module(debug/msg or var)</li>
<li>Promptins for input(类似与input,vars_prompt)</li>
<li>Playbook Handlers(notify)<ol>
<li>Tasks with asynchronous execution</li>
<li>Only runs tasks when notified</li>
<li>Tasks Only notify when state=changed</li>
<li>Does not run until all playbook tasks have executed</li>
<li>Most common for restarting services to load changes(if changes are made)</li>
</ol>
</li>
<li>Contitional Clause(when: ansible_os_family == “Debian”,搭配register使用)</li>
<li>Jinja2 Template Module(template)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: webservres</div><div class="line">  sudo: yes</div><div class="line"></div><div class="line">  vars:</div><div class="line">    http_port: 80</div><div class="line">    doc_dir: /ansible/</div><div class="line">    doc_root: /var/www/html/ansible/</div><div class="line">    max_clients: 5</div><div class="line">  </div><div class="line">  vars_prompt:</div><div class="line">    - name: username</div><div class="line">      prompt: what is your name?</div><div class="line"></div><div class="line">  tasks:</div><div class="line">  - name: Ensure that Apache is installed</div><div class="line">    yum: name=httpd state=present</div><div class="line">    when: ansible_os_family == &quot;RedHat&quot;</div><div class="line"></div><div class="line">  - name: Start Apache Services</div><div class="line">    service: name=httpd enabled=yes state=started</div><div class="line"></div><div class="line">  - name: Deploy configuration File</div><div class="line">    template: src=templates/httpd.j2 dest=/etc/httpd/conf/httpd.conf</div><div class="line">    notify:</div><div class="line">      - Restart Apache</div><div class="line">    </div><div class="line">  - name: Copy Site Files</div><div class="line">      template: src=templates/index.j2 dest=&#123;&#123; doc_root &#125;&#125;/index.html</div><div class="line"></div><div class="line">  handlers:</div><div class="line">    - name: Restart Apache</div><div class="line">      service: name=httpd state=restarted</div><div class="line"></div><div class="line">- hosts: dbservers</div><div class="line">  sudo: yes</div><div class="line"></div><div class="line">  tasks:</div><div class="line">  - name: Ensure MySQL is installed</div><div class="line">    yum: name=mysql-server state=present</div><div class="line">  </div><div class="line">  - name: Start MySQL</div><div class="line">    service: name=mysqld state=started</div><div class="line"></div><div class="line">- hosts: webservers:dbservers</div><div class="line">  sudo: yes</div><div class="line"></div><div class="line">  tasks:</div><div class="line">  - name: Stop IPTABLES NOW!!!</div><div class="line">    service: name=iptables state=stopped</div></pre></td></tr></table></figure>
<p>ansible-playbook -i inventory web_db.yaml</p>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><ul>
<li>Predefined directory structure</li>
<li>defaults、files、handlers、meta、tasks、templates、vars</li>
<li>main.yml,使用include.vars除外</li>
<li>use tags to define categories within your playbooks</li>
<li><p>Adding Roles to Playbook</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    ---</div><div class="line">    - hosts: code-dev</div><div class="line">    roles:</div><div class="line">        - server-common</div><div class="line">        - builders</div><div class="line">    gather_facts: no</div><div class="line">    tasks:</div><div class="line">        # Build your extra tasks here like</div><div class="line">    ``` </div><div class="line">- Pre-tasks and Post-tasks(executes plays before or after roles)</div><div class="line">- ```ansible-playbook site.yml -tags &quot;web&quot; -limit atlanta</div></pre></td></tr></table></figure>
</li>
<li><p>ansible galaxy(ansible-galaxy install username.role)</p>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><a href="https://github.com/enginyoyen/ansible-best-practises">ansible-best-practises</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下为观看&lt;a href=&quot;https://www.youtube.com/playlist?list=PL7hgvWUGJtUsT74AXZgVhr37riphKjzkD&quot;&gt;Ansible-Configuration Management&lt;/a&gt;的笔记。不适合初学者查看。可以作为温习使用&lt;/p&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>内网无网络环境初始化线上环境</title>
    <link href="https://www.zoulei.net/2017/08/13/when_no_network_setup_environment/"/>
    <id>https://www.zoulei.net/2017/08/13/when_no_network_setup_environment/</id>
    <published>2017-08-13T09:18:36.000Z</published>
    <updated>2017-08-13T09:46:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>遇到有人反映可能是内网环境。无法访问外部网络。安装初始化环境的时候好像颇为不便。其实只要能ssh上去。这一切都不是问题。就是各种转发，以下以内网使用pip安装第三方依赖包为例说明该如何操作</p>
<h2 id="1-本机开启一个临时的http代理"><a href="#1-本机开启一个临时的http代理" class="headerlink" title="1.本机开启一个临时的http代理"></a>1.本机开启一个临时的http代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mitmproxy           # 安装</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mitmproxy -p 8899 --ignore .+               #  使用</div></pre></td></tr></table></figure>
<p>mitmproxy是一个python编写的http/https中间人框架。这里我们单独的使用它的http proxy功能。<br>参数p当然是port端口的意思了。监听8899端口<br>加上ignore是因为中间人https连接需要客户端安装信任证书才可以。此处我们只是单纯的使用一下proxy不需要中间人。所以所有流量使用HTTP Connection隧道方式就达成目的了。使用正则表达式<code>.+</code>忽略所有域名。至于为什么使用http不是用socks。因为http使用更广泛</p>
<h2 id="2-ssh使用远程端口转发-参考ssh端口映射"><a href="#2-ssh使用远程端口转发-参考ssh端口映射" class="headerlink" title="2.ssh使用远程端口转发(参考ssh端口映射)"></a>2.ssh使用远程端口转发(参考<a href="https://ficapy.com/2017/03/12/ssh-port-forward/">ssh端口映射</a>)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R 8899:localhost:8899 remote_server</div></pre></td></tr></table></figure>
<p>将远程主机上的8899端口映射到本机的8899端口</p>
<h2 id="3-远程主机使用本地的http代理进行环境初始化"><a href="#3-远程主机使用本地的http代理进行环境初始化" class="headerlink" title="3.远程主机使用本地的http代理进行环境初始化"></a>3.远程主机使用本地的http代理进行环境初始化</h2><p>可以使用如下命令进行测验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -x http://localhost:8899 ip.cn</div></pre></td></tr></table></figure>
<p>比如使用pypi安装tornado执行如下命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --proxy http://localhost:8899 tornado</div></pre></td></tr></table></figure>
<p>思路是这样。其它同理~~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到有人反映可能是内网环境。无法访问外部网络。安装初始化环境的时候好像颇为不便。其实只要能ssh上去。这一切都不是问题。就是各种转发，以下以内网使用pip安装第三方依赖包为例说明该如何操作&lt;/p&gt;
&lt;h2 id=&quot;1-本机开启一个临时的http代理&quot;&gt;&lt;a href=&quot;#1
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>开发环境中数据库快速回滚</title>
    <link href="https://www.zoulei.net/2017/07/15/develop_quick_restore_postgresql_database/"/>
    <id>https://www.zoulei.net/2017/07/15/develop_quick_restore_postgresql_database/</id>
    <published>2017-07-15T05:24:19.000Z</published>
    <updated>2017-07-15T07:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发中总会遇到一些测试需要回滚数据库。常规的单元测试的做法是在单个会话中不真正的写入到数据库。而是测试完成后进行数据库回滚。大多数情况下这样都是满足要求的。只是有的时候需要数据库真正的写入到数据库。此时rollback回滚就有些乏力了。此时给数据库做一个备份，测试完成后回滚是一种不错的主意。Postgresql数据库的常规备份我们会使用pg_dump和pg_restore进行导出和恢复。此时如何快速的进行这个操作是我们关注的话题</p>
<p>很幸运。很顺利的搜到了答案。6年前有人在stackexchange上提问同样的问题。得到了一些有用的回复。大概有这些</p>
<ul>
<li>使用文件系统级快照LVM</li>
<li>使用CREATE  DATABASE … TEMPLATE语法</li>
<li>将数据库放在虚拟机里面。使用虚拟机快照</li>
</ul>
<p>其中最有效的方案是二。因为LVM在个人笔记本上难以实施。虚拟机恢复时间较慢。依据方案二于是乎有人写了一个工具 <a href="https://github.com/fastmonkeys/stellar">stellar</a>。粗略读了一下源码。其具体原理大概如下图<br><img src="https://ficapy.b0.upaiyun.com/blogimg/backup_and_restore_flow.jpg" alt="backup_and_restore_flow"></p>
<p>备份的时候使用create database … template创建2个备份。恢复的时候删掉原有的数据库。将一个备份重命名为原有的名称。另外的一个备份再生成一个备份就完成了。另外删除新建数据库操作均会关闭所有已连接的数据库会话。</p>
<p>因为类似文件系统级快照，所以方法极快。我本机2G的数据库文件，创建一个快照大概十秒钟左右，恢复就更快了。当然缺点也是有的，你每创建一个快照都会新增2个一样大小的副本，相当的占据硬盘空间，可是为了速度这点缺陷也就微不足道了┑(￣Д ￣)┍</p>
<p>另外一个小缺点。因为它定位于测试环境下的数据库备份恢复。所以只连接一台机器。比如你一个数据库在机器A,一个数据库在机器B.赛高~~，那你只能在2个目录下使用2个配置文件来完成了。如果同一个机器上的多个数据库是可以直接备份的。再就是此工具比较专注于Postgresql。对于Mysql就不那么友好了。或许是Mysql的备份方案不一样</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><code>stellar init</code> 按照提示输入本机数据库访问路径生成配置文件</li>
<li><code>stellar snapshot</code> 生成一个快照</li>
<li><code>stellar restore &lt;snap1&gt;</code> 恢复</li>
<li>其他请看 <code>stellar --help</code></li>
</ol>
<p>( ⊙ o ⊙ )啊！ 多么爽快，世界真美妙</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dba.stackexchange.com/questions/3394/is-it-possible-to-quickly-create-restore-database-snapshots-with-postgresql">Is it possible to quickly create/restore database snapshots with PostgreSQL?</a><br><a href="https://github.com/fastmonkeys/stellar">github stellar</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中总会遇到一些测试需要回滚数据库。常规的单元测试的做法是在单个会话中不真正的写入到数据库。而是测试完成后进行数据库回滚。大多数情况下这样都是满足要求的。只是有的时候需要数据库真正的写入到数据库。此时rollback回滚就有些乏力了。此时给数据库做一个备份，测试完成后回滚
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker CD初探-Drone</title>
    <link href="https://www.zoulei.net/2017/07/05/drone/"/>
    <id>https://www.zoulei.net/2017/07/05/drone/</id>
    <published>2017-07-05T13:51:26.000Z</published>
    <updated>2017-07-05T16:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有个小需求，我们公司写文档是通过<a href="https://github.com/lord/slate">slate</a>来的。每一次文档编写完成之后都需要执行<code>bundle exec middleman build --clean</code>生成静态文件。然后再使用rsync来进行上传操作。虽然只有2步。但是做的次数多了难免也让人觉得厌烦。萌生了自动化处理的想法。比较粗暴的方式有。每隔几分钟去检测一次git版本库是否有更新(以前本人真这样实现过)，自己写个小web程序。设置webhook。接收到webhook再拉取进行操作(我也实现过，目前一切运行良好)。现在尝试下使用可持续集成的套路去实现。</p>
<a id="more"></a>
<p>说一下第三种方案相对前两种方案的特点。</p>
<ul>
<li>集中化管理。第一二种方案都需要将脚本放在对应的应用机器上面。第三种不需要，它集中化了。所有的webhook都在可持续集成平台处理。由平台再来操控应用。而且每一次触发操作都有详尽的日志。集中在一起比较容易看出哪里出了什么问题</li>
<li>不需要在每一台应用机处理webhook(处理意味着每个应用机都需要绑定一个域名)，可能和上面的集中化管理的优点是一个意思吧</li>
<li>对于一个良好的架构。可持续集成平台比零散的脚本无疑更合适</li>
<li>算是一个缺点。单独写脚本独立处理webhook相对可持续集成更容易</li>
</ul>
<h3 id="Drone配置"><a href="#Drone配置" class="headerlink" title="Drone配置"></a>Drone配置</h3><p>docker-compose我都不大用了，直接用docker stack deploy替代。后者相对前者实际没有什么区别。或者说前者是因为docker网络配置欠发达的产物。docker-compose适合单机部署，docker-swarm适合多主机。开启docker-swarm只需要docker swarm init大概就可以了，更详细的知识请查看官方文档</p>
<p>drone.yml 文件大概如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line"></div><div class="line">services:</div><div class="line">  drone-server:</div><div class="line">    image: drone/drone:0.7</div><div class="line">    ports:</div><div class="line">      - 82:8000</div><div class="line">    volumes:</div><div class="line">      - /data/github_drone:/var/lib/drone/</div><div class="line">    environment:</div><div class="line">      - DRONE_OPEN=false</div><div class="line">      - DRONE_ADMIN=ficapy</div><div class="line">      - DRONE_GITLAB=true</div><div class="line">      - DRONE_GITHUB_CLIENT=xxxxxxxxx</div><div class="line">      - DRONE_GITHUB_SECRET=xxxxxxxxxx</div><div class="line">      - DRONE_SECRET=xxxpwdxxx</div><div class="line"></div><div class="line">  drone-agent:</div><div class="line">    image: drone/drone:0.7</div><div class="line">    command: agent</div><div class="line">    depends_on:</div><div class="line">      - drone-server</div><div class="line">    volumes:</div><div class="line">      - /var/run/docker.sock:/var/run/docker.sock</div><div class="line">    environment:</div><div class="line">      - DRONE_SERVER=ws://drone-server:8000/ws/broker</div><div class="line">      - DRONE_SECRET=xxxpwdxxx</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>然后执行<code>docker stack deploy --compose-file=drone.yml drone</code>，整个程序就运行起来了。此处是监听81端口。从配置文件中也可以猜一个大概。了解下drone的流程。service主要用来响应浏览器端的请求。接收到请求后使用websocket和agent通信用来下发任务获取结果。agent通过/var/run/docker.sock来和docker daemon进行通信。执行创建容器。执行命令等一系列过程。</p>
<p>有几点需要注意的</p>
<ul>
<li>最好指定管理员用户DRONE_ADMIN，因为有些操作需要admin权限</li>
<li>DRONE_OPEN设置为true的时候所有的用户都能授权后使用你的Drone进行集成测试。这往往是你不愿意的，个人的诉求往往是私有的</li>
<li>github和gitlab在一个drone不能同时使用，所以我部署了两套，使用了不同的域名</li>
<li>起码了解OAuth流程和webhook的过程，才能更好的理解整套流程</li>
<li>其他事宜可以查看Drone的<a href="http://docs.drone.io/installation/">安装文档</a></li>
</ul>
<p>之所以监听81端口，是因为我使用的Caddy当做前置web服务器。配置如下Caddyfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">drone.ficapy.com &#123;</div><div class="line">    proxy / dockerhost:81 &#123;</div><div class="line">        websocket</div><div class="line">        transparent</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的docker-compose文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  Caddy:</div><div class="line">    image: &quot;abiosoft/caddy&quot;</div><div class="line">    volumes:</div><div class="line">      - /root/caddy/Caddyfile:/etc/Caddyfile</div><div class="line">      - /root/.caddy:/root/.caddy</div><div class="line">    ports:</div><div class="line">      - &quot;80:80&quot;</div><div class="line">      - &quot;443:443&quot;</div><div class="line">    extra_hosts:</div><div class="line">      - &quot;dockerhost:$&#123;dockerhost&#125;&quot;</div></pre></td></tr></table></figure>
<p>此处使用了环境变量dockerhost，我将它写入了zshrc配置文件中<code>export dockerhost=&quot;172.17.0.1&quot;</code>,不难看出只是为了转发请求, 和drone一样。执行<code>docker stack deploy --compose-file=caddy_compose.yml caddy</code>启动</p>
<h3 id="持续集成部署"><a href="#持续集成部署" class="headerlink" title="持续集成部署"></a>持续集成部署</h3><p>当使用Drone，并授权之后。Drone会自动给你的项目加上webhook地址。我们在项目根目录放置.drone.yml文件后会使用docker自动构建</p>
<p>实现本文开头说的需求.drone.yml文件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">pipeline:</div><div class="line">  build:</div><div class="line">    image: ruby:2.3</div><div class="line">    commands:</div><div class="line">      - bundle config mirror.https://rubygems.org https://gems.ruby-china.org</div><div class="line">      - bundle install</div><div class="line">      - apt-get update &amp;&amp; apt-get install nodejs rsync -y &amp;&amp; bundle exec middleman build --clean</div><div class="line">      - rsync -r --rsh=&apos;ssh -o LogLevel=ERROR -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -i /data/id_rsa -p 22&apos; build/* user@host:~/docs --progress --delete</div><div class="line">    volumes:</div><div class="line">      - /data:/data</div><div class="line">    when:</div><div class="line">      branch: master</div></pre></td></tr></table></figure></p>
<p>在使用之前。我现在/data目录使用ssh-agent生成了密匙对。在目标主机上放上公钥，让我们能够ssh连接远端主机。然后容器创建的时候将密匙挂载到容器目录(此处需要管理员权限将项目设置为可信)。然后就顺理成章了。搭建环境，生成静态文件，rsync同步就完成了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有个小需求，我们公司写文档是通过&lt;a href=&quot;https://github.com/lord/slate&quot;&gt;slate&lt;/a&gt;来的。每一次文档编写完成之后都需要执行&lt;code&gt;bundle exec middleman build --clean&lt;/code&gt;生成静态文件。然后再使用rsync来进行上传操作。虽然只有2步。但是做的次数多了难免也让人觉得厌烦。萌生了自动化处理的想法。比较粗暴的方式有。每隔几分钟去检测一次git版本库是否有更新(以前本人真这样实现过)，自己写个小web程序。设置webhook。接收到webhook再拉取进行操作(我也实现过，目前一切运行良好)。现在尝试下使用可持续集成的套路去实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://www.zoulei.net/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>理解metaclass</title>
    <link href="https://www.zoulei.net/2017/03/24/python_metaclass/"/>
    <id>https://www.zoulei.net/2017/03/24/python_metaclass/</id>
    <published>2017-03-24T01:34:48.000Z</published>
    <updated>2017-05-31T08:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>metaclass一直被归类为比较高深的内容，写代码也很少会使用到metaclass。然而如果你看某些项目的源代码，还是会被绕到metaclass里面去。花一些时间理解下metaclass很有用的，因为它真的能把一条线串起来，环环相扣，所以有扎实的基础是掌握metaclass的前提，本文代码基于python3.5</p>
<a id="more"></a>
<p>你只需要理解以下2点</p>
<ol>
<li>metaclass和<code>__new__</code>、<code>__init__</code>并没有非常非常深的关系</li>
<li>type(name, bases, dict)生成了一个object类，了解三个参数分别指代了什么</li>
</ol>
<p>了解python中有这样一条关系链type-&gt;object-&gt;instance,通常我们写类默认会继承自object。从关系链就能知道type能够生成object。代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></div><div class="line">        attrs.pop(<span class="string">'e'</span>)</div><div class="line">        print(<span class="string">'1'</span>, cls, name, bases, attrs)</div><div class="line">        cls.a = <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, attrs)</div><div class="line"></div><div class="line">    <span class="comment"># def __call__(self, *args, **kwargs):</span></div><div class="line">    <span class="comment">#     print('3')</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attrs)</span>:</span></div><div class="line">        self.b = <span class="number">2</span></div><div class="line">        print(<span class="string">'2'</span>, self, name, bases, attrs)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(metaclass=A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line">        print(<span class="string">'4'</span>, args, kwargs)</div><div class="line">        cls.c = <span class="number">4</span></div><div class="line">        <span class="keyword">return</span> super().__new__(cls)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">e</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        print(<span class="string">'5'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d)</span>:</span></div><div class="line">        self.d = d</div><div class="line">        print(<span class="string">'6'</span>)</div><div class="line"></div><div class="line"></div><div class="line">b = B(<span class="number">6</span>)</div><div class="line">print(hasattr(b, <span class="string">'a'</span>))</div><div class="line">print(b.b)</div><div class="line">print(b.c)</div><div class="line">print(b.d)</div><div class="line">print(hasattr(b, <span class="string">'e'</span>))</div></pre></td></tr></table></figure>
<p>可以尝试注释掉B(12)，A依旧会被打印，观察args和kwargs的输出。对比A和B的不同，你会发现metaclass的用处，<strong>使用metaclass的时候，B的所有属性会被当做参数传递给A</strong>，那么我们能够将这些传过来的参数预处理然后挂在到类的属性上面返回。以供后续B使用。目前在我遇到的web开发中体现的最常见的就是ORM和表单验证。</p>
<p>我们知道<code>__new__</code>创建一个对象。<code>__init__</code>对创建后的对象进行赋值等初始化操作。他们的传参args和kwargs是没有区别的。但是在<code>__new__</code>阶段，能够对attrs进行修改从而hook对象的创建流程，除此之外感觉只能用new不能用init的场景是很少的。目前看到的例子记得的可能只有用new实现单例。对于内置不可变对象比如int用new变更初始化逻辑</p>
<p>最后例举一个ORM的例子(见参考)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, column_type)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.column_type = column_type</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        super(StringField, self).__init__(name, <span class="string">'vachar(100)'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaclass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></div><div class="line">        <span class="keyword">if</span> name != <span class="string">'Model'</span>:</div><div class="line">            mappings = &#123;k: v.name <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items() <span class="keyword">if</span> isinstance(v, Field)&#125;</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</div><div class="line">                attrs.pop(k)</div><div class="line">            attrs[<span class="string">'__mappings__'</span>] = mappings</div><div class="line">            attrs[<span class="string">'__table__'</span>] = name</div><div class="line"></div><div class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict, metaclass=ModelMetaclass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></div><div class="line">        super().__init__(**kwargs)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self[key]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Model' object has no attribute &#123;key&#125;"</span>.format(key=key))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self[key] = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></div><div class="line">        fields, params, args = [], [], []</div><div class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</div><div class="line">            fields.append(v)</div><div class="line">            params.append(<span class="string">'?'</span>)</div><div class="line">            args.append(getattr(self, k, <span class="keyword">None</span>))</div><div class="line">        sql = <span class="string">'insert into &#123;table_name&#125; (&#123;fields&#125;) values (&#123;values&#125;)'</span>.format(table_name=self.__table__,</div><div class="line">                                                                             fields=<span class="string">','</span>.join(fields),</div><div class="line">                                                                             values=<span class="string">','</span>.join(params))</div><div class="line">        print(<span class="string">'SQL: &#123;sql&#125;'</span>.format(sql=sql))</div><div class="line">        print(<span class="string">'ARGS: &#123;args&#125;'</span>.format(args=args))</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span><span class="params">(Model)</span>:</span></div><div class="line">    user_name = StringField(<span class="string">'username'</span>)</div><div class="line">    email = StringField(<span class="string">'email'</span>)</div><div class="line">    password = StringField(<span class="string">'password'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    user = UserModel(user_id=<span class="number">123</span>, user_name=<span class="string">'hhh'</span>, email=<span class="string">'a@a.a'</span>, password=<span class="string">'asdfa'</span>, x=<span class="string">'y'</span>)</div><div class="line">    user.save()</div><div class="line">    </div></pre></td></tr></table></figure>    </p>
<p>下篇会分析metaclass在WTForms中的应用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/">Understanding Python metaclasses 更详细的介绍</a><br><a href="http://www.jianshu.com/p/9dfa40bf2a62">python实现ORM</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;metaclass一直被归类为比较高深的内容，写代码也很少会使用到metaclass。然而如果你看某些项目的源代码，还是会被绕到metaclass里面去。花一些时间理解下metaclass很有用的，因为它真的能把一条线串起来，环环相扣，所以有扎实的基础是掌握metaclass的前提，本文代码基于python3.5&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>tornado表单验证</title>
    <link href="https://www.zoulei.net/2017/03/23/tornado_wtforms/"/>
    <id>https://www.zoulei.net/2017/03/23/tornado_wtforms/</id>
    <published>2017-03-23T12:17:29.000Z</published>
    <updated>2017-03-23T12:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中看到有一些不好的代码，想了个办法优化了一下，于是有了这篇博文。本文主要讲tornado的表单验证，使用的是wtforms。本文最终达到的效果是使用self.xx获取post传递过来的值。</p>
<a id="more"></a>
<p>首先是将wtforms嵌入tornado。做法可以参考<a href="https://github.com/truemped/tornadotools/blob/master/tornadotools/forms.py">https://github.com/truemped/tornadotools/blob/master/tornadotools/forms.py</a>，我的做法类似，可以看最下面的代码。这样继承一下就能够使用wtforms的表单验证了。能够使用的结果是很多人写这样的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.xx1 = self.form.xx1.data</div><div class="line">self.xx2 = self.form.xx2.data</div><div class="line">self.xx3 = self.form.xx3.data</div><div class="line">:</div><div class="line">:</div></pre></td></tr></table></figure>
<p>然后这样写了20行(不黑，项目里真有这样的)。写的人也确实是很认真啊！，改进的方法很简单。调用self.xx1的时候自动取值self.form.xx1.data。能做成这样的方法挺多。很多时候会导致self.xxx使用IDE无法补全。我个人认为好的代码肯定能够方便的补全和提示，毕竟这样能实打实的提升码代码的心情，试想一下你要输入20个单词，很可能一不小心就输入错误了。改进的方法就是使用<code>__getattribute__</code>,配合类继承，兼顾自动补全也不用跑去写self.form.xxx.data了</p>
<ol>
<li><code>__getattr__</code>，当属性不存在的时候会调用</li>
<li><code>__getattribute__</code>,无论属性是否存在都会被调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">import tornado.ioloop</div><div class="line">import tornado.web</div><div class="line"></div><div class="line">from wtforms import validators, fields</div><div class="line">from wtforms import Form</div><div class="line">from wtforms.fields.core import UnboundField</div><div class="line"></div><div class="line"></div><div class="line">class MultiDict(dict):</div><div class="line">    def getlist(self, key):</div><div class="line">        return self[key]</div><div class="line"></div><div class="line">    def setlist(self, key, value):</div><div class="line">        self[key] = value</div><div class="line"></div><div class="line"></div><div class="line">class BaseForm(Form):</div><div class="line">    def __init__(self, handler=None, obj=None, prefix=&apos;&apos;, **kwargs):</div><div class="line">        if handler is None:</div><div class="line">            return</div><div class="line">        formdata = MultiDict()</div><div class="line">        if handler.request.method == &apos;POST&apos;:</div><div class="line">            for name in handler.request.arguments.keys():</div><div class="line">                formdata.setlist(name, handler.get_arguments(name))</div><div class="line">        else:</div><div class="line">            for name in handler.request.query_arguments.keys():</div><div class="line">                formdata.setlist(name, handler.request.query_arguments[name])</div><div class="line">        Form.__init__(self, formdata, obj=obj, prefix=prefix, **kwargs)</div><div class="line"></div><div class="line"></div><div class="line">class LoginForm(BaseForm):</div><div class="line">    email = fields.StringField(</div><div class="line">        validators=[validators.Email(), validators.required(), validators.length(min=5, max=64)])</div><div class="line">    password = fields.PasswordField(validators=[validators.required()])</div><div class="line"></div><div class="line"></div><div class="line">class MainHandler(tornado.web.RequestHandler, LoginForm):</div><div class="line">    def __getattribute__(self, item):</div><div class="line">        ret = object.__getattribute__(self, item)</div><div class="line">        if isinstance(ret, UnboundField):</div><div class="line">            form = object.__getattribute__(self, &apos;form&apos;)</div><div class="line">            return getattr(form, item).data</div><div class="line">        return ret</div><div class="line"></div><div class="line">    def post(self):</div><div class="line">        self.form = LoginForm(self)</div><div class="line">        print(self.email)</div><div class="line">        self.write(&quot;Hello, world&quot;)</div><div class="line"></div><div class="line"></div><div class="line">def make_app():</div><div class="line">    return tornado.web.Application([</div><div class="line">        (r&quot;/&quot;, MainHandler),</div><div class="line">    ])</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    app = make_app()</div><div class="line">    app.listen(8888)</div><div class="line">    tornado.ioloop.IOLoop.current().start()</div></pre></td></tr></table></figure>
<p>完美解决问题,心情瞬间舒畅了┑(￣Д ￣)┍</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中看到有一些不好的代码，想了个办法优化了一下，于是有了这篇博文。本文主要讲tornado的表单验证，使用的是wtforms。本文最终达到的效果是使用self.xx获取post传递过来的值。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>ssh端口映射</title>
    <link href="https://www.zoulei.net/2017/03/12/ssh-port-forward/"/>
    <id>https://www.zoulei.net/2017/03/12/ssh-port-forward/</id>
    <published>2017-03-12T03:40:30.000Z</published>
    <updated>2017-06-01T07:30:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发中经常会需要用到端口映射这种事情。以前觉得好容易混淆。其实用习惯了就会发现如此简单┑(￣Д ￣)┍，下面联系到我日常使用到的一些ssh映射实例讲解一下</p>
<a id="more"></a>
<ol>
<li><p>-D参数，提供一个socket5级别的代理。</p>
<p> 这个在很多年以前翻墙的时候还是很好用的。不过都已经成为了历史。有代理使用经验的开发者都能很快理解这个玩意</p>
</li>
<li><p>-L(local forward)本地转发</p>
<p> 比如你现在需要连接到正式环境的数据库,那么你不需要先ssh到正式环境再输入数据库命令。我的做法是选择用图形界面查看数据库。命令是这样的 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L  6789:192.168.10.10:5432 prod</div></pre></td></tr></table></figure>
<p> 含义就是将本地6789端口接受到的请求转发到生产环境prod上面的192.168.10.10:5432，这样本地GUI数据库管理程序就能够直接连接本地6789端口显示线上数据了。可以看出它的作用就是将本地端口的请求转发的服务器上面</p>
</li>
<li><p>-R(Remote forward)远程转发</p>
<p> 这个就是和本地转发相反。在连接的服务器上打开一个端口，映射到自己的端口。此时数据流是服务器端口接收到的数据传到了本地。比如你需要一个公网ip(显然我们的办公环境都是没有公网ip的)来调试你的web应用，比如你本地写了个web程序监听8989端口，你远程服务器上有公网ip。你需要把web程序临时分享到公网给别人尝试使用。执行以下命令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R 4321:127.0.0.1:8989 prod</div></pre></td></tr></table></figure>
<p> 这样别人访问prod_ip:4321就会映射到你本地的8989端口上。</p>
</li>
<li><p>助记</p>
<p> 刚开始可能觉得端口比较容易混淆。只需要记住xx:xx，前面是入口，后面是出口。本地转发的时候数据是从本地发到远程。所以6789是本地端口。远程转发的时候数据是从远程发到本地。所以8989是本地端口</p>
</li>
<li><p>辅助参数及工具</p>
<p> 假如你只需要端口映射不需要进入终端执行命令。可以增加-Nf参数，-N为不进入交互式终端。f为后台执行。假如你需要长期使用，那就使用autossh，和ssh一个套路。就不举例了</p>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>其实本地转发和远程转发已经形成了一个双向的数据流动。这样我们就能够实现一些看起来很高级的功能。比如访问内网机器(没有公网ip，不能够被直接访问到)。只要内网机器能够使用ssh访问到外部机器，而这台外部机器我们能够进行访问。那么此时就是搭配本地转发和远程转发的时候了。(注意，如果外部机器能够和内部机器双向访问那么会更简单)</p>
<p>思路就是使用内网机器访问外部机器，使用远程端口映射，将本机的22端口映射到外部机器的任一端口上。之后在外部机器就能够使用ssh localhost -p xx访问到内网机器了。然而这需要我们先登录到外部机器再使用localhost登陆到内网。此时我们可以更简单的使用~/.ssh/config配置文件完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Host demo</div><div class="line">    user    ficapy</div><div class="line">    HostName    localhost</div><div class="line">    ProxyCommand ssh prod -W %h:7890</div></pre></td></tr></table></figure>
<p>ssh demo后会先连接外部机器prod,再将请求转发到localhost:7890上完成对内部机器的登陆。<br>假如内部机器和外部机器可以双向访问，那么就不需要远程端口转发，只需要这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Host demo</div><div class="line">    User ficapy</div><div class="line">    HostName 内网机器ip</div><div class="line">    ProxyCommand ssh prod -W %h:%p</div></pre></td></tr></table></figure>
<h3 id="更坑爹的情况"><a href="#更坑爹的情况" class="headerlink" title="更坑爹的情况"></a>更坑爹的情况</h3><p>在严格的环境下，假如禁用了ssh协议。不允许从内部ssh到外部。只允许对外发送http、https请求。此时ssh、ngrok1.7版本、frp这种是无法使用的。推荐使用pagekite自建，亦或者使用速度暴慢的ngrok付费版<br>遇到过一个问题。测试机上需要访问10.19.2.96的1234和5053端口。处理方案是将10.19.2.96此ip绑定到网卡上面配合ssh转发，<code>sudo ifconfig en0 10.19.15.34 netmask 255.255.255.0 up</code>。然后<code>ssh -NL 10.19.15.34:1234:10.19.15.34:1234 -L 10.19.15.34:5053:10.19.15.34:5053 dev</code>就可以了</p>
<h3 id="收集的ssh配置文件（更好的连接到远端服务器）"><a href="#收集的ssh配置文件（更好的连接到远端服务器）" class="headerlink" title="收集的ssh配置文件（更好的连接到远端服务器）"></a>收集的ssh配置文件（更好的连接到远端服务器）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Host	   *</div><div class="line">	Port          		 22</div><div class="line">    User          		 root</div><div class="line">    IdentityFile  		 ~/.ssh/id_rsa</div><div class="line">    ConnectTimeout 		15</div><div class="line">    ConnectionAttempts 	3</div><div class="line">    ServerAliveInterval 	20</div><div class="line">    ServerAliveCountMax 	5		</div><div class="line">    # 多条连接共享</div><div class="line">    ControlMaster   	auto</div><div class="line">    ControlPath     	/tmp/ssh_mux_%h_%p_%r</div><div class="line">    # 长连接(退出服务器后连接依然可重用)</div><div class="line">    ControlPersist  	4h</div><div class="line">    # 减少延迟</div><div class="line">    GSSAPIAuthentication 	no</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中经常会需要用到端口映射这种事情。以前觉得好容易混淆。其实用习惯了就会发现如此简单┑(￣Д ￣)┍，下面联系到我日常使用到的一些ssh映射实例讲解一下&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://www.zoulei.net/categories/DevOps/"/>
    
    
  </entry>
  
  <entry>
    <title>使用acme.sh快速搭建https</title>
    <link href="https://www.zoulei.net/2017/03/05/acme.sh_quick_start/"/>
    <id>https://www.zoulei.net/2017/03/05/acme.sh_quick_start/</id>
    <published>2017-03-05T09:19:27.000Z</published>
    <updated>2017-07-29T15:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>letsencrypt刚出来的时候写了一篇它的认证签发原理。自那过后就没有真正的去实践过了。最近有部署HTTPS的需求就又考察了一番。发现acme.sh灰常好用啊~~~，来一篇水文记录下测试部署HTTPS的完整过程吧</p>
<a id="more"></a>
<p><a href="media/README-1.md">README</a></p>
<p>首先有2种认证方式，生成一个指定的文件让letsencrypt访问。或者生成一个DNS记录让letsencrypt访问。第一种方式有非常大的局限性。比如你的80端口正在被使用。那么你需要先设置DNS解析，再修改下nginx的配置让网址能够被正常访问到。这就显得很麻烦了。主流的DNS服务提供商都已经提供了API接口，使用DNS的优势就是：</p>
<ol>
<li>任何电脑都能直接生成证书文件，不需要依赖本机能够被外部访问</li>
<li>不需要对nginx做任何设置</li>
</ol>
<p>以下记录下我使用一个临时的digitalocean机器从0开始部署https的步骤(假设测试url为ssl.ficapy.com,操作环境为osx)</p>
<p>我还是要安利下，临时使用digitalocean测试使用命令行工具tugboat灰常好啊</p>
<ol>
<li><p>安装tugboat用命令行快速创建机器以及测试完成后删除</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install tugboat</div></pre></td></tr></table></figure>
</li>
<li><p>将digitalocean的api写入让tugboat能够正常使用,并执行一些初始化设置</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tugboat authorize</div></pre></td></tr></table></figure>
</li>
<li><p>根据初始化默认设置创建一个vps</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tugboat create temp</div></pre></td></tr></table></figure>
</li>
<li><p>ssh登陆</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tugboat ssh temp</div></pre></td></tr></table></figure>
</li>
<li><p>安装acme.sh</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl https://get.acme.sh | sh</div></pre></td></tr></table></figure>
</li>
<li><p>参照acme.sh文档将dns的api信息作为环境变量写入(记得执行source ~/.bashrc)</p>
</li>
<li><p>生成证书</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">acme.sh --issue --dns dns_cf -d ssl.ficapy.com --debug</div></pre></td></tr></table></figure>
</li>
<li><p>将证书放置到位置并设置nginx重启命令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">acme.sh --installcert -d ssl.ficapy.com \</div><div class="line">           --keypath       /etc/nginx/ssl/ssl.ficapy.com.key  \</div><div class="line">           --fullchainpath /etc/nginx/ssl/ssl.ficapy.com.pem \</div><div class="line">           --reloadcmd     &quot;service nginx force-reload&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>强制测试续约(该操作会自动执行注册过的事件，一般就是重启nginx咯，续约key是不会变的，变的是fullchain.cer文件)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">acme.sh --renew-all --force</div></pre></td></tr></table></figure>
</li>
<li><p>生成dhparam文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048</div></pre></td></tr></table></figure>
</li>
<li><p>使用生成一个标准的nginx配置文件并放入/etc/nginx/site-enables目录，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">    server &#123;</div><div class="line">    listen 443 ssl;</div><div class="line"></div><div class="line">    server_name ssl.ficapy.com;</div><div class="line">    # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate</div><div class="line">    ssl_certificate /etc/nginx/ssl/ssl.ficapy.com.pem;</div><div class="line">    ssl_certificate_key /etc/nginx/ssl/ssl.ficapy.com.key;</div><div class="line">    ssl_session_timeout 1d;</div><div class="line">    ssl_session_cache shared:SSL:50m;</div><div class="line"></div><div class="line"></div><div class="line">    # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits</div><div class="line">    ssl_dhparam /etc/nginx/ssl/dhparam.pem;</div><div class="line"></div><div class="line">    # intermediate configuration. tweak to your needs.</div><div class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    ssl_ciphers &apos;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&apos;;</div><div class="line">    ssl_prefer_server_ciphers on;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>最后就是浏览器访问以下测试完毕啦。如果出现错误可以查看nginx的日志/var/log/error.log，肯定是哪一步出问题啦，最后就是测试完毕后删除vps啦<code>tugboat destory temp</code></p>
</li>
</ol>
<p>额外说一下其他的吧。最开始我试过阿里云dns的api，用的是子账号。结果子账号是无法包含(注意)dns的操作权限的，就总是失败。后来不用子账号，直接用原账号的api密匙就完全没问题啦~~~。另外各大云平台大多都有负载均衡器，然后可以填写https证书。这种就不太适合letsencrypt这种短期证书了。否则总上去换证书不被麻烦死。如果在这种负载均衡器上不设置https证书。那么就需要在负载均衡器每一台机器都设置上https证书，嗯想想也挺头大啊~~~，所以这种自动化方式只比较适合在一台机器上生成并维护证书</p>
<p>再额外，哪个时候写个Ansible的playbook就好哒，可能会更加方便┑(￣Д ￣)┍</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/pearkes/tugboat">github tugboat</a><br><a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">mozilla ssl-config-generator</a><br><a href="https://ruby-china.org/topics/31983">使用 acme.sh 给 Nginx 安装 Let’ s Encrypt 提供的免费 SSL 证书</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;letsencrypt刚出来的时候写了一篇它的认证签发原理。自那过后就没有真正的去实践过了。最近有部署HTTPS的需求就又考察了一番。发现acme.sh灰常好用啊~~~，来一篇水文记录下测试部署HTTPS的完整过程吧&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="https://www.zoulei.net/categories/DevOps/"/>
    
    
  </entry>
  
  <entry>
    <title>使用pre-commit改进代码风格</title>
    <link href="https://www.zoulei.net/2017/03/04/pre_commit/"/>
    <id>https://www.zoulei.net/2017/03/04/pre_commit/</id>
    <published>2017-03-04T04:52:37.000Z</published>
    <updated>2017-03-04T10:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早就使用过autopep8来自动格式化代码，使用IDE的时候也会经常使用格式化代码功能让代码更符合规范一点。可是这都不是自动化的，或者说是强制的。为了保持团队的良好代码风格感觉每个同事在提交代码之前都自动进行格式化或者风格检查是一个不错的主意，于是找到了<a href="http://pre-commit.com/">pre-commit</a></p>
<p>原理也还是很简单的，git自身提供了一些hook功能，查看git/hooks目录下会发现有一些sample文件，这样在执行commit、push、merge的时候都是可以进行一些简单的检查等功能的。然而这个设定有一个缺点。没一个hook只能执行一个文件的内容，所以要么将各种功能放在一个文件里面，或者每个功能都放置在各自的文件里面。最后由一个文件一起执行。pre-commit就解决了我们的这个文件。将不同的任务分割成单个文件。然后只需要添加别人共享的脚本就能够很快的进行commit hook了，简要使用方法例举如下</p>
<ol>
<li><p>在项目根目录下编写配置文件(.pre-commit-config.yaml)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-   repo: git://github.com/pre-commit/pre-commit-hooks</div><div class="line">    sha: v0.7.1</div><div class="line">    hooks:</div><div class="line">    -   id: trailing-whitespace</div><div class="line">    -   id: autopep8-wrapper</div></pre></td></tr></table></figure>
</li>
<li><p>进行初始化<code>pre-commit install</code>就可以了，以后每次执行commit的时候就会执行检查。配置文件的repo地址即为符合pre-commit框架的地址，id即为提供的功能~~，还是很好理解的。例如以上提供的autopep8-wrapper就可能够配置pep8规范进行一些代码风格检查，如果不符合风格就会自动格式化。pep8工具的默认配置文件是<code>~/.config/pep8</code></p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sideci.com/2015/12/14/style-guide-of-python-and-lint-tool/">About style guide of python and linter tool. pep8, pyflakes, flake8, haking, Pyling.</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早就使用过autopep8来自动格式化代码，使用IDE的时候也会经常使用格式化代码功能让代码更符合规范一点。可是这都不是自动化的，或者说是强制的。为了保持团队的良好代码风格感觉每个同事在提交代码之前都自动进行格式化或者风格检查是一个不错的主意，于是找到了&lt;a href=&quot;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>supervisor遇到的坑</title>
    <link href="https://www.zoulei.net/2016/12/25/supervisor_may_be_sucks/"/>
    <id>https://www.zoulei.net/2016/12/25/supervisor_may_be_sucks/</id>
    <published>2016-12-25T12:01:43.000Z</published>
    <updated>2017-01-11T08:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>写几条自己用supervisor遇到的一些小坑</p>
<ol>
<li><a href="https://python3wos.appspot.com/">Python 3 Wall</a>的反派代表，一直不能使用python3安装</li>
<li>对中文输出支持奇差，估计是使用python2造成的，举个例子，假如你要在python2里面print输出一个unicode中文字符。我试了各种办法，均无解(和supervisor使用子进程运行程序的策略有关),好在使用logging模块输出中文居然没啥问题-_-，正式运行环境也是全部使用logging代替print</li>
<li>即使用python3，输出中文也会遇到问题,需要在配置文件添加<code>environment=LANG=&quot;en_US.utf8&quot;, LC_ALL=&quot;en_US.UTF-8&quot;, LC_LANG=&quot;en_US.UTF-8&quot;</code>解决</li>
<li>写配置文件的时候一个变量不能配置多行,我一开始因为environment太长。写了2行，导致后面的没生效，折腾好久</li>
<li>修改supervisor配置文件后，如果配置文件错了，不会报错！而且supervisor没有工具能对配置文件的正确性进行检查，灰常操蛋啊！</li>
<li>supervisor可以检查到异常自动重启并设置最大重启次数，可是有时候会造成无限重启这种情况。因为重启后立刻退出才会触发最大重启次数机制，假如程序一直是运行了十分钟自动退出。那么会造成无限重启，可以使用它的api写一个脚本监控这种情况，进行警告</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> xmlrpc.client</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_time</span><span class="params">(name: str, interval: int, times: int)</span>:</span></div><div class="line">    s = xmlrpc.client.ServerProxy(<span class="string">'http://localhost:9001'</span>)</div><div class="line">    <span class="keyword">if</span> s.supervisor.getProcessInfo(name).get(<span class="string">'statename'</span>) != <span class="string">'RUNNING'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    context = s.supervisor.readLog(<span class="number">0</span>, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">100</span>)</div><div class="line">    context = filter(<span class="keyword">lambda</span> x: name <span class="keyword">in</span> x <span class="keyword">and</span> <span class="string">'spawn'</span> <span class="keyword">in</span> x, context.splitlines())</div><div class="line">    context = map(<span class="keyword">lambda</span> x: datetime.strptime(x[:<span class="number">19</span>], <span class="string">'%Y-%m-%d %H:%M:%S'</span>), context)</div><div class="line">    context = list(filter(<span class="keyword">lambda</span> x: x + timedelta(minutes=interval) &gt; datetime.now(), context))</div><div class="line">    <span class="keyword">return</span> (len(context) &gt; times) <span class="keyword">and</span> len(context)</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://in355hz.iteye.com/blog/1860787">也谈 Python 的中文编码处理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写几条自己用supervisor遇到的一些小坑&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://python3wos.appspot.com/&quot;&gt;Python 3 Wall&lt;/a&gt;的反派代表，一直不能使用python3安装&lt;/li&gt;
&lt;li&gt;对中文输出支持奇差，
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>半自动刷网络课程</title>
    <link href="https://www.zoulei.net/2016/11/08/network_course_pass/"/>
    <id>https://www.zoulei.net/2016/11/08/network_course_pass/</id>
    <published>2016-11-08T14:04:28.000Z</published>
    <updated>2016-11-08T14:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>刷一个网络课程，很常见的那种，播放视频统计观看时长。不过该系统比较弱，即使切换到别的页面一样也会计算时长。限制条件只是偶尔会出现一些问答题让视频暂停且一个视频播放完成后不会自动播放下一个视频。最开始是打算直接模拟发送http请求，不过后面感觉或许有坑就选了另外一种办法。讲课肯定是有声音的，用程序去捕获声音，如果五秒钟没有声音则认为有问答题出现或者该章节讲完了。</p>
<a id="more"></a>
<h3 id="模拟请求法"><a href="#模拟请求法" class="headerlink" title="模拟请求法"></a>模拟请求法</h3><p>通过chrome开发者工具可以知道每60秒会发送一个请求，大概如下(某些信息*号替代)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">POST /home/scorm/rte?cmd=submit&amp;token=68&amp;uid=null&amp;cwid=20&amp;eplanid=17245&amp;dig=************ HTTP/1.1</div><div class="line">Host: ******</div><div class="line">Connection: keep-alive</div><div class="line">Content-Length: 58</div><div class="line">Pragma: no-cache</div><div class="line">Cache-Control: no-cache</div><div class="line">Origin: *********</div><div class="line">X-Requested-With: ShockwaveFlash/23.0.0.205</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36</div><div class="line">Content-Type: text/xml</div><div class="line">Accept: */*</div><div class="line">Referer: *****htmlv1player_template_index.swf?1478605419919</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div><div class="line">Cookie: *********</div><div class="line"></div><div class="line">cmd:submit</div><div class="line">token:68</div><div class="line">uid:null</div><div class="line">cwid:20</div><div class="line">eplanid:17245</div><div class="line">dig:*****</div></pre></td></tr></table></figure></p>
<p>可以看到cookie信息登录后就会有，要拼凑出以上信息只需要知道dig是如何产生的。从X-Requested-With: ShockwaveFlash/23.0.0.205我们就能看出来是flash发送的，然后下载页面的swf文件进行反编译就能知道dig产生的逻辑。把swf文件放入<a href="http://www.showmycode.com/">http://www.showmycode.com/</a>就能看到产生的逻辑了。不过我不会as，他产生的代码也异常糟糕，截取一段如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">md5String = (md5String + _md5PrivateKey);</div><div class="line">md5String = MD5.hash(md5String);</div><div class="line">req = new URLRequest((_serviceUrlHasQuery) ? ((((((((((_serviceUrl + &quot;&amp;cmd=submit&amp;token=&quot;) + _token) + &quot;&amp;uid=&quot;) + _uid) + &quot;&amp;cwid=&quot;) + _cwid) + &quot;&amp;eplanid=&quot;) + _cplanid) + &quot;&amp;dig=&quot;) + md5String) : ((((((((((_serviceUrl + &quot;?cmd=submit&amp;token=&quot;) + _token) + &quot;&amp;uid=&quot;) + _uid) + &quot;&amp;cwid=&quot;) + _cwid) + &quot;&amp;eplanid=&quot;) + _cplanid) + &quot;&amp;dig=&quot;) + md5String));</div><div class="line">req.method = URLRequestMethod.POST;</div><div class="line">req.contentType = &quot;text/xml&quot;;</div><div class="line">_currentSubmitData = xml;</div><div class="line">req.data = xml;</div><div class="line">_urlLoader.load(req);</div></pre></td></tr></table></figure></p>
<p>如果你对as非常熟悉看起来估计没啥问题。可是有更好的方案。开源软件<a href="https://github.com/jindrapetrik/jpexs-decompiler">jpexs-decompiler</a>.而且居然有中文语言包。很牛的一点就是它能够直接编辑编反编译后的代码再重新打包，可以看看它生成的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">this._token++;</div><div class="line">md5String = this._token + &quot;&quot; + this._uid + &quot;&quot; + this._cwid + &quot;&quot; + this._cplanid + &quot;&quot; + tmpTime;</div><div class="line">xml = &quot;&lt;request lastAccess=\&quot;&quot; + this._lastAccess + &quot;\&quot; sessionTime=\&quot;&quot; + tmpTime + &quot;\&quot;&gt;&quot;;</div><div class="line">for each(tmpObj in tmpHash)</div><div class="line">&#123;</div><div class="line">   if(tmpHash[&quot;sco_&quot; + tmpObj.id] == null)</div><div class="line">   &#123;</div><div class="line">      tmpObj2 = this._tracksHash[&quot;sco_&quot; + tmpObj.id];</div><div class="line">      if(tmpObj2 != null)</div><div class="line">      &#123;</div><div class="line">         xml = xml + &quot;&lt;item id=\&quot;&quot; + tmpObj2.id + &quot;\&quot; score=\&quot;&quot; + tmpObj2.score + &quot;\&quot; time=\&quot;&quot; + tmpObj2.time + &quot;\&quot;/&gt;&quot;;</div><div class="line">         tmpHash[&quot;sco_&quot; + tmpObj.id] = tmpObj2;</div><div class="line">         md5String = md5String + tmpObj2.id + tmpObj2.score;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">for each(objTemp in tmpHash)</div><div class="line">&#123;</div><div class="line">   xml = xml + &quot;&lt;item id=\&quot;&quot; + objTemp.id + &quot;\&quot; complete=\&quot;&quot; + objTemp.complete + &quot;\&quot; type=\&quot;obj\&quot;/&gt;&quot;;</div><div class="line">&#125;</div><div class="line">xml = xml + &quot;&lt;/request&gt;&quot;;</div><div class="line">this._cmd = &quot;submit&quot;;</div><div class="line">md5String = md5String + this._md5PrivateKey;</div><div class="line">ExternalInterface.call(&quot;console.log&quot;,md5String);</div><div class="line">md5String = MD5.hash(md5String);</div><div class="line">req = new URLRequest(!!this._serviceUrlHasQuery?this._serviceUrl + &quot;&amp;cmd=submit&amp;token=&quot; + this._token + &quot;&amp;uid=&quot; + this._uid + &quot;&amp;cwid=&quot; + this._cwid + &quot;&amp;eplanid=&quot; + this._cplanid + &quot;&amp;dig=&quot; + md5String:this._serviceUrl + &quot;?cmd=submit&amp;token=&quot; + this._token + &quot;&amp;uid=&quot; + this._uid + &quot;&amp;cwid=&quot; + this._cwid + &quot;&amp;eplanid=&quot; + this._cplanid + &quot;&amp;dig=&quot; + md5String);</div><div class="line">req.method = URLRequestMethod.POST;</div><div class="line">req.contentType = &quot;text/xml&quot;;</div><div class="line">this._currentSubmitData = xml;</div><div class="line">req.data = xml;</div><div class="line">this._urlLoader.load(req);</div></pre></td></tr></table></figure></p>
<p>这样看起来就很容易理解了，写成python代码大概就是这样子(反编译后可以看到key)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Request Payload</span></div><div class="line"><span class="comment"># &lt;request lastAccess="ch_00_02" sessionTime="60"&gt;&lt;/request&gt;</span></div><div class="line"><span class="comment"># &lt;response success="true"&gt;</span></div><div class="line"><span class="comment"># &lt;item complete="0" id="ch_00_02" score="0.0" time="2249" /&gt;</span></div><div class="line"><span class="comment"># &lt;/response&gt;</span></div><div class="line"><span class="comment"># &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;response success="true"&gt;&lt;item complete="0" id="ch_00_02" score="0.0" time="2249"/&gt;&lt;/response&gt;</span></div><div class="line"></div><div class="line"><span class="comment"># http://***?cmd=submit&amp;token=5&amp;uid=null&amp;cwid=67&amp;eplanid=17242&amp;dig=*****</span></div><div class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</div><div class="line">pri = <span class="string">'#Huaxia$RTE-*PP'</span></div><div class="line">a = <span class="string">'1null671724260#Huaxia$RTE-*PP'</span></div><div class="line">b = md5(a).hexdigest()</div></pre></td></tr></table></figure><br>另外如果遇到什么疑惑可以直接<code>ExternalInterface.call(&quot;console.log&quot;,md5String);</code>这样能够输出变量。重新打包为swf，再用fiddler替换掉请求的swf文件为自己打包的文件，这样就能看到调试输出了。感慨下这个工具真好用，不过本人不是搞前端的，而且flash也已经没落到没有去深入的必要┑(￣Д ￣)┍</p>
<h3 id="判断视频是否播放完成半自动化"><a href="#判断视频是否播放完成半自动化" class="headerlink" title="判断视频是否播放完成半自动化"></a>判断视频是否播放完成半自动化</h3><p>我判断的依据是没有声音了，需要解决的就是获取当前音量大小的问题。最开始想的是使用系统的命令行接口，无奈并没有找到，而后看到了使用虚拟音频接口<a href="https://github.com/mattingalls/Soundflower">Soundflower</a>,虽然2年没更新过了，惊奇的是能正常使用。安装上之后在sound里面的input和output会多出2个设备，如图<img src="https://ficapy.b0.upaiyun.com/blogimg/soundflower.png" alt="soundflower">,当你需要捕获系统声音的时候将input和output均选为同一个(这样会导致机器没有声音输出，需要选择同一个的原因我觉得是代码中根据input的文件描述符来获得output,所以需要将input和output选为同一个)，然而我单独开了一个windows虚拟机，虚拟机可以选择使用哪个输入输出音频接口，对于虚拟机的输出我选择了soundflower，在系统设置里面我选择了相同的soundeflower作为输入。可是选择了正常的接口作为输出。如此我听不到虚拟机发出的声音，同时本机发出的声音又可以正常收听，完美~~~<br>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line">import pyaudio</div><div class="line">import audioop</div><div class="line">from collections import deque</div><div class="line">from subprocess import Popen</div><div class="line"></div><div class="line">FORMAT = pyaudio.paInt16</div><div class="line">CHANNELS = 2</div><div class="line">RATE = 44100</div><div class="line">CHUNK = 1024</div><div class="line"></div><div class="line">audio = pyaudio.PyAudio()</div><div class="line"></div><div class="line">stream = audio.open(format=FORMAT, channels=CHANNELS,</div><div class="line">                    rate=RATE, input=True,</div><div class="line">                    frames_per_buffer=CHUNK)</div><div class="line"></div><div class="line">flag = time.time()</div><div class="line">queue = deque(maxlen=5)</div><div class="line">while True:</div><div class="line">    data = stream.read(CHUNK)</div><div class="line">    if time.time() - flag &gt; 1:</div><div class="line">        flag = time.time()</div><div class="line">        rms = audioop.rms(data, 2)</div><div class="line">        print rms</div><div class="line">        queue.append(rms)</div><div class="line">        if len(queue) == 5 and sum(queue) == 0:</div><div class="line">            Popen(&quot;&quot;&quot;/usr/bin/osascript -e &apos;display notification &quot;look here&quot; &apos;&quot;&quot;&quot;, shell=True)</div></pre></td></tr></table></figure></p>
<p>当五秒钟没有声音就在屏幕右上角弹出一个提示框提醒你去点击。本文用于osx系统，其他系统按照这个思路应该也能实现</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>当然这个系统还有很<code>贴心</code>的地方，对于视频讲解中出现的问答题，其实在前端页面中已经给出了答案，打开web控制台，查看一下就有哒。<br>然后还不允许复制粘贴。这个同样直接在控制台里面复制就好了，也没必要禁用js啥的~~</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.christianengvall.se/record-audio-soundflower/">record-audio-soundflower</a><br><a href="http://stackoverflow.com/questions/26478315/getting-volume-levels-from-pyaudio-for-use-in-arduino">getting-volume-levels-from-pyaudio-for-use-in-arduino</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷一个网络课程，很常见的那种，播放视频统计观看时长。不过该系统比较弱，即使切换到别的页面一样也会计算时长。限制条件只是偶尔会出现一些问答题让视频暂停且一个视频播放完成后不会自动播放下一个视频。最开始是打算直接模拟发送http请求，不过后面感觉或许有坑就选了另外一种办法。讲课肯定是有声音的，用程序去捕获声音，如果五秒钟没有声音则认为有问答题出现或者该章节讲完了。&lt;/p&gt;
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Flask路由机制</title>
    <link href="https://www.zoulei.net/2016/09/11/flask_routing_note/"/>
    <id>https://www.zoulei.net/2016/09/11/flask_routing_note/</id>
    <published>2016-09-11T14:06:12.000Z</published>
    <updated>2016-09-11T14:11:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask帅气的Hello World示例让人印象深刻。其中使用装饰器的路由写法功不可没，甚至以前看过一个系列<a href="http://ains.co/blog/things-which-arent-magic-flask-part-1.html">没那么神奇</a>，讲了app.route。是的，它好像并没有那么神奇，我也来解析一下😆</p>
<a id="more"></a>
<p>Flask的路由是对werkzeug进行了简单的包装，做成了app.route装饰器和blueprint。其实werkzeug中有一段docstring就能反映出flask的路由机制(MapAdapter.dispatch)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request, Response</div><div class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> responder</div><div class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> Map, Rule</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_index</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">return</span> Response(<span class="string">'Hello from the index'</span>)</div><div class="line"></div><div class="line">url_map = Map([Rule(<span class="string">'/'</span>, endpoint=<span class="string">'index'</span>)])</div><div class="line">views = &#123;<span class="string">'index'</span>: on_index&#125;</div><div class="line"></div><div class="line"><span class="meta">@responder</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    request = Request(environ)</div><div class="line">    urls = url_map.bind_to_environ(environ)</div><div class="line">    <span class="keyword">return</span> urls.dispatch(<span class="keyword">lambda</span> e, v: views[e](request, **v),</div><div class="line">                         catch_http_exceptions=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p>
<p>werkzeug路由的全部实现都在routing.py文件当中，看它就够了。路由的基本功能可以说是</p>
<ol>
<li>给出一个URL，匹配到它对应的处理函数，</li>
<li>给出函数能反推构造出URL</li>
</ol>
<h2 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h2><p>一个Rule就是一条URL匹配规则,它的模式如下<code>&lt;converter(arguments):name&gt;</code>,使用正则匹配找出我们需要的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_rule_re = re.compile(r&apos;&apos;&apos;</div><div class="line">    (?P&lt;static&gt;[^&lt;]*)                           # static rule data</div><div class="line">    &lt;</div><div class="line">    (?:</div><div class="line">        (?P&lt;converter&gt;[a-zA-Z_][a-zA-Z0-9_]*)   # converter name</div><div class="line">        (?:\((?P&lt;args&gt;.*?)\))?                  # converter arguments</div><div class="line">        \:                                      # variable delimiter</div><div class="line">    )?</div><div class="line">    (?P&lt;variable&gt;[a-zA-Z_][a-zA-Z0-9_]*)        # variable name</div><div class="line">    &gt;</div><div class="line">&apos;&apos;&apos;, re.VERBOSE)</div></pre></td></tr></table></figure></p>
<p>大概是这么个样子rule匹配<br><img src="https://ficapy.b0.upaiyun.com/blogimg/werkzeug_rule_re.png" alt="werkzeug_rule_re"><br>convert规则匹配<br><img src="https://ficapy.b0.upaiyun.com/blogimg/werkzeug_converter_args_re.png" alt="werkzeug_converter_args_re"><br>很容易想到使用这2个正则能够匹配一个URL，一看他是否匹配某个rule，其次如果匹配那么提取出rule中的参数和值,比如<code>/&lt;int:id&gt;</code>就能匹配<code>/16</code>这个url且得到id=16。这2个函数就是match和build了<br>仅仅有它们是不够的。我们需要的不仅仅是一条Rule，我们需要的是所有Rule的集合。当我们每创建一个Rule的时候将它加入到集合中。所以它提供了get_rules和bind方法</p>
<p>Rule对象同时有2个非常重要的属性endpoint和_regex(编译后的正则).endpoint不用说匹配返回它，根据它返回构建好的URL，匹配功能则是由_regex对象提供的。另外有几个对象继承自Rule<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Subdomain           self.subdomain</div><div class="line">Submount            self.rule = self.path + self.rule</div><div class="line">EndpointPrefix      self.endpoint = self.prefix + self.endpoint</div></pre></td></tr></table></figure></p>
<p>可以看出这三个对象都是对Rule的属性进行了小幅度修改,其中subdomain和submount修改的最终结果就是改变了_regex对象</p>
<p>说一下Subdomain,子域名。这玩意儿好像并不常用，一般一个子域名就是单独一个项目了，不大会几个子域名混合在一个项目里面。如果要使用子域名需要设置SERVER_NAME。示例如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__)</div><div class="line">app.config[<span class="string">'SERVER_NAME'</span>] = <span class="string">'app.local:5000'</span></div><div class="line"><span class="meta">@app.route('/',subdomain='blog')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello'</span></div><div class="line">app.run(<span class="string">'app.local'</span>)</div></pre></td></tr></table></figure><br>然后就是在host里面添加就可以正常调试子域名了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1 app.local</div><div class="line">127.0.0.1 blog.app.local</div></pre></td></tr></table></figure></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map的作用就是将所有的Rule组合在一起,所以add函数是必须的,Rule对象中的match和build都只是针对自己的，Map中提供的match和build则是针对所有Rule的。比如在Flask中写app.route必然会调用add，将该Rule添加到Map中。代码如下(0.1版本)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(self, rule, endpoint, **options)</span>:</span></div><div class="line">    options[<span class="string">'endpoint'</span>] = endpoint</div><div class="line">    options.setdefault(<span class="string">'methods'</span>, (<span class="string">'GET'</span>,))</div><div class="line">    self.url_map.add(Rule(rule, **options))</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></div><div class="line">      self.add_url_rule(rule, f.__name__, **options)</div><div class="line">      self.view_functions[f.__name__] = f</div><div class="line">      <span class="keyword">return</span> f</div><div class="line">  <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure><br>代码中self.url_map = Map(),可以看到app.route做了2件事情，加入到Map中，加入到了view_functions字典中(endpoint对应函数,这段代码和文章开头的代码是很相似的)</p>
<p>Map对象中有2个属性也是比较重要的,_rules列表和_rules_by_endpoint字典。前者存放所有Rule对象，匹配的时候用来遍历，后者为endpoint到Rule的映射。用来build重组URL</p>
<p>现在再来看看Flask中的dispatch分发逻辑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""Does the request dispatching.  Matches the URL and returns the</div><div class="line">    return value of the view or error handler.  This does not have to</div><div class="line">    be a response object.  In order to convert the return value to a</div><div class="line">    proper response object, call :func:`make_response`.</div><div class="line">    """</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        endpoint, values = self.match_request()</div><div class="line">        <span class="keyword">return</span> self.view_functions[endpoint](**values)</div><div class="line">    <span class="keyword">except</span> HTTPException, e:</div><div class="line">        handler = self.error_handlers.get(e.code)</div><div class="line">        <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> e</div><div class="line">        <span class="keyword">return</span> handler(e)</div><div class="line">    <span class="keyword">except</span> Exception, e:</div><div class="line">        handler = self.error_handlers.get(<span class="number">500</span>)</div><div class="line">        <span class="keyword">if</span> self.debug <span class="keyword">or</span> handler <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span></div><div class="line">        <span class="keyword">return</span> handler(e)</div></pre></td></tr></table></figure><br>匹配请求得到endpoint再从view_function中得到对应的处理函数执行</p>
<h2 id="Blueprint"><a href="#Blueprint" class="headerlink" title="Blueprint"></a>Blueprint</h2><p>@app.route虽然够炫酷，可是它绝不适应于大项目。因为注册的endpoint就是函数的名称，在大项目中绝对会存在重名函数的。Blueprint的解决办法就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">blueprint = Blueprint(&apos;public&apos;, __name__, static_folder=&apos;../static&apos;)</div><div class="line">@blueprint.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def index()</div><div class="line"></div><div class="line">app.register_blueprint(blueprint)</div></pre></td></tr></table></figure></p>
<p>这样它注册的endpoint就会变成public.index，解决了重名问题</p>
<p>有人问为什么endpoint不直接使用对应的函数，而要使用字符串。我认为是使用url_for等构建URL函数的时候需要它是字符串，因为使用装饰器后func = deactor(func)，你使用@app.route之后注册的func和你现在的func不是同一个对象。构建函数将无法使用,这也告诉了我们,任何时候其他的装饰器都需要写在@app.route下面,因为如果写在上面，你注册的那个函数是不包含上面的装饰器的，注定了上面的装饰器无法执行</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask帅气的Hello World示例让人印象深刻。其中使用装饰器的路由写法功不可没，甚至以前看过一个系列&lt;a href=&quot;http://ains.co/blog/things-which-arent-magic-flask-part-1.html&quot;&gt;没那么神奇&lt;/a&gt;，讲了app.route。是的，它好像并没有那么神奇，我也来解析一下😆&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask插件原理</title>
    <link href="https://www.zoulei.net/2016/09/05/flask_plugin_note/"/>
    <id>https://www.zoulei.net/2016/09/05/flask_plugin_note/</id>
    <published>2016-09-04T23:38:32.000Z</published>
    <updated>2016-09-11T14:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask的插件还挺多,用过的都知道比如flask-sqlalchemy,安装的时候是使用pip install flask-sqlalchemy，使用的时候就成了from flask.ext.sqlalchemy import SQLAlchemy。使用的是flask.ext而不是flask_sqlalchemy。感觉还有点牛掰啊-_-，不过仅仅是看起来高大上，并没有什么卵用。<a href="https://github.com/pallets/flask/issues/1135">在2016年4月13号正式被移出支持了</a>，已经直接发出不建议使用的警告。本文还是来炒一下现饭，看看它背后的逻辑</p>
<a id="more"></a>
<p>比如flask-sqlalchemy原本是使用from flask_sqlalchemy import [anything]使用的，被变成了from flask.ext.sqlalchemy import [anything]。这是一种对于import的hook。我们知道要导入一个模块，不使用import声明也是可以的，可以使用__import__函数，返回得到的也是一个模块对象</p>
<h2 id="import-hook"><a href="#import-hook" class="headerlink" title="import hook"></a>import hook</h2><p>下文简述，如果需要了解比较详细的资料可以查看后文给出的参考链接(python2和3的import机制是略有区别的)<br>import声明主要做了2件事情，查找模块，加载模块。我们说的hook发生在第一步查找模块。查找模块的步骤是</p>
<ol>
<li>查找sys.modules缓存</li>
<li>在sys.meta_path中依次执行finder对象,找到就返回自身,所有的都没有找到则会报错<br>注意:sys.path_hooks中的finder会被sys.meta_path调用执行(sys.meta_path和sys.path_hook都可以参与import hooks步骤)</li>
</ol>
<h2 id="精简版本实现"><a href="#精简版本实现" class="headerlink" title="精简版本实现"></a>精简版本实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtensionImporter</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install</span><span class="params">(self)</span>:</span></div><div class="line">        sys.meta_path[:] = [x <span class="keyword">for</span> x <span class="keyword">in</span> sys.meta_path <span class="keyword">if</span> self != x] + [self]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_module</span><span class="params">(self, fullname, path=None)</span>:</span></div><div class="line">        <span class="keyword">if</span> fullname.startswith(<span class="string">'flask.ext.'</span>):</div><div class="line">            <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_module</span><span class="params">(self, fullname)</span>:</span></div><div class="line">        <span class="keyword">if</span> fullname <span class="keyword">in</span> sys.modules:</div><div class="line">            <span class="keyword">return</span> sys.modules[fullname]</div><div class="line"></div><div class="line">        modname = fullname.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</div><div class="line"></div><div class="line"></div><div class="line">        realname = <span class="string">'flask_'</span> +  modname</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            __import__(realname)</div><div class="line">        <span class="keyword">except</span> ImportError:</div><div class="line">            <span class="keyword">raise</span> ImportError(<span class="string">'No module named %s'</span> % fullname)</div><div class="line"></div><div class="line">        module = sys.modules[fullname] = sys.modules[realname]</div><div class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">not</span> <span class="keyword">in</span> modname:</div><div class="line">            setattr(sys.modules[<span class="string">'flask.ext'</span>], modname, module)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> module</div></pre></td></tr></table></figure>
<p>ExtensionImporter是一个finder对象,当执行import flask.ext时会把它加入到sys.meta_path列表，后续的import都会先执行它，判断满足要求后就会使用__import__导入然后加入到sys.modules，这样就实现了flask.ext.sqlalchemy导入</p>
<p>为什么会被废除呢。下面是我猜测的。首先本来这个东西没有实质的作用，就是看着炫酷而已。我们可以认为所有的扩展导入都会使用flask.ext.xxx，但是这对第三方扩展库是有要求的，那就是包名必须为flask_xxx才行，我猜测有的第三方库未必遵守这个规则(否则exthook.py中也不会出现['flask_%s', 'flaskext.%s'flaskext.另外一种形式)，这就说明了有的作者使用了flaskextxxx这种包名。出现了第二种难免就会出现另外的。当使用者发现并非所有的第三方扩展都使用flask.ext导入的时候。社区也觉得没必要维持了，毕竟第一个写这个代码的人是不是因为刚刚了解了import机制，觉得很炫酷写上去的呢-_-,另外这种花哨的设计也可能对代码自动补全功能产生了负面影响。so，最后还是回到了原来的位置，直接使用import flask_sqlalchemy导入吧</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.python.org/3/reference/import.html#import-hooks">官方import hook文档</a><br><a href="https://github.com/Liuchang0812/slides/tree/master/pycon2015cn">pycon2015 import演讲</a><br><a href="https://github.com/mitsuhiko/flask-sqlalchemy">flask-sqlalchemy</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask的插件还挺多,用过的都知道比如flask-sqlalchemy,安装的时候是使用pip install flask-sqlalchemy，使用的时候就成了from flask.ext.sqlalchemy import SQLAlchemy。使用的是flask.ext而不是flask_sqlalchemy。感觉还有点牛掰啊-_-，不过仅仅是看起来高大上，并没有什么卵用。&lt;a href=&quot;https://github.com/pallets/flask/issues/1135&quot;&gt;在2016年4月13号正式被移出支持了&lt;/a&gt;，已经直接发出不建议使用的警告。本文还是来炒一下现饭，看看它背后的逻辑&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>tmux</title>
    <link href="https://www.zoulei.net/2016/09/02/tmux_note/"/>
    <id>https://www.zoulei.net/2016/09/02/tmux_note/</id>
    <published>2016-09-02T07:43:22.000Z</published>
    <updated>2016-09-04T07:33:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>自screen之后tmux早已身名远扬，然而这个东西对于一般人来说好像并没有什么卵用，好像还比较麻烦。这也是我以前的看法。主要原因就是iterm2已经非常完美了。iterm2的好用一定程度上掩盖了tmux的光辉。因为iterm2是开箱即用,tmux不配置不一定用的舒服。直到某一天我在youtube上看到了2个视频，我知道我该改改了:)<br><img src="https://ficapy.b0.upaiyun.com/blogimg/gotbletu_tmux.png" alt="gotbletu_tmux"><br>我个人也是刚入门,下面介绍一些基本知识，希望对读者有所帮助.</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>tmux分客户端和服务端，这个docker这种是很相似的，我们操作的只是针对客户端，服务端以守护进程运行，这样实现了我们退出后下次再进入依旧保持了运行状态</li>
<li>session:比如你在公司有个工作环境，在家里又是另外一个工作环境。这2个环境差别非常大。那么就使用2个不同的session</li>
<li>window:你在工作环境中要打开多个软件，聊天的、BT下载的、听歌的etc</li>
<li>pane:一个软件要分成多个区域输出</li>
<li>当然一般来说越少是越方便切换的。就个人来说一个session就够了,主要切换来自于window和pane</li>
<li>tmux主要来说最重要的就是对各个窗口的切换排列管理，各种键位绑定也是用于对窗口的切换</li>
</ul>
<h2 id="windows-pane基本设置"><a href="#windows-pane基本设置" class="headerlink" title="windows,pane基本设置"></a>windows,pane基本设置</h2><p>和vim一样tmux也是使用一个主要的prefix key，先输入prefix key之后再输入绑定的字母执行操作.下面就将我从多个地方copy来的配置解释一番-_-</p>
<p>设置成C-a,同时解绑原来的C-b,最后的bind a的作用就是:C-a本来是回到行首的快捷键，被tmux使用之后使用此设定变成了C-a-a到行首</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set -g prefix ^a</div><div class="line">unbind ^b</div><div class="line">bind a send-prefix</div></pre></td></tr></table></figure>
<p>之后就是对window和pane的快捷键设定，本人使用vim相似的快捷键设定。这个好像没啥好说的，比如hjkl在pane中移动,s、v分屏，使用&lt;、&gt;、+、_对pane进行大小的改变，使用C-u、C-d进行交换，使用q、C-q进行关闭pane和window，举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bind k selectp -U</div><div class="line">bind -r &lt; resize-pane -L 10</div><div class="line">bind ^u swapp -U</div><div class="line">bind q killp</div></pre></td></tr></table></figure>
<p>使用-r(recursion)就能够输入一次&lt;之后马上多次输入&lt;、&gt;有效,这对于调整大小时是非常有用的。。。,没有被重写的配置基本都是非常好记的单词,c、n、w、d记这些都是毫不费力的</p>
<h2 id="鼠标、复制及清屏设置"><a href="#鼠标、复制及清屏设置" class="headerlink" title="鼠标、复制及清屏设置"></a>鼠标、复制及清屏设置</h2><p>如果你不进行其他设置可能用几下动一下鼠标上下翻一下，就会高呼WTF。毕竟完全不动鼠标的大神不多，我还是打开鼠标设置吧,这样也能同时使用鼠标进行上下滑动了，其次复制也和以前不一样了，特别是如果你分了2个竖向的pane,这样和以前一样用鼠标复制就出问题了，当然你可以用z(zoom)全屏当前的pane，然后用鼠标复制。然而一个vim党是不会这样做的T_T。下面是设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">setw -g mouse on</div><div class="line">#set vi mode for copy mode</div><div class="line">setw -g mode-keys vi</div><div class="line"></div><div class="line"># more settings to make copy-mode more vim-like</div><div class="line">unbind [</div><div class="line">bind Escape copy-mode</div><div class="line">unbind p</div><div class="line">bind p paste-buffer</div><div class="line">bind -t vi-copy &apos;v&apos; begin-selection</div><div class="line">bind -t vi-copy &apos;y&apos; copy-selection</div><div class="line"></div><div class="line"># Buffers to/from Mac clipboard, yay tmux book from pragprog</div><div class="line">bind C-c run &quot;tmux save-buffer - | reattach-to-user-namespace pbcopy&quot;</div><div class="line">bind C-v run &quot;tmux set-buffer $(reattach-to-user-namespace pbpaste); tmux paste-buffer&quot;</div></pre></td></tr></table></figure>
<p>这样复制好像变得复杂了。。。需要先进入选择模式C-a-ESC-v选择需要复制的内容后再执行y复制到tmux的缓冲区，另外像tmux和vim这种的粘贴板是独立的,和osx系统的粘贴板不共通,如果要再复制到系统粘贴板，此时再使用C-a-C-c,好像是比较复杂啊。。你可以按住option再用鼠标选择也是直接复制到系统粘贴板，要让vim和tmux和系统粘贴板通用，你需要<code>brew install reattach-to-user-namespace</code>安装。另外iterm2其实是可以让他们共用的，下图选中Applications in terminal may access clipboard也能达到同样的效果，不过下面的参考文章有说有缺点-_-我就听了他的了<br><img src="https://ficapy.b0.upaiyun.com/blogimg/iterm_access_clipboard.png" alt="iterm_access_clipboard"></p>
<p>再就是配置重载和清屏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#bind -n C-l send-keys &apos;C-l&apos;</div><div class="line">bind -n C-k send-keys -R \; send-keys C-l \; clear-history</div><div class="line"># reload config (prefix r)</div><div class="line">bind r source ~/.tmux.conf \; display &quot;Configuration reloaded!&quot;</div></pre></td></tr></table></figure>
<p>就好像command+k完全清屏，tmux也可以，不过需要配置(这个完美清屏命令找了很久),-n表示不需要先按prefix key直接使用C-k就调用了，另外不要将C-l设置为清屏,会让TAB补全失效</p>
<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>配置一个好看的状态栏好像还是比较困难的,我比较偷懒就直接使用了<a href="https://github.com/erikw/tmux-powerline">tmux-powerline</a>和<a href="https://github.com/seebi/tmux-colors-solarized/blob/master/tmuxcolors-256.conf">tmux-colors-solarized</a>,下面是效果<br><img src="https://ficapy.b0.upaiyun.com/blogimg/tmux_statusbar.png" alt="tmux_statusbar"><br>注意配置powerline的时候可能需要在~/.zshrc中加入<code>PS1=&quot;$PS1&quot;&#39;$([ -n &quot;$TMUX&quot; ] &amp;&amp; tmux setenv TMUXPWD_$(tmux display -p &quot;#D&quot; | tr -d %) &quot;$PWD&quot;)&#39;</code>有的时候修改配置可能需要tmux kill-server后重新进入才能看到效果</p>
<p>在状体栏的配置会看到这种<code>set-option -g status-bg colour235</code>,colour235是什么鬼颜色。真是不好猜啊，可以单独开一个pane打印输出所有256种颜色，自己对比修改成喜欢的颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i in &#123;0..255&#125; ; do</div><div class="line">    printf &quot;\x1b[38;5;$&#123;i&#125;mcolour$&#123;i&#125;\n&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>我们设置好了之后可能需要在打开iterm之后就直接进入tmux,否则岂不是白忙活~(≧▽≦)/~啦啦啦，很简单,在iterm的设置页profiles→General→Send text at start中填入<code>tmux attach -t init || tmux new -s init</code>,更有用的是在我们远程到vps上的时候直接进入到tmux,设置一个别名如下<code>alias hg=&quot;ssh -t hg \&quot;bash -c &#39;tmux a -t init || tmux new -s init&#39;\&quot;&quot;</code>这样我们执行hg的时候就新建一个session或者连接到已有的session</p>
<p>如果我们本地开一个tmux，然后远程连接vps，vps再运行tmux，这会造成嵌套使用。特别是当你的prefix key还是一样的时候。。。悲催了，你所输入的快捷键只会被本地的tmux处理而不会被远程的tmux响应，要处理这个问题可以将2者的prefix key设置成不一样,比如一个为a另外一个为s。或者使用iterm单独开一个窗口，我更推荐后者,因为设置成不同的prefix key输入快了可能就输入混淆啦。</p>
<p>另外,使用了tmux显著增加了iterm2的耗电量,估计是我设置的那个状态栏显示上传下载流量导致的，每几秒刷新执行一次shell或许挺耗电.</p>
<p><a href="https://github.com/ficapy/dotfiles/blob/master/.tmux.conf">我的tmux配置</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://danielmiessler.com/study/tmux/">A tmux Primer</a><br><a href="https://www.youtube.com/playlist?list=PL5BE1545D8486D66D">gotbletu youtube playlist</a><br><a href="https://evertpot.com/osx-tmux-vim-copy-paste-clipboard/">Making the clipboard work between iTerm2, tmux, vim and OS X.</a><br><a href="http://superuser.com/questions/285381/how-does-the-tmux-color-palette-work">How does the tmux color palette work?</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自screen之后tmux早已身名远扬，然而这个东西对于一般人来说好像并没有什么卵用，好像还比较麻烦。这也是我以前的看法。主要原因就是iterm2已经非常完美了。iterm2的好用一定程度上掩盖了tmux的光辉。因为iterm2是开箱即用,tmux不配置不一定用的舒服。直到某一天我在youtube上看到了2个视频，我知道我该改改了:)&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/blogimg/gotbletu_tmux.png&quot; alt=&quot;gotbletu_tmux&quot;&gt;&lt;br&gt;我个人也是刚入门,下面介绍一些基本知识，希望对读者有所帮助.&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.zoulei.net/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>fasd和fzf</title>
    <link href="https://www.zoulei.net/2016/08/29/fasd&amp;fzf/"/>
    <id>https://www.zoulei.net/2016/08/29/fasd&amp;fzf/</id>
    <published>2016-08-29T13:55:24.000Z</published>
    <updated>2016-08-30T07:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>来2个日常使用命令行工具玩一玩，前一个是目录快速跳转，后一个是使用curses模糊查找</p>
<a id="more"></a>
<h2 id="fasd"><a href="#fasd" class="headerlink" title="fasd"></a><a href="https://github.com/clvv/fasd">fasd</a></h2><p>目录快速跳转工具挺多的autojump,z.我最开始用的是z，用长了感觉好像有bug,然后就换fasd.<code>好像</code>感觉好用那么一点点。这种工具原理都差不多。对你的历史输入进行统计，放入数据库。然后根据你输入的结果从数据库匹配达到快速cd的结果。安装好后直接输入fasd,就可以看到得分以及目录/文件。从它的原理也能可以看出来。它只能对有记录的快速切换(从你安装这个软件开始记录)。对于一个新的目录首次访问还是需要用cd。这个软件个常用的命令也就2个<br>z和v，分别代表切换目录和使用$EDITOR打开文件.所以:</p>
<ul>
<li>当你需要快速cd到以前打开过的目录用z,当你首次打开一个目录用cd(或者打开当前目录)；</li>
<li>当你需要用vim打开以前打开的文件用v,首次打开或确定目录vim</li>
<li>它真的很方便了,我看到有些人把它和fzf合起来一起用。我想了很久，除了装逼降低效率。我没想到有什么用</li>
</ul>
<h2 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a><a href="https://github.com/junegunn/fzf">fzf</a></h2><p>这款软件对于提高命令行效率也是很牛逼,而且看github上面的提交记录，依旧非常活跃(对于一个小白没什么比项目的活跃更重要了，因为它意味着你可能遇到的坑前人都可能已经趟过).而且这个项目的作者好像非常自信,项目说明里面居然只列举了优点，丝毫没有缺点.</p>
<p>这是一款安装上去就能让你眼前一亮的软件。比如Ctrl+R，完美替换了shell默认的历史记录功能,当输入指令的时候使用ctrl+T就能列出当前目录下所有的文件。当然这只是列举的2个最常用的功能,实际上，它的潜力远不止这么点，如果你用过osx上被人吹成神的alfred,那么fzf的概念可能和它有一定的相似性(取得一些结果,然后使用列表排除出来),举个例子,IDE中我们经常使用全局替换,用以下命令也能搞定<br><code>grep -rn &#39;python&#39;| fzf -m | awk -F &#39;:&#39; &#39;{print $1}&#39; | xargs -L 1 sed -i -e &#39;s/python/hello/g&#39;</code><br>效果如下<img src="https://ficapy.b0.upaiyun.com/blogimg/fzf_grep_sed.gif" alt="fzf_grep_sed"><br>解释一下，</p>
<ol>
<li>使用grep递归匹配当前目录含有python的文件,-r为递归，-n为显示行号。</li>
<li>使用fzf显示出来,-m为多行模式,使用tab为选择或者取消选择。</li>
<li>使用awk对选择的的结果进行处理,-F为选择分隔符，结果为多个目录</li>
<li>使用xargs对结果执行sed替换,-L为对每一个非空行执行后续命令(Call utility for every number non-empty lines read.  A line ending with a space continues to the next non-empty line)</li>
<li>另外grep的效率是非常高的,如果你直接用sed进行全局替换-_-文件一多还是很花费时间滴,比如这种<code>sed -i -- &#39;s/foo/bar/g&#39; **/*(D.)</code></li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然作者没有列举出来,我还是就我的个人感觉说一下</p>
<ol>
<li>蠢到家的匹配效果,你很难理解它是根据什么给你匹配的,放一张图<img src="http://ficapy.b0.upaiyun.com/blogimg/fzf_match.png" alt="fzf_match">，就这匪夷所思的匹配，你不得不使用^$!等额外的规则或者多输入一些字符然后上下键选择</li>
<li>看着炫酷,有时候没必要那么炫酷，比如使用z的时候tab如果有多个选择，这个时候如果你用fzf替代，他会使用curses全屏让你选择,其实整个过程已经多输入了好多字符.</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>fasd和fzf的很好用，而且它们都不需要任何配置都能让你感到高效!对于fzf如果你花时间配置是有特别多玩法的，可以参照官网<a href="https://github.com/junegunn/fzf/wiki/examples">fzf_examples</a>和<a href="https://www.youtube.com/playlist?list=PLqv94xWU9zZ2fMsMMDF4PjtNHCeBFbggD">gotbletu的视频教程</a>体验它的强大。另外，如果你喜欢这2个软件，那么你一定会喜欢<a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a>试一试吧~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来2个日常使用命令行工具玩一玩，前一个是目录快速跳转，后一个是使用curses模糊查找&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.zoulei.net/categories/linux/"/>
    
    
  </entry>
  
</feed>
