<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邹雷</title>
  
  <subtitle>刨过的坑,自己慢慢来填</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zoulei.net/"/>
  <updated>2020-03-02T16:59:04.371Z</updated>
  <id>https://www.zoulei.net/</id>
  
  <author>
    <name>ficapy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用python去除PDF水印</title>
    <link href="https://www.zoulei.net/2020/03/02/delete_watermark/"/>
    <id>https://www.zoulei.net/2020/03/02/delete_watermark/</id>
    <published>2020-03-02T10:00:00.000Z</published>
    <updated>2020-03-02T16:59:04.371Z</updated>
    
    <content type="html"><![CDATA[<p>最近手上有一份PDF资料，水印太多。非常影响阅读。所以写了一个脚本去掉水印。在两年前我折腾过给PDF增加隐藏的文本，说实话，个人感觉PDF格式还是很复杂的。好在很多PDF常见需求都有无数前人躺过坑。在网上搜了一下找了一个比较靠谱的改了一下</p><a id="more"></a><p>先表明，由于PDF格式的复杂性和水印的多样性。水印情况不一样，处理方式不一样。甚至不同的处理方式对原文件造成的破坏也不一样。如果让一个专家针对特定的文件进行特定的处理肯定可以得到很好的效果，据我记忆所知可以对PDF文件进行追加，给已有对象设置可见性。达到去水印的效果且对文件无任何影响</p><p>在找资料的时候我也看到有些小伙伴通过将PDF转换成图片。再采取图片去水印的方式，最后再转换成PDF文件。可以说这种方式可操作性很强，效果也很好，大多数情况能适用，但是对文件有很大的破坏性。emmm, 废话了这么多，说说我遇到的情况吧。<span style="color:red"><strong>该PDF文件有图片水印，且每个图片长宽都固定。所以我找的方案是，找到所有这些长宽的图片，然后隐藏</strong></span>, 解决思路是我先找到一个能够编辑PDF的软件，查看水印由哪些元素组成，总结发现是一些图片</p><p>使用<a href="https://github.com/pymupdf/PyMuPDF" target="_blank" rel="noopener">PyMuPDF</a>使用代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fitz</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_watermark</span><span class="params">(src, dst, width=<span class="number">963</span>, height=<span class="number">215</span>)</span>:</span></span><br><span class="line">    doc = fitz.open(src)</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(doc.pageCount):</span><br><span class="line">        images = doc.getPageImageList(page)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> content <span class="keyword">in</span> doc[page]._getContents():</span><br><span class="line">            c = doc._getXrefStream(content)</span><br><span class="line">            <span class="keyword">for</span> _, _, width, height, _, _, _, img, _ <span class="keyword">in</span> images:</span><br><span class="line">                <span class="keyword">if</span> width == width <span class="keyword">and</span> height == height:</span><br><span class="line">                    c = c.replace(<span class="string">"/&#123;&#125; Do"</span>.format(img).encode(), <span class="string">b""</span>)</span><br><span class="line">            doc._updateStream(content, c)</span><br><span class="line"></span><br><span class="line">    dir = os.path.dirname(dst)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(os.path.dirname(dst)):</span><br><span class="line">        os.makedirs(dir)</span><br><span class="line">    doc.save(dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SRC = <span class="string">"/Users/ficapy/Downloads/pdf"</span></span><br><span class="line">DST = <span class="string">"/Users/ficapy/Downloads/pdf_handle"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(SRC):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> file.endswith(<span class="string">"pdf"</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        src = os.path.join(root, file)</span><br><span class="line">        dst = os.path.join(root.replace(SRC, DST), file)</span><br><span class="line">        delete_watermark(src, dst)</span><br></pre></td></tr></table></figure><p>最后再次强调，具体情况具体分析，想要做到PDF去水印，<span style="color:red"><strong>大多数情况下稍微编码都是能够做到的，但是期待一份代码能够处理所有的去水印情况是不现实的</strong></span></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/pymupdf/PyMuPDF/issues/338#issuecomment-517686621" target="_blank" rel="noopener">How to remove an image from PDF?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近手上有一份PDF资料，水印太多。非常影响阅读。所以写了一个脚本去掉水印。在两年前我折腾过给PDF增加隐藏的文本，说实话，个人感觉PDF格式还是很复杂的。好在很多PDF常见需求都有无数前人躺过坑。在网上搜了一下找了一个比较靠谱的改了一下&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>远程办公访问公司内网</title>
    <link href="https://www.zoulei.net/2020/02/22/WFH/"/>
    <id>https://www.zoulei.net/2020/02/22/WFH/</id>
    <published>2020-02-22T10:00:00.000Z</published>
    <updated>2020-02-23T05:28:16.845Z</updated>
    
    <content type="html"><![CDATA[<p>天灾人祸，今年开年大家被迫在家远程办公。以前从来没有规划过的一些网络问题被提上了台面。我司是一个几乎不加班的公司。从来没有人被要求要在家里完成工作。我们有一些服务是内网的，同时写了一些工具供办公室的文员使用。然后被迫远程，需要解决在家里访问公司内网的要求。同时因为业务的原因还需要访问谷歌</p><a id="more"></a><h3 id="访问公司内网服务"><a href="#访问公司内网服务" class="headerlink" title="访问公司内网服务"></a>访问公司内网服务</h3><p>最常规的方案是VPN, 我对VPN不熟悉。但是在网上看到了一篇很详细的教程，刚好符合业务需求。<a href="https://silence-linhl.github.io/blog/2019/11/02/softEther/" target="_blank" rel="noopener">利用softEther VPN远程访问内部网络</a>。我试着搭建了一下。能够实现需求。用起来就是办公室里面的一台电脑一样。能够访问内网服务。能够正常使用Google. 但是我对这个不熟，不清楚如何优化它的配置。导致使用这个方案性能无比的差。连上VPN的客户端的所有请求都会经过中转服务器，在中转到内网。即使是不需要代理的请求也会被处理，这在性能上是完全无法接受的</p><p>既然是http服务，那么如果使用了域名。是很好解决的。修改DNS让映射到一个外网ip. 访问外网ip,外网再转发到内网。基本不需要在客户端上做任何修改。即使觉得创建一个域名比较麻烦，相对写死一个ip，使用<a href="http://xip.io/" target="_blank" rel="noopener">xip.io</a>，或者<a href="https://sslip.io/" target="_blank" rel="noopener">sslip.io</a> 这种服务也比写死ip强。如果用域名。客户端想要访问完全可以直接修改本地Hosts</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>因为客户端都是用windows，所以用了<a href="https://www.proxifier.com/download/" target="_blank" rel="noopener">proxifier</a>. 它支持劫持所有的客户端访问，然后使用http或者socks代理进行代理处理请求</p><p>有了代理就比较好办了。比如本机访问192.168.1.3。将访问代理到公网中转服务器，中转服务器转发到公司内网，如图所示 <img src="https://blogimg.ficapy.com/blogimg/proxy_%E5%85%AC%E7%BD%91%E8%BD%AC%E5%8F%91.png" alt><br>有几个需要注意的地方</p><ol><li>公网转发到内网使用的是zerotier，虽然有很多种方案可以做到转发，但是我个人比较偏好zerotier。觉得比较好管理，效果也不错。其次为什么没有选择直接让本机客户端直接安装zerotier，是因为大概只有电信网络使用zerotier比较顺畅，其他比如移动，联通几乎无法使用</li><li>proxifier支持http代理，但是不支持普通http代理，仅仅支持connect隧道方式(不清楚这两者的区别，可以查看最后的链接)。非常多的现成代理工具，对于普通的http请求使用的是普通代理，对于https请求使用的是隧道代理，这和要求不符合</li></ol><p>中转服务器使用mitmproxy进行转发</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mitmproxy</span><br><span class="line"><span class="keyword">from</span> mitmproxy <span class="keyword">import</span> http</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(flow)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> flow.request.pretty_host.endswith(<span class="string">"192.168.3.1"</span>):</span><br><span class="line">        flow.request.host = <span class="string">"172.22.233.213"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flow.response = http.HTTPResponse.make(</span><br><span class="line">            <span class="number">200</span>,  <span class="comment"># (optional) status code</span></span><br><span class="line">            <span class="string">b"Hello World"</span>,  <span class="comment"># (optional) content</span></span><br><span class="line">            &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;  <span class="comment"># (optional) headers</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>访问代理google。因为业务需求需要访问谷歌地图<br>这个也是使用proxifier进行代理。但是这个并不能使用http代理。因为http代理使用的是本地DNS解析，这一步就会得到错误的IP. 因此需要使用socks5代理搭配DNS远程解析(proxifier可以设置)<br>服务端使用的是clash, 配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">socks-port:</span> <span class="number">5553</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">authentication:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"xxxx:xxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="string">Proxy</span> <span class="attr">Group:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"auto"</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">url-test</span></span><br><span class="line"><span class="attr">    proxies:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ss1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ss2</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ss3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Rule:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">DOMAIN-KEYWORD,google,auto</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">MATCH,REJECT</span></span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>客户端需要设置，而且设置略复杂。如果使用域名代替直接写ip要好处理很多</li><li>http和socks5代理都是明文, 安全性缺失</li></ol><p>优点嘛，解决了问题，可实施性和性能都还是不错的</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://imququ.com/post/web-proxy.html" target="_blank" rel="noopener">http代理原理及其实现</a><br><a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener">clash</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天灾人祸，今年开年大家被迫在家远程办公。以前从来没有规划过的一些网络问题被提上了台面。我司是一个几乎不加班的公司。从来没有人被要求要在家里完成工作。我们有一些服务是内网的，同时写了一些工具供办公室的文员使用。然后被迫远程，需要解决在家里访问公司内网的要求。同时因为业务的原因还需要访问谷歌&lt;/p&gt;
    
    </summary>
    
      <category term="network" scheme="https://www.zoulei.net/categories/network/"/>
    
    
  </entry>
  
  <entry>
    <title>scp加速传输</title>
    <link href="https://www.zoulei.net/2019/07/29/scp_speedup/"/>
    <id>https://www.zoulei.net/2019/07/29/scp_speedup/</id>
    <published>2019-07-29T13:58:21.000Z</published>
    <updated>2019-08-05T09:20:44.138Z</updated>
    
    <content type="html"><![CDATA[<p>今天有15G的资料需要先传递到服务器上，琢磨着怎么能更快的上传完成，最后总结了一下方法，确实比直接scp传递效率高很多,从直接scp速度是40M/s，到参照参考文章利用lz4变成93M，最后换成zstd变成了152M,效果很棒，语句如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -c gh/ |pv| zstd -9 -T0 |ssh -c chacha20-poly1305@openssh.com  </span><br><span class="line">-o &quot;MACs umac-64@openssh.com&quot; clickhouse &quot;zstd -d | tar -xC /tmp/xx&quot;</span><br></pre></td></tr></table></figure><p>反向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -c chacha20-poly1305@openssh.com  -o &quot;MACs umac-64@openssh.com&quot; remote </span><br><span class="line">&quot;cat /data/filename | zstd -T0&quot; | pv | zstd -d &gt; filename</span><br></pre></td></tr></table></figure><a id="more"></a><p>一般传文件会有两种选择，scp和rsync，scp最基础，rsync主要是增加了块计算，实现了增量传输。增量传输是rsync的优点，在某些场景却也是它的致命伤，为了计算区别，rsync不得不读取要传输的文件信息，对比之后再决定传哪一块，这种方式就对流传输不友好，无法做到边生成文件边传输的作用</p><p>加速传输的主要思路是，将文件压缩后再上传，但是一般的压缩上传又要分为几个步骤</p><ol><li>本地压缩</li><li>scp上传</li><li>远程解压</li></ol><p>每次上传一个文件需要执行三条命令很烦躁，而且绝大多数情况下上传的速度是很慢的，我们完全可以做到边压缩边上传，这样就节约了时间。在无损压缩算法里面最近几年新出的zstd算法可谓是完爆各类压缩算法，看官方benchmark图就知道性能差异了</p><table><thead><tr><th>Compressor name</th><th>Ratio</th><th>Compression</th><th>Decompress.</th></tr></thead><tbody><tr><td>zstd 1.3.4 -1</td><td>2.877</td><td>470 MB/s</td><td>1380 MB/s</td></tr><tr><td>zlib  1.2.11 -1</td><td>2.743</td><td>110 MB/s</td><td>400 MB/s</td></tr><tr><td>brotli  1.0.2 -0</td><td>2.701</td><td>410 MB/s</td><td>430 MB/s</td></tr><tr><td>quicklz   1.5.0 -1</td><td>2.238</td><td>550 MB/s</td><td>710 MB/s</td></tr><tr><td>lzo1x   2.09 -1</td><td>2.108</td><td>650 MB/s</td><td>830 MB/s</td></tr><tr><td>lz4   1.8.1</td><td>2.101</td><td>750 MB/s</td><td>3700 MB/s</td></tr><tr><td>snappy  1.1.4</td><td>2.091</td><td>530 MB/s</td><td>1800 MB/s</td></tr><tr><td>lzf 3.6 -1</td><td>2.077</td><td>400 MB/s</td><td>860 MB/s</td></tr></tbody></table><p>压缩快的没它压缩率高，而且解压速度还贼快，很适合流式处理的场景</p><p>再看它的压缩级别和压缩率曲线<br><img src="https://blogimg.ficapy.com/blogimg/zstd_compression_rate.png" alt="zstd_compression_rate"></p><p>我个人觉得上图中第9个点很有意思，压缩率3.5, 压缩速率为64M/s, 压缩率很高，压缩文件速率也很快，<br>比如我用5G Wifi无线网络连接内网服务器，传输速度是40M/s，这个时候假如选择了压缩率为9，压缩速率为64,压缩后就只有18M了，浪费了40M/s的性能，所以这种情况应该选择低压缩率占满带宽，假如是上传到云服务器，可能上传速度只有2M/s，这个时候就可以选择更高的压缩率10或者11，但不能选择太大，应该极限情况下压缩文件速率只有5M/s, 因此选择怎样的压缩速率由原始上传速率决定</p><p><strong>注意: 以上讨论的时候文件能够被压缩节省空间的情况下，如果你本来就是传输已经被压缩过的文件，比如mp4, 那么启用压缩很可能得不偿失</strong></p><p>在内网某些情况下，也有人赞成不启用压缩进行传输，<a href="https://gist.github.com/KartikTalwar/4393116" target="_blank" rel="noopener">看这个链接</a> , 但是我个人觉得，在有zstd这么优秀的压缩算法加持下，对于可以压缩的文件，加上zstd肯定不会亏</p><p>另外，使用zstd需要本机和远程机器同时安装zstd osx: <code>brew install zstd</code> ubuntu: <code>sudo apt install zstd</code></p><p>其他就是ssh传输参数的调节了，因为ssh会话是安全加密的，加密性越强的算法性能一般会越低，所以一般而言，换成更低级别的加密强度会获得更好的性能，当然用更优秀的算法在不损失安全性的情况下也能获得更好的性能，本来性能最好的是arcfour(有安全问题)，但是这玩意儿已经被弃用了，综合之下选择<code>chacha20-poly1305@openssh.com</code>这个速度也挺好</p><p><code>MACs umac-64@openssh.com</code> 这个参数就是参照一篇13年的文章了，具体我没有测试过</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用流式压缩，边压缩边传输边解压，修改ssh传输配置, 让传输更快</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>如果你经常使用ssh协议传大量文件，把它加到ssh配置里面其实不错，这样就能减少命令行参数了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">参照相关资料照抄的配置</span><br><span class="line">Host   *</span><br><span class="line">Port           22</span><br><span class="line">    User           root</span><br><span class="line">    StrictHostKeyChecking    no</span><br><span class="line">    IdentityFile   ~/.ssh/id_rsa</span><br><span class="line">    ConnectTimeout 15</span><br><span class="line">    ConnectionAttempts 3</span><br><span class="line">    ServerAliveInterval 20</span><br><span class="line">    ServerAliveCountMax 5</span><br><span class="line">    # 多条连接共享</span><br><span class="line">    ControlMaster   auto</span><br><span class="line">    ControlPath     /tmp/ssh_mux_%h_%p_%r</span><br><span class="line">    # 长连接(退出服务器后连接依然可重用)</span><br><span class="line">    ControlPersist  4h</span><br><span class="line">    # 减少延迟</span><br><span class="line">    GSSAPIAuthentication no</span><br><span class="line">    # 选择合适的Ciphers和MACs http://www.wreck.net/ssh_speed</span><br><span class="line">    Ciphers aes128-gcm@openssh.com,aes256-gcm@openssh.com,aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com</span><br><span class="line">    MACs umac-128-etm@openssh.com,umac-128@openssh.com,hmac-sha1-etm@openssh.com,hmac-sha1,hmac-sha2-512-etm@openssh.com,hmac-sha2-512,hmac-sha2-256-etm@openssh.com,hmac-sha2-256</span><br><span class="line">    KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256</span><br><span class="line">    HostKeyAlgorithms ssh-ed25519,ssh-rsa</span><br><span class="line">    ChallengeResponseAuthentication no</span><br><span class="line">    UseRoaming no</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="http://www.orczhou.com/index.php/2013/11/tranfer-data-faster-on-the-fly/" target="_blank" rel="noopener">使用tar+lz4/pigz+ssh更快的数据传输</a><br><a href="https://gist.github.com/dlenski/e42a08fa27e97b0dbb0c0024c99a8bc4" target="_blank" rel="noopener">ssh-cipher-benchmark.sh</a><br><a href="http://www.wreck.net/ssh_speed" target="_blank" rel="noopener">另一个测试</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天有15G的资料需要先传递到服务器上，琢磨着怎么能更快的上传完成，最后总结了一下方法，确实比直接scp传递效率高很多,从直接scp速度是40M/s，到参照参考文章利用lz4变成93M，最后换成zstd变成了152M,效果很棒，语句如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tar -c gh/ |pv| zstd -9 -T0 |ssh -c chacha20-poly1305@openssh.com  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o &amp;quot;MACs umac-64@openssh.com&amp;quot; clickhouse &amp;quot;zstd -d | tar -xC /tmp/xx&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;反向&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh -c chacha20-poly1305@openssh.com  -o &amp;quot;MACs umac-64@openssh.com&amp;quot; remote &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;cat /data/filename | zstd -T0&amp;quot; | pv | zstd -d &amp;gt; filename&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="network" scheme="https://www.zoulei.net/categories/network/"/>
    
    
  </entry>
  
  <entry>
    <title>国内观看Netflix</title>
    <link href="https://www.zoulei.net/2019/01/01/ss_netflix/"/>
    <id>https://www.zoulei.net/2019/01/01/ss_netflix/</id>
    <published>2019-01-01T03:45:26.000Z</published>
    <updated>2019-01-01T04:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>元旦三天假，比较无聊，看了两天的Netflix，起因是网上很多教程说这家视频网站对代理封杀很严重，即使付费还不一定能看，搞的好像很吸引人的样子，这勾起了我的好奇心，想看看这个视频网站是啥样的，去淘宝花十块钱买了一个月的共享账号，折腾了一下还是能看了！给我的感觉就是视频清晰不卡顿(即使代理一点也不卡)，至于视频数量，不敢恭维，可能网上找盗版资源下载更好一点，突破代理限制的方法就是服务器使用ipv6地址去连接Netflix</p><a id="more"></a><h3 id="ipv4现状"><a href="#ipv4现状" class="headerlink" title="ipv4现状"></a>ipv4现状</h3><p>我先后尝试使用三个代理去连接Netflix，居然都成功被识别为代理，有点心灰意冷，心想这商家还做不做生意了，有必要这样赶尽杀绝吗？后来在网上搜索了一番，发现居然有好多代理商家用能看Netflix作为卖点，搞的好像用了很高深的黑科技的样子，后来网友反馈用ipv6可以连接，我试了一下居然还真可以了</p><h3 id="ipv6-解决"><a href="#ipv6-解决" class="headerlink" title="ipv6 解决"></a>ipv6 解决</h3><p>ipv4毕竟地址有限，也发展了这么多年，所以ipv4的地址归纳比较完善了，能准确的知道某个ip是否是云服务器厂商所拥有的，ipv6的地址范围明显就广的多，因此目前并不能很好的识别是否来自于云服务器，另外，商家也要赚钱，不能把路彻底堵死，我想这也是一个原因吧</p><p>shadowsocks5本地提供socks5代理,socks5代理有dns解析选项，一个是本地dns解析，一个是远程dns解析，本地dns解析那得到的ip基本就是ipv4的，所以Netflix识别到的也是ipv4的ip,就被识别为代理了，远程dns解析，交由代理服务器解析，此时我们的目的是得到ipv6的地址，就能成功突破封锁了。</p><p>shadowsocks的python原版和ssr都是自己实现了异步的dns解析功能，通过配置文件<a href="https://github.com/shadowsocks/shadowsocks/blob/5ff694b2c2978b432918dea6ac104706b25cbf48/shadowsocks/asyncdns.py#L251" target="_blank" rel="noopener">开启ipv6解析</a>，ss是prefer_ipv6, ssr的是dns_ipv6，顺利的情况下把它们设置为true就解决问题了。可以使用如下地址连接测试是否正常使用<a href="http://v4v6.ipv6-test.com/json/defaultproto.php" target="_blank" rel="noopener">http://v4v6.ipv6-test.com/json/defaultproto.php</a>。或者使用命令行看到更详细一些的交互</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -x socks5h://127.0.0.1:1086 http://v4v6.ipv6-test.com/json/defaultproto.php -v</span><br></pre></td></tr></table></figure><p>如果返回的ipv6的地址就成功了</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>如果你使用docker运行，那么容器环境需要<a href="https://docs.docker.com/config/daemon/ipv6/" target="_blank" rel="noopener">额外开启ipv6的支持</a></li><li>如果是其他版本的shadowsocks实现，具体看一下代码应该也能实现类似的配置</li><li>开启ipv6有缺点，具体在于极多网站对ipv6的支持不友好，为了Netflix开启ipv6相当于全局开启了ipv6，所以保险起见，你可以开两个代理端口，一个专门看Netflix开启ipv6</li><li>测试了ios端，设置代理无效，可能ios端忽略了代理设置吧，可以尝试直接部署在路由器全局翻</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元旦三天假，比较无聊，看了两天的Netflix，起因是网上很多教程说这家视频网站对代理封杀很严重，即使付费还不一定能看，搞的好像很吸引人的样子，这勾起了我的好奇心，想看看这个视频网站是啥样的，去淘宝花十块钱买了一个月的共享账号，折腾了一下还是能看了！给我的感觉就是视频清晰不卡顿(即使代理一点也不卡)，至于视频数量，不敢恭维，可能网上找盗版资源下载更好一点，突破代理限制的方法就是服务器使用ipv6地址去连接Netflix&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 布隆过滤器案例</title>
    <link href="https://www.zoulei.net/2018/09/04/redis_bloom_filter_case/"/>
    <id>https://www.zoulei.net/2018/09/04/redis_bloom_filter_case/</id>
    <published>2018-09-04T14:27:51.000Z</published>
    <updated>2018-09-04T16:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天工作中遇到了一个小bug，本来主键id应该会存在，结果却并不存在与数据库里面。debug的时候需要查找多张表，看该id是否存在，由于未来可能还存在这种需求，就写了个小脚本。达到的效果就是给出id，能快速得到该id存在于哪张表的哪个字段</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>项目中存在很多张表, 几乎重要地方的主键均使用UUID，有关联的地方有的地方使用了外键，有的地方没有</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>Postgresql分层级db-&gt;schema-&gt;table-&gt;column,先得到所有类型为uuid的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    SELECT t.table_schema,c.table_name,c.column_name</span><br><span class="line">FROM information_schema.columns c</span><br><span class="line">left join information_schema.tables t on t.table_schema = c.table_schema and t.table_name = c.table_name</span><br><span class="line">where c.data_type = &apos;uuid&apos; and t.table_type = &apos;BASE TABLE&apos;</span><br></pre></td></tr></table></figure><p>需要注意的是查询的时候可以限制一下表类型，对于视图和物化视图可以忽略，一般它们都是基于基础表中得到的数据    </p></li><li><p>对每一个得到的字段，构建出一个SQL语句得到uuid的值</p><pre><code>select distinct(column) from schema.table</code></pre></li><li><p>将这些值写入到Redis中</p><p> 对于少量数据，可以很容易想到采用uuid-&gt;set的方式，记录每一个UUID存在于哪些字段中。但是当uuid的个数达到上千万级别的时候，该方式无疑会极大的浪费内存空间<br> 此时Bloom Filter数据结构就是一个极佳的形式,它拥有的特性是, 判断值是否已经存在于已经添加的数据中，如果判断结果是不存在，那么它就一定没有被加入，如果结果是存在，那么有一定几率是没有加入的(具体原理可以参照下方文档)，查询效率极高，空间占用比上一种要小一些。因此，数据对应关系是这样的：column-&gt;uuid set。<br> Bloom Filter在Redis免费版中并不是内置的，是作为4.0以上版本中的一个外部模块，需要我们编译后使用<code>loadmodule</code>指令挂载.</p></li><li><p>客户端查询</p><p> 写入Redis后需要查询的时候先keys得到所有的字段,对于每一个字段执行bf.exists查找该id是否存在于该字段中</p></li></ol><h3 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h3><p>即使单表一亿个字段,单表扫描查询，大概三五十秒也能读取到所有数据, 所以数据库读取性能并不需要太过担心，采用多个goroutine读取会更快，写入Redis就在遍历结果的时候写入就好了<br>写入cron里面，每天更新一次数据，redis最后使用rename使用新的数据替换掉旧的数据<br>客户端查询的时候得到所有的key后，也采用多goroutine同时查询.此时采用pipeline的形式应该更好，然而我不怎么会写~~<br>客户端连接的redis地址已经写死了，我使用了ssh端口转发<code>ssh -NL 6378:127.0.0.1:6379 remote_machine</code>,更近一步,使用<a href="https://github.com/tmuxinator/tmuxinator" target="_blank" rel="noopener">tmuxinator</a>管理tmux配置</p><p>源码如下 <a href="https://github.com/ficapy/pg_uuid_search" target="_blank" rel="noopener">https://github.com/ficapy/pg_uuid_search</a></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://redislabs.com/blog/rebloom-bloom-filter-datatype-redis/" target="_blank" rel="noopener">rebloom-bloom-filter-datatype-redis</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天工作中遇到了一个小bug，本来主键id应该会存在，结果却并不存在与数据库里面。debug的时候需要查找多张表，看该id是否存在，由于未来可能还存在这种需求，就写了个小脚本。达到的效果就是给出id，能快速得到该id存在于哪张表的哪个字段&lt;/p&gt;
    
    </summary>
    
      <category term="database, Go" scheme="https://www.zoulei.net/categories/database-Go/"/>
    
    
  </entry>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第七章(接口)</title>
    <link href="https://www.zoulei.net/2018/06/24/the_go_programming_lang_usage_answer_7/"/>
    <id>https://www.zoulei.net/2018/06/24/the_go_programming_lang_usage_answer_7/</id>
    <published>2018-06-24T09:13:40.000Z</published>
    <updated>2018-06-27T15:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><ul><li>接口即约定</li><li>接口类型</li><li>实现接口</li><li>使用flag.Value来解析参数</li><li>接口值</li><li>使用Sort.Interface来排序</li><li>http.Handler接口</li><li>error接口</li><li>示例: 表达式求值器</li><li>类型断言</li><li>使用类型断言来识别错误</li><li>通过接口类型断言来查询特性</li><li>类型分支</li><li>示例: 基于标记的XML解析</li><li>一些建议</li></ul><p>这章是重点</p><a id="more"></a><h4 id="练习7-1"><a href="#练习7-1" class="headerlink" title="练习7.1:"></a>练习7.1:</h4><p>使用类似ByteCounter的想法,实现单词和行的计数器.实现时考虑使用bufio.ScanWords</p><ul><li>创建一个结构体，实现Writer方法，分词得到写入的个数</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByteCounter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ByteCounter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">scan := bufio.NewScanner(strings.NewReader(<span class="keyword">string</span>(p)))</span><br><span class="line">scan.Split(bufio.ScanWords)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> scan.Scan() &#123;</span><br><span class="line">*c += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c ByteCounter</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Dolly"</span></span><br><span class="line">fmt.Fprintf(&amp;c, <span class="string">"hello, %s"</span>, name)</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习7-2"><a href="#练习7-2" class="headerlink" title="练习7.2:"></a>练习7.2:</h4><p>实现一个满足如下前面的CountingWriter函数,输入一个io.Writer,输出一个封装了输入值的新Writer,以及一个指向int64的指针,该指针对应的值是新的Writer写入的字节数<br><code>func CountingWriter(w io.Writer) (io.Writer, *int64)</code></p><ul><li>这个地方使用了一个全局的变量统计写入的字节数，CountingWriter好像再外面封装了一层一样，仅仅只是为了记一个数，需要新建一个类型，然后让这个类型满足接口</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> position <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counting <span class="keyword">struct</span> &#123;</span><br><span class="line">W io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counting)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">n, err = c.W.Write(p)</span><br><span class="line">position += <span class="keyword">int64</span>(n)</span><br><span class="line"><span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountingWriter</span><span class="params">(w io.Writer)</span> <span class="params">(io.Writer, *<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Counting&#123;w&#125;, &amp;position</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习7-3"><a href="#练习7-3" class="headerlink" title="练习7.3:"></a>练习7.3:</h4><p>为gopl.io/ch4/treesort中的*tree类型写一个String方法,用于展示其中的值序列</p><ul><li>这个练习题比较直白了，估计是想说类型可以自己添加方法，这个地方直接使用广度优先保存下了列表然后打印一下</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> deque []*tree</span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line">deque = <span class="built_in">append</span>(deque, t)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(deque) &gt; <span class="number">0</span> &#123;</span><br><span class="line">current := deque[<span class="number">0</span>]</span><br><span class="line">deque = deque[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> current.left != <span class="literal">nil</span> &#123;</span><br><span class="line">deque = <span class="built_in">append</span>(deque, current.left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> current.right != <span class="literal">nil</span> &#123;</span><br><span class="line">deque = <span class="built_in">append</span>(deque, current.right)</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, current.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf.Write([]<span class="keyword">byte</span>(<span class="string">"&#123;"</span>))</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> ret &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(ret)<span class="number">-1</span> &#123;</span><br><span class="line">buf.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"%d"</span>, v)))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">buf.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"%d, "</span>, v)))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">buf.Write([]<span class="keyword">byte</span>(<span class="string">"&#125;"</span>))</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习7-4"><a href="#练习7-4" class="headerlink" title="练习7.4:"></a>练习7.4:</h4><p>strings.NewReader函数输入一个字符串,返回一个从字符串读取数据并满足io.Reader接口的值.请自己实现该函数,并且通过它来让HTML分析器支持以字符串作为输入</p><ul><li>Golang里面使用Newxxx这样的函数特别普遍，一个常用的套路，它初始化了一个struct，然后该结构体满足某接口</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">R       <span class="keyword">string</span></span><br><span class="line">current <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.current &gt;= <span class="built_in">len</span>(s.R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line">l := <span class="built_in">copy</span>(p, s.R[s.current:])</span><br><span class="line">s.current = l</span><br><span class="line"><span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">io</span>.<span class="title">Reader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;S&#123;s, <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := NewReader(<span class="string">"123"</span>)</span><br><span class="line">s, err := ioutil.ReadAll(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习7-5"><a href="#练习7-5" class="headerlink" title="练习7.5:"></a>练习7.5:</h4><p> io包中的LimitReader函数接受io.Reader r和字节数n,返回一个Reader,该返回值从r读取数据,但在读取n字节后报告文件结束.请实现该函数<br><code>func LimitReader(r io.Reader,n int64) io.Reader</code></p><ul><li>感觉和上面的New差不多,只不过这个地方的初始化是使用了一个接口类型值</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LimitR <span class="keyword">struct</span> &#123;</span><br><span class="line">R io.Reader</span><br><span class="line">N <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LimitR)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.N &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(p)) &gt; l.N &#123;</span><br><span class="line">p = p[<span class="number">0</span>:l.N]</span><br><span class="line">&#125;</span><br><span class="line">n, err = l.R.Read(p)</span><br><span class="line">l.N -= <span class="keyword">int64</span>(n)</span><br><span class="line"><span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r io.Reader, n <span class="keyword">int64</span>)</span> <span class="title">io</span>.<span class="title">Reader</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;LimitR&#123;r, n&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习7-6"><a href="#练习7-6" class="headerlink" title="练习7.6:"></a>练习7.6:</h4><p>在tempflag中支持热力学温度</p><ul><li>这题没什么意义，添加一个case判断就可以了</li><li>本小节主要讲解了flag.Value的原理,先有一个struct结构体,然后一个函数xxFlag(name string,value Type,usage string) *Type</li><li>上述函数调用flag.CommandLine.Var进行注册，当调用flag.Parse的时候调用结构体相应的Set方法,达到了解析命令行参数的目的</li></ul><h3 id="练习7-7"><a href="#练习7-7" class="headerlink" title="练习7.7:"></a>练习7.7:</h3><p>请解释为什么默认值20.0没有写单位,而在帮助消息中却包含单位</p><ul><li>接上一题,因为除了String方法还有Set方法,查看帮助的时候会调用它,在celsiusFlag结构体中String方法直接添加了单位</li></ul><h4 id="练习7-8"><a href="#练习7-8" class="headerlink" title="练习7.8:"></a>练习7.8:</h4><p>很多图形界面提供了一个表格空间,它支持有状态的多层排序,先按照最近单击的列表排序,接着是上一次单击的列,依次类推.请定义sort.Interface接口来实现如上需求,试比较这个方法和多次使用sort.Stable排序的异同</p><ul><li>这一节主要讲利用接口实现排序,需要排序的对象提供三个方法Len、Swap、Less</li><li>用一个slice来维持状态，Less函数使用倒序遍历加上switch开实现</li><li>对比sort.Stable来说，sort.Stable是稳定排序，一个对象有A/B两个属性，当使用稳定排序的时候假如A属性值相同，则对象相对位置不会改变</li><li>代码可能写的有点失败~~<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Track <span class="keyword">struct</span> &#123;</span><br><span class="line">Title  <span class="keyword">string</span></span><br><span class="line">Artist <span class="keyword">string</span></span><br><span class="line">Album  <span class="keyword">string</span></span><br><span class="line">Year   <span class="keyword">int</span></span><br><span class="line">Length time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tracks = []*Track&#123;</span><br><span class="line">&#123;<span class="string">"Go"</span>, <span class="string">"Delilah"</span>, <span class="string">"From the Roots Up"</span>, <span class="number">2012</span>, length(<span class="string">"3m38s"</span>)&#125;,</span><br><span class="line">&#123;<span class="string">"Go"</span>, <span class="string">"Moby"</span>, <span class="string">"Moby"</span>, <span class="number">1992</span>, length(<span class="string">"3m37s"</span>)&#125;,</span><br><span class="line">&#123;<span class="string">"Go Ahead"</span>, <span class="string">"Alicia Keys"</span>, <span class="string">"As I Am"</span>, <span class="number">2007</span>, length(<span class="string">"4m36s"</span>)&#125;,</span><br><span class="line">&#123;<span class="string">"Ready 2 Go"</span>, <span class="string">"Martin Solveig"</span>, <span class="string">"Smash"</span>, <span class="number">2011</span>, length(<span class="string">"4m24s"</span>)&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">length</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">d, err := time.ParseDuration(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> customSort <span class="keyword">struct</span> &#123;</span><br><span class="line">t []*Track</span><br><span class="line">r []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = customSort&#123;tracks,[]<span class="keyword">string</span>&#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(x.t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(x.r) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">switch</span> x.r[i] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Title"</span>:</span><br><span class="line"><span class="keyword">if</span> x.t[i].Title != x.t[j].Title &#123;</span><br><span class="line"><span class="keyword">return</span> x.t[i].Title &lt; x.t[j].Title</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Artist"</span>:</span><br><span class="line"><span class="keyword">if</span> x.t[i].Artist != x.t[j].Artist &#123;</span><br><span class="line"><span class="keyword">return</span> x.t[i].Artist &lt; x.t[j].Artist</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Album"</span>:</span><br><span class="line"><span class="keyword">if</span> x.t[i].Artist != x.t[j].Artist &#123;</span><br><span class="line"><span class="keyword">return</span> x.t[i].Artist &lt; x.t[j].Artist</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Year"</span>:</span><br><span class="line"><span class="keyword">if</span> x.t[i].Year != x.t[j].Year &#123;</span><br><span class="line"><span class="keyword">return</span> x.t[i].Year &lt; x.t[j].Year</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Not support field"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x.t[i], x.t[j] = x.t[j], x.t[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(s <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">c.r = <span class="built_in">append</span>(c.r,s)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.r) &gt; <span class="number">4</span>&#123;</span><br><span class="line">c.r = c.r[:<span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line">sort.Sort(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">Sort(<span class="string">"Title"</span>)</span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> tracks&#123;</span><br><span class="line">fmt.Println(*v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"======="</span>)</span><br><span class="line">Sort(<span class="string">"Artist"</span>)</span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> tracks&#123;</span><br><span class="line">fmt.Println(*v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"======="</span>)</span><br><span class="line">Sort(<span class="string">"Album"</span>)</span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> tracks&#123;</span><br><span class="line">fmt.Println(*v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="练习7-9"><a href="#练习7-9" class="headerlink" title="练习7.9:"></a>练习7.9:</h4><p>利用html/template包来替换printTracks函数,使用HTML表格来显示音乐列表,结合上一个练习,来实现通过单击列头来发送HTTP请求,进而对表格排序</p><ul><li>对这题完全没兴趣，可以练习写template包</li></ul><h4 id="练习7-10"><a href="#练习7-10" class="headerlink" title="练习7.10:"></a>练习7.10:</h4><p>sort.Interface也可以用于其他用户.试写一个函数IsPalindrome(s sort.Interface)bool来判断一个序列是否是回文,即序列反转后保持不变.可以假定对于下标分别为i、j的元素,如果!s.Less(i,j)&amp;&amp;!s.Less(j,i),那么两个元素相等</p><ul><li>左右向中间比较，都相等则表示为回文,主要是用接口方法的Len和Less判断是否相等</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Demo []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Demo)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Demo)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d[i] &lt; d[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Demo)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">d[i], d[j] = d[j], d[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPalindrome</span><span class="params">(s sort.Interface)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.Len()/<span class="number">2</span>; i++ &#123;</span><br><span class="line">x, y := i, s.Len()<span class="number">-1</span>-i</span><br><span class="line"><span class="keyword">if</span> !(!s.Less(x, y) &amp;&amp; !s.Less(y, x)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(IsPalindrome(Demo&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;))</span><br><span class="line">fmt.Println(IsPalindrome(Demo&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习7-11"><a href="#练习7-11" class="headerlink" title="练习7.11:"></a>练习7.11:</h4><p>增加额外的处理程序,来支持创建、读取、更新和删除数据库条目.比如,/update?item=socks&amp;prince=6 这样的请求将更新仓库中物品的价格,如果商品不存在或者价格无效就返回错误</p><ul><li>使用多个http.HandleFunc</li><li>使用锁防止并发修改</li><li>给struct添加多个方法就好了</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db := database&#123;<span class="keyword">map</span>[<span class="keyword">string</span>]dollars&#123;<span class="string">"shoes"</span>: <span class="number">50</span>, <span class="string">"socks"</span>: <span class="number">5</span>&#125;, sync.Mutex&#123;&#125;&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/list"</span>, db.list)</span><br><span class="line">http.HandleFunc(<span class="string">"/price"</span>, db.price)</span><br><span class="line">http.HandleFunc(<span class="string">"/update"</span>, db.update)</span><br><span class="line">http.HandleFunc(<span class="string">"/delete"</span>, db.<span class="built_in">delete</span>)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:8000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dollars <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dollars)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">"$%.2f"</span>, d) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">struct</span> &#123;</span><br><span class="line">R     <span class="keyword">map</span>[<span class="keyword">string</span>]dollars</span><br><span class="line">mutex sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">list</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> item, price := <span class="keyword">range</span> db.R &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"%s: %s\n"</span>, item, price)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">update</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">db.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> db.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">item := req.URL.Query().Get(<span class="string">"item"</span>)</span><br><span class="line">price := req.URL.Query().Get(<span class="string">"price"</span>)</span><br><span class="line"></span><br><span class="line">p, err := strconv.ParseFloat(price, <span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprint(w, <span class="string">"invalid price"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">db.R[item] = dollars(p)</span><br><span class="line">fmt.Fprint(w, <span class="string">"Update price success"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">delete</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">db.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> db.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">item := req.URL.Query().Get(<span class="string">"item"</span>)</span><br><span class="line"><span class="built_in">delete</span>(db.R, item)</span><br><span class="line">fmt.Fprint(w, <span class="string">"Success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">price</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">item := req.URL.Query().Get(<span class="string">"item"</span>)</span><br><span class="line"><span class="keyword">if</span> price, ok := db.R[item]; ok &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"%s\n"</span>, price)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">fmt.Fprintf(w, <span class="string">"no such item: %q\n"</span>, item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习7-12"><a href="#练习7-12" class="headerlink" title="练习7.12:"></a>练习7.12:</h4><p>修改/list的处理程序,改为输出HTML表格,而不是纯文本.可以考虑使用html/template包</p><ul><li>这本书我已经数不清有多少个template包的练习了，老哥，这个模块是不是你写的！！！！！！</li><li>restful当道的年代,没多少机会拼html啦</li><li>即使拼html，这也相当于在python里面不用Jinja这种模板引擎，而跑去用python自带的string.Template一样</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第七章&quot;&gt;&lt;a href=&quot;#第七章&quot; class=&quot;headerlink&quot; title=&quot;第七章&quot;&gt;&lt;/a&gt;第七章&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;接口即约定&lt;/li&gt;
&lt;li&gt;接口类型&lt;/li&gt;
&lt;li&gt;实现接口&lt;/li&gt;
&lt;li&gt;使用flag.Value来解析参数&lt;/li&gt;
&lt;li&gt;接口值&lt;/li&gt;
&lt;li&gt;使用Sort.Interface来排序&lt;/li&gt;
&lt;li&gt;http.Handler接口&lt;/li&gt;
&lt;li&gt;error接口&lt;/li&gt;
&lt;li&gt;示例: 表达式求值器&lt;/li&gt;
&lt;li&gt;类型断言&lt;/li&gt;
&lt;li&gt;使用类型断言来识别错误&lt;/li&gt;
&lt;li&gt;通过接口类型断言来查询特性&lt;/li&gt;
&lt;li&gt;类型分支&lt;/li&gt;
&lt;li&gt;示例: 基于标记的XML解析&lt;/li&gt;
&lt;li&gt;一些建议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这章是重点&lt;/p&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第六章(方法)</title>
    <link href="https://www.zoulei.net/2018/06/21/the_go_programming_lang_usage_answer_6/"/>
    <id>https://www.zoulei.net/2018/06/21/the_go_programming_lang_usage_answer_6/</id>
    <published>2018-06-21T15:24:50.000Z</published>
    <updated>2018-06-21T15:40:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><ul><li>方法声明</li><li>指针接收者的方法</li><li>通过结构体内嵌组成类型</li><li>方法变量与表达式</li><li>示例: 位向量</li><li>封装</li></ul><p>这应该是整本书包含内容最少的章节了,因为和函数差不多，该章习题整个也是扩充位向量这个练习，比第五章练习简单太多</p><a id="more"></a><h4 id="练习6-1"><a href="#练习6-1" class="headerlink" title="练习6.1:"></a>练习6.1:</h4><p>实现这些附加的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (*InSet) Len() int</span><br><span class="line">func (*InSet) Remove(x int)</span><br><span class="line">func (*InSet) Clear()</span><br><span class="line">func (*InSet) Copy() *InSet</span><br></pre></td></tr></table></figure><ul><li>首先需要注意的是，在该实现中位向量并不是完整的从左往右，在slice中每个元素是从右向左的</li><li>书本上给出了稍微复杂的string实现,Len参照string就可以了</li><li>Remove就是将某二进制位置为0,比置为1稍微复杂一点，方案为左移后取反再求与运算</li><li>Clear实行slice的清空，slice[:0]即可</li><li>Copy，使用make新建一个同等长度的slice，再copy完全拷贝</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line"><span class="keyword">if</span> word == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span> &#123;</span><br><span class="line">ret += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Remove</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">word, bit := x/<span class="number">64</span>, <span class="keyword">uint</span>(x%<span class="number">64</span>)</span><br><span class="line">s.words[word] &amp;= (^(<span class="number">1</span> &lt;&lt; bit))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">s.words = s.words[:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Copy</span><span class="params">()</span> *<span class="title">IntSet</span></span> &#123;</span><br><span class="line">newWords := <span class="built_in">make</span>([]<span class="keyword">uint64</span>, <span class="built_in">len</span>(s.words))</span><br><span class="line"><span class="built_in">copy</span>(newWords, s.words)</span><br><span class="line"><span class="keyword">return</span> &amp;IntSet&#123;newWords&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习6-2"><a href="#练习6-2" class="headerlink" title="练习6.2:"></a>练习6.2:</h4><p>定义一个变长方法(*InSet).AddAll(…int),它允许接受一串整型值作为参数,比如s.AddAll(1,2,3)</p><ul><li>因为已经实现了Add方法，此处直接内部调用Add就可以了</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">AddALL</span><span class="params">(values ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">s.Add(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习6-3"><a href="#练习6-3" class="headerlink" title="练习6.3:"></a>练习6.3:</h4><p>(*InSet).UnionWith计算了两个集合的并集,使用|操作符对每个字符进行按位或操作.实现交集、差集和对称差运算(两个集合的对称差只包含某个集合中存在的元素)</p><ul><li>额<del>~</del>，搞个最简单的求并集好了….,最后得到结果覆盖一下原有的slice</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">And</span><span class="params">(t *IntSet)</span></span> &#123;</span><br><span class="line">min := math.Min(<span class="built_in">len</span>(s.words), <span class="built_in">len</span>(t.words))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; min; i++ &#123;</span><br><span class="line">s.words[i] &amp;= t.words[i]</span><br><span class="line">&#125;</span><br><span class="line">s.words = s.words[:min]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习6-4"><a href="#练习6-4" class="headerlink" title="练习6.4:"></a>练习6.4:</h4><p>添加方法Elems返回包含集合元素的slice,这适合在range循环中使用</p><ul><li>同Len方法,都是遍历,因此，从设计角度上说，应该string和len方法都直接依赖Elems的实现</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *IntSet)</span> <span class="title">Elems</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ret []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i, word := <span class="keyword">range</span> s.words &#123;</span><br><span class="line"><span class="keyword">if</span> word == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">64</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> word&amp;(<span class="number">1</span>&lt;&lt;<span class="keyword">uint</span>(j)) != <span class="number">0</span> &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, <span class="number">64</span>*i+j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习6-5"><a href="#练习6-5" class="headerlink" title="练习6.5:"></a>练习6.5:</h4><p>InSet使用的每个字符类型都是int64,但是64位的计算在32位平台上的效率不高.改写程序以使用uint类型,这是适应平台的无符号整型.除以64的操作可以使用一个常量来表示32位或者64位.你或许可以使用一个讨巧的表达式32&lt;&lt;(^uint(0)&gt;&gt;63)来表示除数</p><ul><li>该题只是从效率角度来提供了一种思路，顺便给了你一个trick，uint在32位平台使用32位长度,64位使用64长度,<code>32&lt;&lt;(^uint(0)&gt;&gt;63)</code>, 当为32位的时候后面为0,得到32,为64的时候，后面为1得到64</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第六章&quot;&gt;&lt;a href=&quot;#第六章&quot; class=&quot;headerlink&quot; title=&quot;第六章&quot;&gt;&lt;/a&gt;第六章&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;方法声明&lt;/li&gt;
&lt;li&gt;指针接收者的方法&lt;/li&gt;
&lt;li&gt;通过结构体内嵌组成类型&lt;/li&gt;
&lt;li&gt;方法变量与表达式&lt;/li&gt;
&lt;li&gt;示例: 位向量&lt;/li&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这应该是整本书包含内容最少的章节了,因为和函数差不多，该章习题整个也是扩充位向量这个练习，比第五章练习简单太多&lt;/p&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第五章(函数)</title>
    <link href="https://www.zoulei.net/2018/06/13/the_go_programming_lang_usage_answer_5/"/>
    <id>https://www.zoulei.net/2018/06/13/the_go_programming_lang_usage_answer_5/</id>
    <published>2018-06-13T14:44:47.000Z</published>
    <updated>2018-06-20T14:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><ul><li>函数声明</li><li>递归</li><li>多返回值</li><li>错误</li><li>函数变量</li><li>匿名函数</li><li>变长函数</li><li>延迟函数调用</li><li>宕机</li><li>恢复</li></ul><a id="more"></a><h4 id="练习5-1"><a href="#练习5-1" class="headerlink" title="练习5.1"></a>练习5.1</h4><p>改变findlinks程序,使用递归调用visit(而不是循环)遍历n.FirstChild链表</p><ul><li>可怕的递归ヽ(*。&gt;Д&lt;)o゜可怕</li><li>循环还挺好理解的，可是改成递归真。。。不好理解</li><li>本题就修改一句就好了</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> visit(visit(links, n.FirstChild), n.NextSibling)</span><br></pre></td></tr></table></figure><h4 id="练习5-2"><a href="#练习5-2" class="headerlink" title="练习5.2"></a>练习5.2</h4><p>写一个函数,用于统计HTML文档树内所有的元素个数,如p,div,span等</p><ul><li>将传入的slice修改为map,其他不变</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/net/html"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">doc, err := html.Parse(os.Stdin)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"findelems: %v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">elements := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">visit(elements, doc)</span><br><span class="line"><span class="keyword">for</span> elem, count := <span class="keyword">range</span> elements &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\t%d\n"</span>, elem, count)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(e <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, n *html.Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.Type == html.ElementNode &#123;</span><br><span class="line">e[n.Data]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">visit(e, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-3"><a href="#练习5-3" class="headerlink" title="练习5.3"></a>练习5.3</h4><p>写一个函数,用于输出HTML文档树种所有文本节点的内容.但不包括<code>&lt;script&gt;</code>或<code>&lt;style&gt;</code>元素,因为这些内容在web浏览器中是不可见的</p><ul><li>还是差不多，递归读取到每一个节点，选择性输出</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"golang.org/x/net/html"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">doc, err := html.Parse(os.Stdin)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"findtexts: %v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">visit(doc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(n *html.Node)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &amp;&amp; n.Type == html.ElementNode &#123;</span><br><span class="line"><span class="keyword">if</span> n.Data == <span class="string">"script"</span> || n.Data == <span class="string">"style"</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n.Type == html.TextNode &#123;</span><br><span class="line">fmt.Println(n.Data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">visit(c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-4"><a href="#练习5-4" class="headerlink" title="练习5.4:"></a>练习5.4:</h4><p> 扩展visit函数,使之能够获得到其他种类的链接地址,比如图片、脚本或样式表的链接</p><ul><li><p>用一个字典匹配所有的类型，先匹配n.Data，在遍历属性得到需要的地址</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> filter = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"a"</span>:      <span class="string">"href"</span>,</span><br><span class="line"><span class="string">"img"</span>:    <span class="string">"src"</span>,</span><br><span class="line"><span class="string">"script"</span>: <span class="string">"src"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(links []<span class="keyword">string</span>, n *html.Node)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> filter &#123;</span><br><span class="line"><span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == k &#123;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> n.Attr &#123;</span><br><span class="line"><span class="keyword">if</span> a.Key == v &#123;</span><br><span class="line">links = <span class="built_in">append</span>(links, a.Val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">links = visit(links, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> links</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h4 id="练习5-5"><a href="#练习5-5" class="headerlink" title="练习5.5:"></a>练习5.5:</h4><p>实现函数countWordsAndImages</p><ul><li>ElementNode、TextNode、ComentNode、DoctypeNode、ErrorNode</li><li>判断为TextNode的时候统计字符个数,n.Data为img的时候图片数目累加</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countWordsAndImages</span><span class="params">(n *html.Node)</span> <span class="params">(words, images <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.Type == html.TextNode&#123;</span><br><span class="line">scanner := bufio.NewScanner(strings.NewReader(n.Data))</span><br><span class="line">scanner.Split(bufio.ScanWords)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">words++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="string">"img"</span> &#123;</span><br><span class="line">images++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">ws, is := countWordsAndImages(c)</span><br><span class="line">words += ws</span><br><span class="line">images += is</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> words, images</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-6"><a href="#练习5-6" class="headerlink" title="练习5.6:"></a>练习5.6:</h4><p>修改gopl.io/ch3/surface中的函数corner,以使用命名的结果以及裸返回语句</p><ul><li>最简单的概念题了，返回参数规范化</li><li>return的时候忽略后面的语句,不过我想我写代码的时候可能不会选择忽略</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">corner</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="params">(sx, sy <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">x := xyrange * (<span class="keyword">float64</span>(i)/cells - <span class="number">0.5</span>)</span><br><span class="line">y := xyrange * (<span class="keyword">float64</span>(j)/cells - <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">z := f(x, y)</span><br><span class="line"></span><br><span class="line">sx = width/<span class="number">2</span> + (x-y)*cos30*xyscale</span><br><span class="line">sy = height/<span class="number">2</span> + (x+y)*sin30*xyscale - z*zscale</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-7"><a href="#练习5-7" class="headerlink" title="练习5.7:"></a>练习5.7:</h4><p>开发startElement和endElement函数并应用到一个普通的HTML输出代码中.输出注释节点、文本节点和所有元素属性<code>(&lt;a href=&#39;...&#39;&gt;)</code>.当一个元素没有子节点时,使用简短的形式,比如<code>&lt;img/&gt;</code>而不是<code>&lt;img&gt;&lt;/img&gt;</code>.写一个测试程序保证输出可以正确解析</p><ul><li>抱歉,我感觉挺复杂</li></ul><h4 id="练习5-8"><a href="#练习5-8" class="headerlink" title="练习5.8:"></a>练习5.8:</h4><p>修改forEachNode使得pre和post函数返回一个布尔型的结果来确定遍历是否继续下去.使用它写一个函数ElementByID,该函数使用下面的函数签名并且找到第一个符合id属性的HTML元素.函数在找到符合条件的元素时应该尽快停止遍历.func 使用它写一个函数ElementByID(doc *html.Node, id string) *html.Node</p><ul><li>终止递归，每次执行pre、post的时候选择判断返回值，如果为真表示找到直接进行return</li><li>因为传递给forEachNode的是html.Node的指针，当return的时候即为找到的第一个id，如果遍历完了还没有，最终返回值为n.FirstChild会为nil</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ElementByID</span><span class="params">(doc *html.Node, id <span class="keyword">string</span>)</span> *<span class="title">html</span>.<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> elem *html.Node</span><br><span class="line">forEachNode(doc,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(n *html.Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.Type == html.ElementNode &#123;</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> n.Attr &#123;</span><br><span class="line"><span class="keyword">if</span> a.Key == <span class="string">"id"</span> &amp;&amp; a.Val == id &#123;</span><br><span class="line">elem = n</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-9"><a href="#练习5-9" class="headerlink" title="练习5.9:"></a>练习5.9:</h4><p>写一个函数expand(s string,f func(string)string)string,该函数替换参数s中每一个子字符串”$foo”为f(“foo”)的返回值</p><ul><li>感觉应该是类似于<code>${foo}</code>这样，否则$后面会有很长的字符串，不利于模板进行分割</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Expand</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">string</span>) <span class="title">string</span></span> &#123;</span><br><span class="line">ret := strings.Replace(s, <span class="string">"$foo"</span>, f(<span class="string">"foo"</span>), <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-10"><a href="#练习5-10" class="headerlink" title="练习5.10:"></a>练习5.10:</h4><p>重写topSort以使用map代替slice并去掉开头的排序.结果不是唯一的,验证这个结果是合法的拓扑排序</p><ul><li>跳过┑(￣Д ￣)┍</li></ul><h4 id="练习5-11"><a href="#练习5-11" class="headerlink" title="练习5.11:"></a>练习5.11:</h4><p>现在有”线性代数”这门课程,它的先决课程是”微积分”.拓展topSort以函数输出结果</p><ul><li>跳过┑(￣Д ￣)┍</li></ul><h4 id="练习5-12"><a href="#练习5-12" class="headerlink" title="练习5.12:"></a>练习5.12:</h4><p>5.5节(gopl.io/ch5/outline2)的startElement和endElement函数共享一个全局变量depth.把它们变为匿名函数以共享outline函数的一个局部变量</p><ul><li>跳过┑(￣Д ￣)┍</li></ul><h4 id="练习5-13"><a href="#练习5-13" class="headerlink" title="练习5.13:"></a>练习5.13:</h4><p>修改crawl函数保存找到的页面,根据需要创建目录.不要保存不同域名下的页面.比如本来的页面来自golang.org,那么就把它们保存下来但是不要保存vimeo.com下的页面</p><ul><li>跳过┑(￣Д ￣)┍</li></ul><h4 id="练习5-14"><a href="#练习5-14" class="headerlink" title="练习5.14:"></a>练习5.14:</h4><p>使用广度优先遍历搜索一个不同的拓扑结构.比如,你可以借鉴拓扑排序的例子里的课程依赖关系,计算机文件系统的分层结构,或者从当前城市的官网上下载公共汽车或者地铁的路线图.</p><ul><li>跳过┑(￣Д ￣)┍</li></ul><h4 id="练习5-15"><a href="#练习5-15" class="headerlink" title="练习5.15:"></a>练习5.15:</h4><p>模仿sum写两个变长函数max和min.当不带任何参数调用这些函数的时候应该怎么应对?编写类似函数的变种,要求至少需要一个参数</p><ul><li>当缺少参数的时候直接panic</li><li>比较的时候直接使用math模块的最大值最小值使用</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(in ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"At least one element"</span>)</span><br><span class="line">&#125;</span><br><span class="line">ret := math.MinInt64</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> in &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; ret &#123;</span><br><span class="line">ret = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(in ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(in) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"At least one element"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := math.MaxInt64</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> in &#123;</span><br><span class="line"><span class="keyword">if</span> v &lt; ret &#123;</span><br><span class="line">ret = v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-16"><a href="#练习5-16" class="headerlink" title="练习5.16:"></a>练习5.16:</h4><p>写一个变长版本的strings.Join函数</p><ul><li>可以直接使用strings.Join返回</li><li>选择使用bytes.Buffer模块</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(in ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.Join(in, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join2</span><span class="params">(in ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> in &#123;</span><br><span class="line">buf.Write([]<span class="keyword">byte</span>(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Join2(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-17"><a href="#练习5-17" class="headerlink" title="练习5.17:"></a>练习5.17:</h4><p>写一个变长函数ElementsByTagname,已知一个HTML节点树和零个或多个名字,返回所有符合给出名字的元素</p><ul><li>衔接前面的题目，遍历判断一下即可</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"golang.org/x/net/html"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ElementsByTagName</span><span class="params">(doc *html.Node, name ...<span class="keyword">string</span>)</span> []*<span class="title">html</span>.<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(name) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> visit <span class="function"><span class="keyword">func</span><span class="params">(elems []*html.Node, n *html.Node)</span> []*<span class="title">html</span>.<span class="title">Node</span></span></span><br><span class="line"><span class="function"><span class="title">visit</span> = <span class="title">func</span><span class="params">(elems []*html.Node, n *html.Node)</span> []*<span class="title">html</span>.<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, tag := <span class="keyword">range</span> name &#123;</span><br><span class="line"><span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == tag &#123;</span><br><span class="line">elems = <span class="built_in">append</span>(elems, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> c := n.FirstChild; c != <span class="literal">nil</span>; c = c.NextSibling &#123;</span><br><span class="line">elems = visit(elems, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> elems</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> visit(<span class="literal">nil</span>, doc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-18"><a href="#练习5-18" class="headerlink" title="练习5.18:"></a>练习5.18:</h4><p>不改变原本的行为,重写fetch函数以使用defer语句关闭打开的可写的文件</p><ul><li>基本不变，直接将原有的写法放置到嵌套的defer函数内部，这样关闭失败的时候同样的逻辑会写入err</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(filename <span class="keyword">string</span>, n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">local := path.Base(resp.Request.URL.Path)</span><br><span class="line"><span class="keyword">if</span> local == <span class="string">"/"</span> &#123;</span><br><span class="line">local = <span class="string">"index.html"</span></span><br><span class="line">&#125;</span><br><span class="line">f, err := os.Create(local)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> closeErr := f.Close(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = closeErr</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">n, err = io.Copy(f, resp.Body)</span><br><span class="line"><span class="keyword">return</span> local, n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5-19"><a href="#练习5-19" class="headerlink" title="练习5.19:"></a>练习5.19:</h4><p>使用panic和recover写一个函数,它没有return语句,但是能够返回一个非零的值</p><ul><li>利用defer语句的作用域和函数同级，在defer语句中执行recover再设置函数返回值</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NoReturn</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">r = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(NoReturn())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第五章&quot;&gt;&lt;a href=&quot;#第五章&quot; class=&quot;headerlink&quot; title=&quot;第五章&quot;&gt;&lt;/a&gt;第五章&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;函数声明&lt;/li&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;li&gt;多返回值&lt;/li&gt;
&lt;li&gt;错误&lt;/li&gt;
&lt;li&gt;函数变量&lt;/li&gt;
&lt;li&gt;匿名函数&lt;/li&gt;
&lt;li&gt;变长函数&lt;/li&gt;
&lt;li&gt;延迟函数调用&lt;/li&gt;
&lt;li&gt;宕机&lt;/li&gt;
&lt;li&gt;恢复&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第四章(基本数据)</title>
    <link href="https://www.zoulei.net/2018/06/08/the_go_programming_lang_usage_answer_4/"/>
    <id>https://www.zoulei.net/2018/06/08/the_go_programming_lang_usage_answer_4/</id>
    <published>2018-06-08T15:48:32.000Z</published>
    <updated>2018-06-13T15:14:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><ul><li>数组</li><li>slice</li><li>map</li><li>结构体</li><li>json</li><li>文本和HTML模板</li></ul><a id="more"></a><h4 id="练习4-1"><a href="#练习4-1" class="headerlink" title="练习4.1"></a>练习4.1</h4><p>编写一个函数,计算两个SHA256哈希中不同的bit的数目</p><ul><li>得到两个字符串的sha256结果,为[32]byte类型,然而需要对比bit</li><li>暂时没有得到很好的操作bit的方法,因此采用了格式化字符串的’%08b’这种奇葩的方案</li><li>使用了bufio和bytes.Buffer,最后需要强制Flush</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"crypto/sha256"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r1 bytes.Buffer</span><br><span class="line">writer := bufio.NewWriter(&amp;r1)</span><br><span class="line">fmt.Fprintf(writer, <span class="string">"%08b"</span>, sha256.Sum256([]<span class="keyword">byte</span>(<span class="string">"1"</span>)))</span><br><span class="line">writer.Flush()</span><br><span class="line">r1Str := r1.String()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r2 bytes.Buffer</span><br><span class="line">writer2 := bufio.NewWriter(&amp;r2)</span><br><span class="line">fmt.Fprintf(writer2, <span class="string">"%08b"</span>, sha256.Sum256([]<span class="keyword">byte</span>(<span class="string">"2"</span>)))</span><br><span class="line">writer2.Flush()</span><br><span class="line">r2Str := r2.String()</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> r1Str &#123;</span><br><span class="line"><span class="keyword">if</span> r1Str[i] != r2Str[i] &#123;</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-2"><a href="#练习4-2" class="headerlink" title="练习4.2"></a>练习4.2</h4><p>编写一个程序,默认情况下打印标准输入的SHA256编码,并支持通过命令行flag定制,输出SHA384或SHA512哈希算法</p><ul><li>这个问题看起来是一个命令行参数解析的问题,<code>flag</code>模块</li><li>针对多个不同的case使用switch语句</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"crypto/sha512"</span></span><br><span class="line"><span class="string">"crypto/sha256"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">method := flag.String(<span class="string">"method"</span>, <span class="string">"sha256"</span>, <span class="string">"select hash method(sha256,sha384,sha512)"</span>)</span><br><span class="line">text := flag.String(<span class="string">"text"</span>, <span class="string">""</span>, <span class="string">"input the string your want to hash"</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="keyword">switch</span> *method &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sha256"</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, sha256.Sum256([]<span class="keyword">byte</span>(*text)))</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sha384"</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, sha512.Sum384([]<span class="keyword">byte</span>(*text)))</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sha512"</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>, sha512.Sum512([]<span class="keyword">byte</span>(*text)))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"not support hash method"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-3"><a href="#练习4-3" class="headerlink" title="练习4.3"></a>练习4.3</h4><p>重写函数reverse,使用数组指针作为参数而不是slice</p><ul><li>使用指针避免值拷贝</li><li>使用的时候注意运算优先级</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s *[]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i,j := <span class="number">0</span>,<span class="built_in">len</span>(*s)<span class="number">-1</span>;i&lt;j;i,j =i+<span class="number">1</span>,j<span class="number">-1</span>&#123;</span><br><span class="line">(*s)[i],(*s)[j] = (*s)[j],(*s)[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-4"><a href="#练习4-4" class="headerlink" title="练习4.4"></a>练习4.4</h4><p>编写一个函数rorate,实现一次遍历就可以完成元素旋转</p><ul><li>找到位置当做起始位置，对起始位置前面的数据进行倒序append</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rotate</span><span class="params">(s []<span class="keyword">int</span>, position <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">r := s[position:]</span><br><span class="line"><span class="keyword">for</span> i := position<span class="number">-1</span> ; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">r = <span class="built_in">append</span>(r, s[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-5"><a href="#练习4-5" class="headerlink" title="练习4.5"></a>练习4.5</h4><p>编写一个就地处理函数,用于去除[]string slice中相邻的重复字符串元素</p><ul><li>设置标记为和当前位置两个参数</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteRepet</span><span class="params">(s []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line">current := s[<span class="number">0</span>]</span><br><span class="line">position := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] != current &#123;</span><br><span class="line">position += <span class="number">1</span></span><br><span class="line">s[position] = s[i]</span><br><span class="line">current = s[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[:position+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-6"><a href="#练习4-6" class="headerlink" title="练习4.6"></a>练习4.6</h4><p>编写一个就地处理函数,用于将一个UTF-8编码的字节slice中所有相邻的Unicode空白字符(查看unicode.IsSpace)缩减为一个ASCII空白字符</p><ul><li>将多个连续的空格转换成单个空格，和上面差不多，设置标志位和当前位置，另外判断的条件会稍微多一些</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"unicode"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteEmpty</span><span class="params">(s []<span class="keyword">rune</span>)</span> []<span class="title">rune</span></span> &#123;</span><br><span class="line">position := <span class="number">0</span></span><br><span class="line">tag := unicode.IsSpace(s[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> unicode.IsSpace(s[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> tag != <span class="literal">true</span> &#123;</span><br><span class="line">position += <span class="number">1</span></span><br><span class="line">s[position] = s[i]</span><br><span class="line">tag = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tag = <span class="literal">false</span></span><br><span class="line">position += <span class="number">1</span></span><br><span class="line">s[position] = s[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[:position+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-7"><a href="#练习4-7" class="headerlink" title="练习4.7"></a>练习4.7</h4><p>修改函数reverse,来翻转一个UTF-8编码的字符串中的字符元素,传入参数是该字符串对应的字节slice类型([]byte).你可以做到不需要重新分配内存就实现该功能吗</p><ul><li>这个感觉有点难,类型转换会导致内存重新分配</li><li>我的思路是对每个byte读取前面有几个1，有几个1则表示有多少个byte是连续的。至于翻转，感觉不好翻…..但是能够转换类型就好办了，直接转换成rune</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">byte</span>(<span class="string">"我要搞Golang"</span>)</span><br><span class="line">b := []<span class="keyword">rune</span>(<span class="keyword">string</span>(a))</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(b)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">b[i], b[j] = b[j], b[i]</span><br><span class="line">&#125;</span><br><span class="line">_ = []<span class="keyword">byte</span>(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-8"><a href="#练习4-8" class="headerlink" title="练习4.8"></a>练习4.8</h4><p>修改charcount的代码来统计字母,数字和其他Unicode分类中的字符数量,可以使用函数unicode.IsLetter等</p><ul><li>就是稍微改一下，你可以看到unicode上有各种区分isXXX</li><li>unicode还是分为很多类的Number,Mark,Letter啥的，听都没听过，挺张姿势的<a href="https://www.fileformat.info/info/unicode/category/index.htm" target="_blank" rel="noopener">https://www.fileformat.info/info/unicode/category/index.htm</a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"unicode"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">var</span> control, digit, graphic, letter, lower, mark, number, <span class="built_in">print</span>, punct, space, symbol, title, upper <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">r, _, err := in.ReadRune()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsControl(r) &#123;</span><br><span class="line">control ++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsDigit(r) &#123;</span><br><span class="line">digit++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsGraphic(r) &#123;</span><br><span class="line">graphic++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsLetter(r) &#123;</span><br><span class="line">letter++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsLower(r) &#123;</span><br><span class="line">lower++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsMark(r) &#123;</span><br><span class="line">mark++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsNumber(r) &#123;</span><br><span class="line">number++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsPrint(r) &#123;</span><br><span class="line"><span class="built_in">print</span>++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsPunct(r) &#123;</span><br><span class="line">punct ++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsSpace(r) &#123;</span><br><span class="line">space ++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsSpace(r) &#123;</span><br><span class="line">symbol ++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsTitle(r) &#123;</span><br><span class="line">title ++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> unicode.IsUpper(r) &#123;</span><br><span class="line">upper ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"control: %d\n"</span>, control)</span><br><span class="line">fmt.Printf(<span class="string">"digit: %d\n"</span>, digit)</span><br><span class="line">fmt.Printf(<span class="string">"graphic: %d\n"</span>, graphic)</span><br><span class="line">fmt.Printf(<span class="string">"letter: %d\n"</span>, letter)</span><br><span class="line">fmt.Printf(<span class="string">"lower: %d\n"</span>, lower)</span><br><span class="line">fmt.Printf(<span class="string">"mark: %d\n"</span>, mark)</span><br><span class="line">fmt.Printf(<span class="string">"number: %d\n"</span>, number)</span><br><span class="line">fmt.Printf(<span class="string">"print: %d\n"</span>, <span class="built_in">print</span>)</span><br><span class="line">fmt.Printf(<span class="string">"punct: %d\n"</span>, punct)</span><br><span class="line">fmt.Printf(<span class="string">"space: %d\n"</span>, space)</span><br><span class="line">fmt.Printf(<span class="string">"symbol: %d\n"</span>, symbol)</span><br><span class="line">fmt.Printf(<span class="string">"title: %d\n"</span>, title)</span><br><span class="line">fmt.Printf(<span class="string">"upper: %d\n"</span>, upper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-9"><a href="#练习4-9" class="headerlink" title="练习4.9"></a>练习4.9</h4><p>编写一个程序wordfreq来汇总输入文本文件中每个单词出现的次数.在第一次调用scan之前,需要使用input.Split(bufio.ScanWords)来将文本行按照单词分割而不是行分割</p><ul><li>写法感觉还是有点奇怪的，bufio.ScanWords使用参考了这篇文章<a href="https://medium.com/golangspec/in-depth-introduction-to-bufio-scanner-in-golang-55483bb689b4" target="_blank" rel="noopener">https://medium.com/golangspec/in-depth-introduction-to-bufio-scanner-in-golang-55483bb689b4</a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scanner := bufio.NewScanner(bufio.NewReader(os.Stdin))</span><br><span class="line">scanner.Split(bufio.ScanWords)</span><br><span class="line">record := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">record[scanner.Text()]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, <span class="string">"Reading input:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> record &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\t%d\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-10"><a href="#练习4-10" class="headerlink" title="练习4.10"></a>练习4.10</h4><p>修改issues实例,按照时间来输出结果,比如一个月以内,一年以内或者超过一年</p><ul><li>对获得的结果使用sort排序</li><li>将所有结果依照一个月、一年、超过一年的放入三个slice当中</li><li>最后输出</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IssuesURL = <span class="string">"https://api.github.com/search/issues"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IssuesSearchResult <span class="keyword">struct</span> &#123;</span><br><span class="line">TotalCount <span class="keyword">int</span> <span class="string">`json:"total_count"`</span></span><br><span class="line">Items      []*Issue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Issue <span class="keyword">struct</span> &#123;</span><br><span class="line">Number    <span class="keyword">int</span></span><br><span class="line">HTMLURL   <span class="keyword">string</span>    <span class="string">`json:"html_url"`</span></span><br><span class="line">Title     <span class="keyword">string</span></span><br><span class="line">State     <span class="keyword">string</span></span><br><span class="line">User      *User</span><br><span class="line">CreatedAt time.Time <span class="string">`json:"created_at"`</span></span><br><span class="line">Body      <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Login   <span class="keyword">string</span></span><br><span class="line">HTMLURL <span class="keyword">string</span> <span class="string">`json:"html_url"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchIssues</span><span class="params">(terms []<span class="keyword">string</span>)</span> <span class="params">(*IssuesSearchResult, error)</span></span> &#123;</span><br><span class="line">q := url.QueryEscape(strings.Join(terms, <span class="string">" "</span>))</span><br><span class="line">resp, err := http.Get(IssuesURL + <span class="string">"?q="</span> + q)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"search query failed: %s"</span>, resp.Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result IssuesSearchResult</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;result); err != <span class="literal">nil</span> &#123;</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">return</span> &amp;result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SortResult</span><span class="params">(result *IssuesSearchResult)</span></span> &#123;</span><br><span class="line">sort.Slice(result.Items, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> result.Items[i].CreatedAt.Before(result.Items[j].CreatedAt)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">result, err := SearchIssues(os.Args[<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SortResult(result)</span><br><span class="line"><span class="keyword">var</span> month, year, distant []*Issue</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v, i := <span class="keyword">range</span> result.Items &#123;</span><br><span class="line"><span class="keyword">if</span> i.CreatedAt.After(time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">30</span> * <span class="number">-1</span>)) &#123;</span><br><span class="line">month = <span class="built_in">append</span>(month, result.Items[v])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i.CreatedAt.After(time.Now().Add(time.Hour * <span class="number">24</span> * <span class="number">365</span> * <span class="number">-1</span>)) &#123;</span><br><span class="line">year = <span class="built_in">append</span>(year, result.Items[v])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">distant = <span class="built_in">append</span>(distant, result.Items[v])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%d issues:\n"</span>, result.TotalCount)</span><br><span class="line">fmt.Printf(<span class="string">"with in a month\n"</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> month &#123;</span><br><span class="line">fmt.Printf(<span class="string">"#%-5d %9.9s %.55s %s\n"</span>, item.Number, item.User.Login, item.Title, item.CreatedAt)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"with in a year\n"</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> year &#123;</span><br><span class="line">fmt.Printf(<span class="string">"#%-5d %9.9s %.55s %s\n"</span>, item.Number, item.User.Login, item.Title, item.CreatedAt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"long long ago\n"</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> distant &#123;</span><br><span class="line">fmt.Printf(<span class="string">"#%-5d %9.9s %.55s %s\n"</span>, item.Number, item.User.Login, item.Title, item.CreatedAt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4-11"><a href="#练习4-11" class="headerlink" title="练习4.11"></a>练习4.11</h4><p>开发一个工具让用户可以通过命令行创建、读取、更新或者关闭Github的issues,当需要额外输入的时候,调用他们喜欢的文本编辑器</p><ul><li>啊，感觉这个题目很无聊<del>~</del></li></ul><h4 id="练习4-12"><a href="#练习4-12" class="headerlink" title="练习4.12"></a>练习4.12</h4><p>流行web漫画xkcd有一个JSON接口.例如,调用<a href="https://xkcd.com/571/info.0.json输出漫画571的详细描述,这个是很多人最喜欢的之一.下载每一个URL并且构建一个离线索引.编写xkcd来使用这个索引,可以通过命令行指定的搜索条件来查找并输出符合条件的每个漫画的URL和剧本" target="_blank" rel="noopener">https://xkcd.com/571/info.0.json输出漫画571的详细描述,这个是很多人最喜欢的之一.下载每一个URL并且构建一个离线索引.编写xkcd来使用这个索引,可以通过命令行指定的搜索条件来查找并输出符合条件的每个漫画的URL和剧本</a></p><ul><li>感觉这条超纲了啊，构建离线索引…….是写到sqlite里面吗？查找的时候正则匹配？</li></ul><h4 id="练习4-13"><a href="#练习4-13" class="headerlink" title="练习4.13"></a>练习4.13</h4><p>基于JSON开发的web服务,开放电影数据库让你可以在<a href="https://omdbapi.com/上通过名字来搜索电影并下载海报图片.开发一个poster工具以通过命令行指定的电影名称来下载海报" target="_blank" rel="noopener">https://omdbapi.com/上通过名字来搜索电影并下载海报图片.开发一个poster工具以通过命令行指定的电影名称来下载海报</a></p><ul><li>没什么兴趣，就一个JSON解析</li></ul><h4 id="练习4-14"><a href="#练习4-14" class="headerlink" title="练习4.14:"></a>练习4.14:</h4><p>创建一个web服务器,可以通过查询github并缓存信息,然后可以浏览bug列表、里程碑信息以及用户参与的信息</p><ul><li>这题应该意图就是编写模板了</li><li>至于缓存大概用Redis吧</li><li>我很懒，就随便搞了个模板测试了下用法</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"html/template"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> templ = <span class="string">`&lt;p&gt;A: &#123;.A&#125;&lt;/p&gt;&lt;p&gt;B: &#123;.B&#125;&lt;/p&gt;`</span>  (换&#123;&#125;,因为hexo渲染问题)</span><br><span class="line">t := template.Must(template.New(<span class="string">"escape"</span>).Parse(templ))</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="keyword">string</span></span><br><span class="line">B template.HTML</span><br><span class="line">&#125;</span><br><span class="line">data.A = <span class="string">"&lt;b&gt;Hello!&lt;/b&gt;"</span></span><br><span class="line">data.B = <span class="string">"&lt;b&gt;Hello!&lt;/b&gt;"</span></span><br><span class="line"></span><br><span class="line">t.Execute(w, data)</span><br><span class="line">&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">":8888"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第四章&quot;&gt;&lt;a href=&quot;#第四章&quot; class=&quot;headerlink&quot; title=&quot;第四章&quot;&gt;&lt;/a&gt;第四章&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;slice&lt;/li&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;li&gt;json&lt;/li&gt;
&lt;li&gt;文本和HTML模板&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第三章(基本数据)</title>
    <link href="https://www.zoulei.net/2018/06/06/the_go_programming_lang_usage_answer_3/"/>
    <id>https://www.zoulei.net/2018/06/06/the_go_programming_lang_usage_answer_3/</id>
    <published>2018-06-06T15:59:33.000Z</published>
    <updated>2018-06-08T15:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><ul><li>整数</li><li>浮点数</li><li>复数</li><li>布尔值</li><li>字符串</li><li>常量</li></ul><p>这一章阅读体验很好，因为书上给的示例很炫酷，产生的结果是炫酷的图形，然而想要理解却挺头痛，因为需要一些基础的图形学知识，这章习题做得比较头疼，不是因为代码逻辑，而是因为”业务逻辑”</p><a id="more"></a><h4 id="练习3-1"><a href="#练习3-1" class="headerlink" title="练习3.1"></a>练习3.1</h4><p> 假如函数f返回一个float64型的无穷大值,就会导致SVG文件含有无效的<polygon>元素.修改本程序以避免无效多边形</polygon></p><ul><li><p>我的想法是将无穷大和<code>math.MaxFloat64</code>进行比较，比它还大就替换为最大值</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">TestMax</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span>/z &gt; math.MaxFloat64&#123;</span><br><span class="line">fmt.Println(math.MaxFloat64)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h4 id="练习3-2"><a href="#练习3-2" class="headerlink" title="练习3.2"></a>练习3.2</h4><p>用math包的其他函数试验可视化效果.你是否能生成各种曲面,分别呈鸡蛋盒状、雪坡状或马鞍状</p><ul><li>没有完全搞明白，三维映射到二维的过程，不过整个代码的逻辑还是很清晰的，这一题略过</li></ul><h5 id="练习3-3"><a href="#练习3-3" class="headerlink" title="练习3.3"></a>练习3.3</h5><p>按高度给每个多边形上色,使得封顶呈红色(#ff0000),谷底呈蓝色(#0000ff)</p><ul><li>思路是得到最大值最小值，将中间部分分为256个部分，然后每个z值都能映射到一个颜色，想着可以平滑过渡，然而效果却很糟糕😰</li><li>svg的polygon显示颜色，只要在每个polygon上面添加fill属性就可以了</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">width, height = <span class="number">600</span>, <span class="number">320</span></span><br><span class="line">cells         = <span class="number">100</span></span><br><span class="line">xyrange       = <span class="number">30.0</span></span><br><span class="line">xyscale       = width / <span class="number">2</span> / xyrange</span><br><span class="line">zscale        = height * <span class="number">0.4</span></span><br><span class="line">angle         = math.Pi / <span class="number">6</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sin30, cos30 = math.Sin(angle), math.Cos(angle)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"&lt;svg xmlns='http://www.w3.org/2000/svg' "</span>+</span><br><span class="line"><span class="string">"style='stroke: grey; fill: white; stroke-width: 0.7' "</span>+</span><br><span class="line"><span class="string">"width='%d' height='%d'&gt;"</span>, width, height)</span><br><span class="line">min, max := getMinMax()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cells; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cells; j++ &#123;</span><br><span class="line">ax, ay, r, g, b := corner(i+<span class="number">1</span>, j, min, max)</span><br><span class="line">bx, by, r, g, b := corner(i, j, min, max)</span><br><span class="line">cx, cy, r, g, b := corner(i, j+<span class="number">1</span>, min, max)</span><br><span class="line">dx, dy, r, g, b := corner(i+<span class="number">1</span>, j+<span class="number">1</span>, min, max)</span><br><span class="line">fmt.Printf(<span class="string">"&lt;polygon points='%g,%g %g,%g %g,%g %g,%g' fill='#%x%x%x'/&gt;\n"</span>,</span><br><span class="line">ax, ay, bx, by, cx, cy, dx, dy, r, g, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"&lt;/svg&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getColor</span><span class="params">(min, max, current <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">step := (max - min) / <span class="number">255</span></span><br><span class="line">v := <span class="keyword">int</span>((current - min) / step)</span><br><span class="line">r := v</span><br><span class="line">g := <span class="number">0</span></span><br><span class="line">b := <span class="number">255</span> - v</span><br><span class="line"><span class="keyword">return</span> r, g, b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinMax</span><span class="params">()</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> min, max <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cells; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; cells; j++ &#123;</span><br><span class="line">x := xyrange * (<span class="keyword">float64</span>(i)/cells - <span class="number">0.5</span>)</span><br><span class="line">y := xyrange * (<span class="keyword">float64</span>(j)/cells - <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">z := f(x, y)</span><br><span class="line"><span class="keyword">if</span> z &lt; min &#123;</span><br><span class="line">min = z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> z &gt; max &#123;</span><br><span class="line">max = z</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min, max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">corner</span><span class="params">(i, j <span class="keyword">int</span>, min, max <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x := xyrange * (<span class="keyword">float64</span>(i)/cells - <span class="number">0.5</span>)</span><br><span class="line">y := xyrange * (<span class="keyword">float64</span>(j)/cells - <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">z := f(x, y)</span><br><span class="line"><span class="comment">// 将(x,y,z)等角投射到二维SVG绘图平面上,坐标是(sx,sy)</span></span><br><span class="line">sx := width/<span class="number">2</span> + (x-y)*cos30*xyscale</span><br><span class="line">sy := height/<span class="number">2</span> + (x+y)*sin30*xyscale - z*zscale</span><br><span class="line">r, g, b := getColor(min, max, z)</span><br><span class="line"><span class="keyword">return</span> sx, sy, r, g, b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="keyword">float64</span>, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">r := math.Hypot(x, y)</span><br><span class="line"><span class="keyword">return</span> math.Sin(r) / r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3-4"><a href="#练习3-4" class="headerlink" title="练习3.4"></a>练习3.4</h4><p>仿照1.7节的示例Lissajous的方法,构建一个web服务器,计算并生成曲面,同时将svg数据写入客户端.服务器必须如下设置Content-Type报头 <code>w.Header().set(&quot;Content-Type&quot;,&quot;image/svg+xml&quot;)</code></p><ul><li>这个问题比较简单，体现了Go的接口思维，将main改成函数，传入<code>io.Writer</code>接口，将<code>fmt.Printf</code>改为<code>fmt.Fprintf</code>就可以了，最后web请求加Header让浏览器识别svg</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"image/svg+xml"</span>)</span><br><span class="line">image(w)</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:8877"</span>, <span class="literal">nil</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3-5"><a href="#练习3-5" class="headerlink" title="练习3.5"></a>练习3.5</h4><p>用image.NewRGBA函数和color.RGBA类型或color.YCbCr类型实现一个Mandelbrot集的全彩图</p><ul><li>又是一个图形学,一维变量最简单的方式是R=G=B,最后出来一个平滑变化的灰度图。作者要求变成全彩图(喂！大哥，我是来学Golang的，不是来搞图形学的)，我也不知道这需要什么图形学知识😕，不过看到有人给出了这样一个看起来很简单也符合题目要求的变化</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mandelbrot</span><span class="params">(z <span class="keyword">complex128</span>)</span> <span class="title">color</span>.<span class="title">Color</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> iterations = <span class="number">200</span></span><br><span class="line"><span class="keyword">const</span> contrast = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">complex128</span></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">uint8</span>(<span class="number">0</span>); n &lt; iterations; n++ &#123;</span><br><span class="line">v = v*v + z</span><br><span class="line"><span class="keyword">if</span> cmplx.Abs(v) &gt; <span class="number">2</span> &#123;</span><br><span class="line">v := <span class="number">255</span> - contrast*n</span><br><span class="line"><span class="keyword">return</span> color.YCbCr&#123;v, <span class="number">255</span> - v, <span class="number">255</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> color.Black</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3-6"><a href="#练习3-6" class="headerlink" title="练习3.6:"></a>练习3.6:</h4><p>超采样通过对几个临近像素颜色取样并取均值,是一种减少锯齿化的方法.最简单的做法是将每个像素分为4个”子像素”.给出实现方式</p><ul><li>暂时略过</li></ul><h4 id="练习3-7"><a href="#练习3-7" class="headerlink" title="练习3.7:"></a>练习3.7:</h4><p>另一种简单的分形是运用牛顿法求某个函数的复数解,比如z的四次方-1 = 0.以平面上各点作为牛顿法的起始,根据逼近其中一个根(共有四个根)所需的迭代次数对该点设定灰度.再根据求得的根对每个点进行全彩上色</p><ul><li>暂时略过</li></ul><h4 id="练习3-8"><a href="#练习3-8" class="headerlink" title="练习3.8:"></a>练习3.8:</h4><p>生成高度放大的分形需要极高的数学精度.分别用以下四种类型(complex64,complex128,big.Float,big.Rat)表示数据实现同一个分形(后面两种类型由math/big包给出.big.Float类型随意选用float32/float64浮点数,但精度有限;big.Rat类型使用无限精度的有理数.)它们在计算性能和内存消耗上相比如何?放大到什么程度,渲染的失真变得可见</p><ul><li>暂时略过</li></ul><h4 id="练习3-9"><a href="#练习3-9" class="headerlink" title="练习3.9:"></a>练习3.9:</h4><p>编写一个web服务器,它生成分形并将图像写入客户端.要让客户端得以通过HTTP请求的参数指定x,y值和放大系数</p><ul><li>终于有一题能做的了😭,读取查询参数，修改函数输出传入参数io.Writer</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"image"</span></span><br><span class="line"><span class="string">"image/png"</span></span><br><span class="line"><span class="string">"math/cmplx"</span></span><br><span class="line"><span class="string">"image/color"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"image/x-png"</span>)</span><br><span class="line">xv := r.URL.Query().Get(<span class="string">"x"</span>)</span><br><span class="line">x, err := strconv.Atoi(xv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">x = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">yv := r.URL.Query().Get(<span class="string">"y"</span>)</span><br><span class="line">y, err := strconv.Atoi(yv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">generate(x, y, w)</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:8877"</span>, <span class="literal">nil</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(_x, _y <span class="keyword">int</span>, w io.Writer)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> xmin, ymin, xmax, ymax <span class="keyword">float64</span> = <span class="keyword">float64</span>(<span class="number">-1</span>*_x), <span class="keyword">float64</span>(<span class="number">-1</span>*_x), <span class="keyword">float64</span>(_y), <span class="keyword">float64</span>(_y)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">width, height = <span class="number">1024</span>, <span class="number">1024</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">img := image.NewRGBA(image.Rect(<span class="number">0</span>, <span class="number">0</span>, width, height))</span><br><span class="line"><span class="keyword">for</span> py := <span class="number">0</span>; py &lt; height; py++ &#123;</span><br><span class="line">y := <span class="keyword">float64</span>(py)/height*(ymax-ymin) + ymin</span><br><span class="line"><span class="keyword">for</span> px := <span class="number">0</span>; px &lt; width; px++ &#123;</span><br><span class="line">x := <span class="keyword">float64</span>(px)/width*(xmax-xmin) + xmin</span><br><span class="line">z := <span class="built_in">complex</span>(x, y)</span><br><span class="line">img.Set(px, py, mandelbrot(z))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">png.Encode(w, img)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mandelbrot</span><span class="params">(z <span class="keyword">complex128</span>)</span> <span class="title">color</span>.<span class="title">Color</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> iterations = <span class="number">200</span></span><br><span class="line"><span class="keyword">const</span> contrast = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="keyword">complex128</span></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">uint8</span>(<span class="number">0</span>); n &lt; iterations; n++ &#123;</span><br><span class="line">v = v*v + z</span><br><span class="line"><span class="keyword">if</span> cmplx.Abs(v) &gt; <span class="number">2</span> &#123;</span><br><span class="line">v := <span class="number">255</span> - contrast*n</span><br><span class="line"><span class="keyword">return</span> color.YCbCr&#123;v, <span class="number">255</span> - v, <span class="number">255</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> color.Black</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3-10"><a href="#练习3-10" class="headerlink" title="练习3.10:"></a>练习3.10:</h4><p>编写一个非递归的comma函数,运用bytes.Buffer,而不是简单的字符串拼接</p><ul><li>得到字符串长度，先对三取余，然后每三位循环一次，最后一个循环特殊处理</li><li>使用bytes.Buffer.String得到结果</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">comma</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r bytes.Buffer</span><br><span class="line"></span><br><span class="line">l := <span class="built_in">len</span>(s)</span><br><span class="line">mod := l % <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> mod &gt; <span class="number">0</span> &#123;</span><br><span class="line">r.Write([]<span class="keyword">byte</span>(s[:mod] + <span class="string">","</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> mod+<span class="number">3</span> &lt; l &#123;</span><br><span class="line">r.Write([]<span class="keyword">byte</span>(s[mod:mod+<span class="number">3</span>] + <span class="string">","</span>))</span><br><span class="line">mod += <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mod+<span class="number">3</span> == l &#123;</span><br><span class="line">r.Write([]<span class="keyword">byte</span>(s[mod:mod+<span class="number">3</span>]))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(r.String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">comma(<span class="string">"12345"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3-11"><a href="#练习3-11" class="headerlink" title="练习3.11"></a>练习3.11</h4><p>完善comma函数,以支持浮点数处理和一个可选的正负号的处理</p><ul><li>先处理(剔除)前置符号，在处理后置浮点数,最后<code>stings.Join</code>连接起来</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">comma</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> r bytes.Buffer</span><br><span class="line">start := <span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(s, <span class="string">"-"</span>) || strings.HasPrefix(s, <span class="string">"+"</span>) &#123;</span><br><span class="line">start = <span class="keyword">string</span>(s[<span class="number">0</span>])</span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">end := <span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> strings.Contains(s, <span class="string">"."</span>) &#123;</span><br><span class="line">ss := strings.Split(s, <span class="string">"."</span>)</span><br><span class="line">s, end = ss[<span class="number">0</span>], <span class="string">"."</span>+ss[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l := <span class="built_in">len</span>(s)</span><br><span class="line">mod := l % <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> mod &gt; <span class="number">0</span> &#123;</span><br><span class="line">r.Write([]<span class="keyword">byte</span>(s[:mod] + <span class="string">","</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> mod+<span class="number">3</span> &lt; l &#123;</span><br><span class="line">r.Write([]<span class="keyword">byte</span>(s[mod:mod+<span class="number">3</span>] + <span class="string">","</span>))</span><br><span class="line">mod += <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mod+<span class="number">3</span> == l &#123;</span><br><span class="line">r.Write([]<span class="keyword">byte</span>(s[mod:mod+<span class="number">3</span>]))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(strings.Join([]<span class="keyword">string</span>&#123;start, r.String(), end&#125;, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">comma(<span class="string">"12345"</span>)</span><br><span class="line">comma(<span class="string">"12345.1"</span>)</span><br><span class="line">comma(<span class="string">"-12345.1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3-12"><a href="#练习3-12" class="headerlink" title="练习3.12"></a>练习3.12</h4><p>编写一个函数,判断两个字符串是否是相互打乱的,也就是说它们有着相同的字符,但是对应不同的顺序</p><ul><li>遍历字符串A,对比字符在两个字符串的个数是否相等</li><li>字符串遍历有坑，得到的是数字，需要string转换一下类型</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">same</span><span class="params">(s1, s2 <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s1 &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Count(s1, <span class="keyword">string</span>(v)) != strings.Count(s2, <span class="keyword">string</span>(v)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(same(<span class="string">"123"</span>, <span class="string">"122"</span>))</span><br><span class="line">fmt.Println(same(<span class="string">"123"</span>, <span class="string">"3321"</span>))</span><br><span class="line">fmt.Println(same(<span class="string">"123"</span>, <span class="string">"321"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3-13"><a href="#练习3-13" class="headerlink" title="练习3.13"></a>练习3.13</h4><p>编写KB、MB的常量声明,然后扩展到YB</p><ul><li>iota </li></ul><p>暂略</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第三章&quot;&gt;&lt;a href=&quot;#第三章&quot; class=&quot;headerlink&quot; title=&quot;第三章&quot;&gt;&lt;/a&gt;第三章&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;整数&lt;/li&gt;
&lt;li&gt;浮点数&lt;/li&gt;
&lt;li&gt;复数&lt;/li&gt;
&lt;li&gt;布尔值&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;常量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一章阅读体验很好，因为书上给的示例很炫酷，产生的结果是炫酷的图形，然而想要理解却挺头痛，因为需要一些基础的图形学知识，这章习题做得比较头疼，不是因为代码逻辑，而是因为”业务逻辑”&lt;/p&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第二章(程序结构)</title>
    <link href="https://www.zoulei.net/2018/06/05/the_go_programming_lang_usage_answer_2/"/>
    <id>https://www.zoulei.net/2018/06/05/the_go_programming_lang_usage_answer_2/</id>
    <published>2018-06-05T15:52:24.000Z</published>
    <updated>2018-06-05T23:52:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul><li>名称</li><li>声明</li><li>变量</li><li>赋值</li><li>类型声明</li><li>包和文件</li><li>作用域</li></ul><a id="more"></a><h4 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2.1:"></a>练习2.1:</h4><p>添加类型、常量和函数到tempconv包中，处理以开尔文为单位(K)的温度值,0K=-273.15℃,变化1K和变化1℃是等价的</p><ul><li>很水的题</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Kelvin <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Kelvin)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%gK"</span>, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToK</span><span class="params">(c Celsius)</span> <span class="title">Kelvin</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Kelvin(c - <span class="number">273.15</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KToC</span><span class="params">(k Kelvin)</span> <span class="title">Celsius</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> Celsius(k + <span class="number">273.15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2.2"></a>练习2.2</h5><p>写一个类似于cf的通用的单位转换程序,从命令行参数或者标准输入(如果没有参数)获取数字,然后将每一个数字转换为以摄氏温度和华氏温度表示的温度,以英寸和米表示的长度单位,以磅和千克表示的重量单位,等等</p><ul><li>略，同很水</li></ul><h4 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2.3:"></a>练习2.3:</h4><p>使用循环重写PopCount来代替单个表达式.对比两个版本的效率</p><ul><li>下面连续三道题都是经典面试题，求二进制数中1的个数，限定了正整数</li><li>书上的代码主要是预先计算,将64bit每8bit一组,8bit会有二的八次方种结果，共256种结果，将所有的结果都先计算出来(空间换时间)</li><li>预计算主要是这一步<code>pc[i] = pc[i/2] + byte(i&amp;1)</code>，注意此处的含义是除以二表示二进制数右移一位，后面表示最后一位是1还是0</li><li>代码中<code>[256]byte</code>换成<code>[256]int</code>，更好理解。可能这样写只是为了让人更加能搞明白byte和int的各种转换吧</li><li>注意这种预计算的执行效率是很高的</li></ul><p>书上给的代码还是比较扭曲的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2000000000         0.32 ns/op</span></span><br><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">pc[i] = pc[i/<span class="number">2</span>] + <span class="keyword">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">0</span>*<span class="number">8</span>))] +</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">1</span>*<span class="number">8</span>))] +</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">2</span>*<span class="number">8</span>))] +</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">3</span>*<span class="number">8</span>))] +</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">4</span>*<span class="number">8</span>))] +</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">5</span>*<span class="number">8</span>))] +</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">6</span>*<span class="number">8</span>))] +</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">7</span>*<span class="number">8</span>))])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成循环</p><ul><li>惊不惊喜，意不意外，速度居然爆降低100倍</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount1</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := <span class="keyword">byte</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">uint8</span>(<span class="number">0</span>); i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">ret += pc[<span class="keyword">byte</span>(x&gt;&gt;(i*<span class="number">8</span>))]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPopCount1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// 100000000        21.4 ns/op</span></span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">PopCount1(<span class="number">2</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2.4"></a>练习2.4</h4><p>写一个用于统计位的PopCount,它在其实际参数的64位上执行移位操作,每次判断最右边的位,进而实现统计功能.把它与快查表版本的性能进行对比</p><ul><li>很普通的写法</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount2</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> x&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">ret += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">x = x &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPopCount2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// 20000000        60.5 ns/op</span></span><br><span class="line"><span class="comment">// &gt;&gt; 循环</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">PopCount2(<span class="number">2</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2-5"><a href="#练习2-5" class="headerlink" title="练习2.5"></a>练习2.5</h4><p>使用x&amp;(x-1)可以清除x最右边的非零位,利用该特点写一个PopCount,然后评价它的性能</p><ul><li>x&amp;(x-1)面试基础题</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount3</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">x = (x - <span class="number">1</span>) &amp; x</span><br><span class="line">ret += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPopCount3</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// 30000000        50.5 ns/op</span></span><br><span class="line"><span class="comment">// x&amp;(x-1)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">PopCount3(<span class="number">2</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后<del>~</del>还是挺奇葩，书上的写法居然是最快的，改成循环速度居然爆降，也不知道Go编译器是如何优化代码的╭(╯^╰)╮</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;名称&lt;/li&gt;
&lt;li&gt;声明&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;赋值&lt;/li&gt;
&lt;li&gt;类型声明&lt;/li&gt;
&lt;li&gt;包和文件&lt;/li&gt;
&lt;li&gt;作用域&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第一章(入门)</title>
    <link href="https://www.zoulei.net/2018/06/03/the_go_programming_language_answer_1/"/>
    <id>https://www.zoulei.net/2018/06/03/the_go_programming_language_answer_1/</id>
    <published>2018-06-03T12:56:37.000Z</published>
    <updated>2018-06-04T14:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个初学者超级喜欢这本书，值得反复阅读，常读常新。因为读了好多时间了，因此有一个计划把课后习题全部做完，每天做五题~~</p><p>Golang版本:1.10.1<br>IDE: GoLand<br>操作系统: 10.13.4</p><a id="more"></a><h4 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1.1"></a>练习1.1</h4><p>修改echo程序输出os.Args[0],即命令的名字</p><ul><li><code>os.Args</code>是一个slice</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOutputName</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(os.Args[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1.2"></a>练习1.2</h4><p>修改echo程序,输出参数的索引和值,每行一个</p><ul><li><code>for range</code>结构的使用</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestListArgs</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1-3"><a href="#练习1-3" class="headerlink" title="练习1.3"></a>练习1.3</h4><p>尝试测量可能低效的程序和使用strings.Join的程序在执行时间上的差异</p><ul><li>该用例大概显示相比<code>+=</code>,使用strings.Join要快1782倍</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringJoin1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// 11581441327 ns/op</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">100000</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">a[i] = <span class="string">"1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> a &#123;</span><br><span class="line">ret += i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringJoin2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// 2000    844351 ns/op</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">100000</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">a[i] = <span class="string">"1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">_ = strings.Join(a[:], <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1-4"><a href="#练习1-4" class="headerlink" title="练习1.4"></a>练习1.4</h4><p>修改dup2程序,输出出现重复行的文件的名称</p><ul><li>用结构体代替原有的string类型</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> line <span class="keyword">struct</span> &#123;</span><br><span class="line">FileName <span class="keyword">string</span></span><br><span class="line">String   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[line]<span class="keyword">int</span>)</span><br><span class="line">files := os.Args[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">countLines(os.Stdin, counts, <span class="string">"ARGS"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">f, err := os.Open(arg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup2: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">countLines(f, counts, f.Name())</span><br><span class="line">f.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s\t%s\t%d\n"</span>, line.FileName, line.String, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(file *os.File, counts <span class="keyword">map</span>[line]<span class="keyword">int</span>, fileName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">input := bufio.NewScanner(file)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">counts[line&#123;</span><br><span class="line">FileName: fileName,</span><br><span class="line">String:   input.Text(),</span><br><span class="line">&#125;]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="练习1-5"><a href="#练习1-5" class="headerlink" title="练习1.5"></a>练习1.5</h4><p>改变利萨如程序的画板颜色为绿色黑底来增加真实性。使用color.RGBA{0xRR,0xGG,0xBB,0xff}创建一种web颜色#RRGGBB,每一对十六进制数组表示组成一个像素红、绿、蓝分量的亮度。</p><ul><li>画板底色为palette的第一个元素，可采用<code>0x</code>表示十六进制数字</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"image/color"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"image/gif"</span></span><br><span class="line"><span class="string">"image"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> palette = []color.Color&#123;color.Black, color.RGBA&#123;</span><br><span class="line">R: <span class="number">0</span>,</span><br><span class="line">G: <span class="number">0xFF</span>,</span><br><span class="line">B: <span class="number">0</span>,</span><br><span class="line">A: <span class="number">0xFF</span>,</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">"web"</span> &#123;</span><br><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">lissajous(w)</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:8000"</span>, <span class="literal">nil</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">lissajous(os.Stdout)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">cycles  = <span class="number">5</span>     <span class="comment">// 完整的x振荡器变化的个数</span></span><br><span class="line">res     = <span class="number">0.001</span> <span class="comment">//角度分辨率</span></span><br><span class="line">size    = <span class="number">100</span>   <span class="comment">//图像画布包含 [-size..+size]</span></span><br><span class="line">nframes = <span class="number">64</span>    <span class="comment">//动画中的帧数</span></span><br><span class="line">delay   = <span class="number">8</span>     <span class="comment">//以10ms为单位的帧间延迟</span></span><br><span class="line">)</span><br><span class="line">freq := rand.Float64() * <span class="number">3.0</span> <span class="comment">// y振荡器的相对频率</span></span><br><span class="line">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">phase := <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</span><br><span class="line">rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</span><br><span class="line">img := image.NewPaletted(rect, palette)</span><br><span class="line"><span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</span><br><span class="line">x := math.Sin(t)</span><br><span class="line">y := math.Sin(t*freq + phase)</span><br><span class="line">img.SetColorIndex(size+<span class="keyword">int</span>(x*size+<span class="number">0.5</span>), size+<span class="keyword">int</span>(y*size+<span class="number">0.5</span>), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">phase += <span class="number">0.1</span></span><br><span class="line">anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</span><br><span class="line">anim.Image = <span class="built_in">append</span>(anim.Image, img)</span><br><span class="line">&#125;</span><br><span class="line">gif.EncodeAll(out, &amp;anim)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1-6"><a href="#练习1-6" class="headerlink" title="练习1.6"></a>练习1.6</h4><p>通过在画板中添加更多颜色，然后通过有趣的方式改变SetColorIndex的第三个参数,修改利萨如程序来产生多彩的图片</p><ul><li>没想到什么有趣的方式，随便用了个随机生成，<code>rand.Intn</code>,注意init在main前面被执行，因此随机种子需要放在init里面</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"image/color"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"image/gif"</span></span><br><span class="line"><span class="string">"image"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> palette []color.Color</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">256</span>; i++ &#123;</span><br><span class="line">palette = <span class="built_in">append</span>(palette, color.RGBA&#123;</span><br><span class="line">R: <span class="keyword">uint8</span>(rand.Intn(<span class="number">256</span>)),</span><br><span class="line">G: <span class="keyword">uint8</span>(rand.Intn(<span class="number">256</span>)),</span><br><span class="line">B: <span class="keyword">uint8</span>(rand.Intn(<span class="number">256</span>)),</span><br><span class="line">A: <span class="number">0xFF</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">"web"</span> &#123;</span><br><span class="line">handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">lissajous(w)</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:8000"</span>, <span class="literal">nil</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">lissajous(os.Stdout)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">cycles  = <span class="number">5</span>     <span class="comment">// 完整的x振荡器变化的个数</span></span><br><span class="line">res     = <span class="number">0.001</span> <span class="comment">//角度分辨率</span></span><br><span class="line">size    = <span class="number">100</span>   <span class="comment">//图像画布包含 [-size..+size]</span></span><br><span class="line">nframes = <span class="number">64</span>    <span class="comment">//动画中的帧数</span></span><br><span class="line">delay   = <span class="number">8</span>     <span class="comment">//以10ms为单位的帧间延迟</span></span><br><span class="line">)</span><br><span class="line">freq := rand.Float64() * <span class="number">3.0</span> <span class="comment">// y振荡器的相对频率</span></span><br><span class="line">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">phase := <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</span><br><span class="line">rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</span><br><span class="line">img := image.NewPaletted(rect, palette)</span><br><span class="line"><span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</span><br><span class="line">x := math.Sin(t)</span><br><span class="line">y := math.Sin(t*freq + phase)</span><br><span class="line">img.SetColorIndex(size+<span class="keyword">int</span>(x*size+<span class="number">0.5</span>), size+<span class="keyword">int</span>(y*size+<span class="number">0.5</span>), <span class="keyword">uint8</span>(rand.Intn(<span class="built_in">len</span>(palette))))</span><br><span class="line">&#125;</span><br><span class="line">phase += <span class="number">0.1</span></span><br><span class="line">anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</span><br><span class="line">anim.Image = <span class="built_in">append</span>(anim.Image, img)</span><br><span class="line">&#125;</span><br><span class="line">gif.EncodeAll(out, &amp;anim)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1-7"><a href="#练习1-7" class="headerlink" title="练习1.7"></a>练习1.7</h4><p>函数io.Copy(dst,src)从src读,并且写入dst.使用它代替ioutil.ReadAll来复制响应内容到os.StdOut,这样不需要装下整个数据流的缓冲区.确保检查io.Copy返回的错误结果</p><ul><li>io.Copy代替ioutil.ReadAll更省内存，同时也可以把它看做是一个同步的操作，返回了最终传输数据的大小</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line"><span class="keyword">go</span> fetch(url, ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%.2f elapsed\n"</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="keyword">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- fmt.Sprint(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">nbytes, err := io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"while reading %s: %v"</span>, url, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">secs := time.Since(start).Seconds()</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"%.2fs %7d %s"</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1-8"><a href="#练习1-8" class="headerlink" title="练习1.8"></a>练习1.8</h4><p>修改fetch程序添加一个http://前缀(假如该URL参数缺失协议前缀).可能会用到strings.HasPrefix</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddPrefix</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">inputURL := <span class="string">"z.cn"</span></span><br><span class="line"><span class="keyword">if</span> ! strings.HasPrefix(inputURL, <span class="string">"http"</span>) &#123;</span><br><span class="line">inputURL = <span class="string">"http://"</span> + inputURL</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(inputURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1-9"><a href="#练习1-9" class="headerlink" title="练习1.9"></a>练习1.9</h4><p>修改fetch来输出http状态码,可以在resp.Status中找到它</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOutputStatusCode</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">resp, _ := http.Get(<span class="string">"http://z.cn"</span>)</span><br><span class="line">fmt.Println(<span class="string">"StatusCode: "</span>, resp.StatusCode)</span><br><span class="line">io.Copy(os.Stdout, resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习1-10"><a href="#练习1-10" class="headerlink" title="练习1.10"></a>练习1.10</h4><p>找一个产生大量数据的网站.连续两次运行fetchall,看报告的时间是否会有大的变化,调查缓存情况.每一次获取的内容一样吗?修改fetchall将内容输出到文件,这样可以检查它是否一致</p><ul><li>这问题不是他傻就是我傻，我还是偏向是他傻。猜测有可能说的是访问网站第一次很慢，第二次会因为缓存策略加速传输(比如http运营商缓存啥的)，亦或者是本机缓存304状态码(但是两次完全独立的访问和这个扯不上什么关系)</li></ul><h4 id="练习1-11"><a href="#练习1-11" class="headerlink" title="练习1.11"></a>练习1.11</h4><p>使用更长的参数列表来尝试fetchall,例如使用alexa.com排名前100万的网站,如果一个网站没有响应,程序的行为是则么样的</p><ul><li><a href="http://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="noopener">Go net/http 超时机制完全手册</a></li><li>虽然每个URL都对应了一个chan，但是有可能某几个URL特别慢，那么所有的请求都需要等到最慢的那个完成，比如你在本地<code>nc -l 8000</code>监听端口，再直接使用<code>http.Get</code>访问。它默认永不超时，直到tcp连接被中断</li><li>打开太多的链接会启用N多的goroutine，这样会达到系统上限，比如触发常见的<code>too many open files</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个初学者超级喜欢这本书，值得反复阅读，常读常新。因为读了好多时间了，因此有一个计划把课后习题全部做完，每天做五题~~&lt;/p&gt;
&lt;p&gt;Golang版本:1.10.1&lt;br&gt;IDE: GoLand&lt;br&gt;操作系统: 10.13.4&lt;/p&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>mac上使用mitmproxy对ios app进行抓包</title>
    <link href="https://www.zoulei.net/2018/05/25/mitmproxy_transparent_model_network_capture/"/>
    <id>https://www.zoulei.net/2018/05/25/mitmproxy_transparent_model_network_capture/</id>
    <published>2018-05-25T09:45:59.000Z</published>
    <updated>2018-05-25T10:52:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>对ios app抓包的方式挺多的，最常规的方案就是本机开启一个http代理。然后手机进行设置，将本机内网ip以及端口设置上去。安装一个https证书，设置为信任就可以开始抓包了。这个方案非常通用。类似的实现以Fiddler、charles为代表，它们确实很好用，也很好理解。但是缺点也是有的</p><ul><li>最大的缺点就是每一次使用都需要设置代理，你需要查看本机内网ip，然后填写到手机上。调试完成后再将手机的代理设置清除</li><li>Fiddler只有windows版本可用，意味着mac需要使用虚拟机，charles并没有Fiddler好用，然而还卖的贼贵</li></ul><p>同类型的开源方案最常见的是Python实现的mitmproxy。mitmweb也提供图形界面，别说，只要你不嫌弃还是挺好用的</p><p>osx上还有个比较奇葩的所谓网络调试软件Surge。99美刀，卖的还是挺贵的，功能还行，界面也挺花哨，忽悠小白是足够了。用它也能够远程调试，代价是需要用有线连接到mac电脑上，然后mac端软件就能捕获远程手机的网络请求数据，这个软件界面确实挺不错，然而请求过滤查找对比下Fiddler而言就是个渣渣吧。</p><p>因此想了一个比较另类的方案，手机使用mac电脑的网络，同时使用pf对请求进行转发。使用mitmproxy的透明代理模式获得手机端的数据，使用mitmweb进行展示</p><a id="more"></a><h3 id="本篇环境"><a href="#本篇环境" class="headerlink" title="本篇环境"></a>本篇环境</h3><ul><li>机器 MBP 2015/ ipad mini</li><li>系统  osx 10.13/ ios 11.3</li></ul><h3 id="1-让ipad通过蓝牙连上osx的网络"><a href="#1-让ipad通过蓝牙连上osx的网络" class="headerlink" title="1. 让ipad通过蓝牙连上osx的网络"></a>1. 让ipad通过蓝牙连上osx的网络</h3><p>参照<a href="https://www.zhihu.com/question/24480413" target="_blank" rel="noopener">https://www.zhihu.com/question/24480413</a>，先让手机通过蓝牙连接上电脑，在电脑设置网络共享，选择蓝牙的方式，这一步基本就配置好了</p><p>接下来是验证。通过<code>ifconfig</code>命令查看目前存在哪些网络接口，查看active状态的接口，自己排除一下。像我的就是<code>bridge100</code>。然后可以使用wireshark看一下这个网络接口是否正常收到了手机端的数据请求<code>sudo /Applications/Wireshark.app/Contents/MacOS/Wireshark</code>。待能正常通过电脑网络访问后进行后续操作</p><h3 id="通过PF对网络数据进行转发"><a href="#通过PF对网络数据进行转发" class="headerlink" title="通过PF对网络数据进行转发"></a>通过PF对网络数据进行转发</h3><ol><li><p>允许ip转发</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.inet.ip.forwarding=1</span><br></pre></td></tr></table></figure></li><li><p>设置pf转发规则(将80、443端口的内容转发到本地8080端口)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/pf.conf</span><br><span class="line">添加如下行(记住使用对应的网络接口)</span><br><span class="line">另外pf的配置对顺序有要求，像我本机就需要将它放到rdr-anchor &quot;com.apple/*&quot;下一行</span><br><span class="line">rdr on bridge100 inet proto tcp to any port &#123;80, 443&#125; -&gt; 127.0.0.1 port 8080</span><br></pre></td></tr></table></figure></li><li><p>启用pf规则</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pfctl -e</span><br></pre></td></tr></table></figure></li><li><p>配置sudoer文件允许mitmproxy访问pfctl</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sudoers</span><br><span class="line">添加以下行</span><br><span class="line">ALL ALL=NOPASSWD: /sbin/pfctl -s state</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装mitmproxy使用"><a href="#安装mitmproxy使用" class="headerlink" title="安装mitmproxy使用"></a>安装mitmproxy使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install mitmproxy</span><br><span class="line">mitmweb -T --ignore apple</span><br></pre></td></tr></table></figure><p>手机端访问<code>http://mimt.it</code>点击安装https证书。除此之外还需要设置-&gt; 通用 -&gt; 关于  -&gt; 信任证书设置 -&gt; 设置为可信。<br>上面ignore参数是正则匹配。忽略对域名包含apple的处理。因为在客户端强制证书验证的时候伪造证书是过不了的，这样会在调试的时候影响ios消息推送啥的<br>bingo~~ 结束了</p><p>不足之处就是它并不会显示访问的域名，只会显示ip(感觉这是一个bug，因为mitmproxy使用–host参数是能够看到正确的地址的)</p><p>然后就是学习一下mitmproxy的过滤语句了，很简单，在web操作上会有提示</p><p>整个过程就是这样，让手机通过电脑进行上网，用mitmproxy的透明代理模式从三层网络上捕获数据(这样就避免了在手机端设置代理)，希望能对你们有所帮助┑(￣Д ￣)┍</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://docs.mitmproxy.org/stable/howto-transparent/" target="_blank" rel="noopener">https://docs.mitmproxy.org/stable/howto-transparent/</a><br><a href="https://medium.com/bugbountywriteup/intercepting-network-data-with-mitmproxy-on-macos-3e3f2f0123b2" target="_blank" rel="noopener">https://medium.com/bugbountywriteup/intercepting-network-data-with-mitmproxy-on-macos-3e3f2f0123b2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对ios app抓包的方式挺多的，最常规的方案就是本机开启一个http代理。然后手机进行设置，将本机内网ip以及端口设置上去。安装一个https证书，设置为信任就可以开始抓包了。这个方案非常通用。类似的实现以Fiddler、charles为代表，它们确实很好用，也很好理解。但是缺点也是有的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大的缺点就是每一次使用都需要设置代理，你需要查看本机内网ip，然后填写到手机上。调试完成后再将手机的代理设置清除&lt;/li&gt;
&lt;li&gt;Fiddler只有windows版本可用，意味着mac需要使用虚拟机，charles并没有Fiddler好用，然而还卖的贼贵&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同类型的开源方案最常见的是Python实现的mitmproxy。mitmweb也提供图形界面，别说，只要你不嫌弃还是挺好用的&lt;/p&gt;
&lt;p&gt;osx上还有个比较奇葩的所谓网络调试软件Surge。99美刀，卖的还是挺贵的，功能还行，界面也挺花哨，忽悠小白是足够了。用它也能够远程调试，代价是需要用有线连接到mac电脑上，然后mac端软件就能捕获远程手机的网络请求数据，这个软件界面确实挺不错，然而请求过滤查找对比下Fiddler而言就是个渣渣吧。&lt;/p&gt;
&lt;p&gt;因此想了一个比较另类的方案，手机使用mac电脑的网络，同时使用pf对请求进行转发。使用mitmproxy的透明代理模式获得手机端的数据，使用mitmweb进行展示&lt;/p&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>ocr.ficapy.com 后台实现</title>
    <link href="https://www.zoulei.net/2018/04/01/pdfaddtext_architecture/"/>
    <id>https://www.zoulei.net/2018/04/01/pdfaddtext_architecture/</id>
    <published>2018-04-01T06:34:38.000Z</published>
    <updated>2019-07-26T06:53:30.724Z</updated>
    
    <content type="html"><![CDATA[<p>因为个人需求，写了一个很小众的作品，<a href="https://ocr.ficapy.com" target="_blank" rel="noopener">https://ocr.ficapy.com</a>，我给它起的项目名是pdfaddtext，用途是给扫描版本的PDF文件加上搜索功能。使用场景是我有几本扫描版本的PDF书籍(网上有特别多的扫描版书籍)，有时候想搜索书中有没有提到某个知识点，纯图片是无法搜索的，你只能凭记忆去找。<span style="color:red"><strong>本项目作用就是将PDF的文本内容识别出来，然后写入一层隐藏的文字层，这样PDF阅读器就能够搜索这些文字了，同时尽量保证将识别出来的文字写到原图片对应的位置</strong></span>,类似的工具有<a href="https://github.com/jbarlow83/OCRmyPDF" target="_blank" rel="noopener">OCRmyPDF</a>，它的缺点很明显，使用Tesseract OCR引擎，对比识别效果，简直被商用OCR吊打。</p><p>最开始有了这个想法，我大概花费了一个下午的时间用python写出了基本的demo。将每一页PDF转换成图片，然后用免费的OCR服务去识别，得到结果，最后合并出一个新的pdf出来。过程算是比较顺利。本着独乐乐不如众乐乐的心态。我计划将它转变成一项web服务，于是挖坑之旅就此开始了</p><p>TLDR</p><a id="more"></a><p>开始的构思是这个样子的<img src="https://blogimg.ficapy.com/blogimg/pdfaddtext_arch1.png" alt="pdfaddtext1"><br>后台接收到文件进行拆分，依次获取结果最后服务端生成文件返回给客户端。流程完成，是不是特简单😕</p><h3 id="问题一-pdf转换生成jpg效率过低"><a href="#问题一-pdf转换生成jpg效率过低" class="headerlink" title="问题一: pdf转换生成jpg效率过低"></a>问题一: pdf转换生成jpg效率过低</h3><p>python的生态无需质疑，各种包齐全到你怀疑人生。pdf转换成jpg也都是有的，比如<a href="https://github.com/Belval/pdf2image" target="_blank" rel="noopener">pdf2image</a>。它有一个无法忽视的缺点，效率太低。个人处理少量问题可以，但是如果用于web服务。每生成一张照片卡两秒，肯定无法忍受，后来对比imagemagick和ghostscript，ghostscript的效率比imagemagick高一些，当然比python不知道高到哪里去了。注: imagemagick的pdf转图片底层使用的是ghostscript，最后选择了subprocess调用ghostscript</p><h3 id="问题二-OCR效率过低"><a href="#问题二-OCR效率过低" class="headerlink" title="问题二: OCR效率过低"></a>问题二: OCR效率过低</h3><p>目前没有能力搭建一个识别准确度比较高的文字识别引擎，于是使用了免费的OCR。在网上腾讯的免费OCR口碑是很不错的，超高的识别准确率，而且看文档发现不限制识别次数，只是不保证并发(是不是感觉超级良心！)。醒醒了少年，哪里有这么好的事情！！！</p><p>我刚开始用的时候大概四五秒返回结果。识别准确率网上没有瞎吹，对中文的准确率还是很不错的，后来可能该服务用的人太多，效率大幅度降低。降低到10到20秒才会返回结果。而且经常性返回系统繁忙的错误。这也可能和我的需求有关，因为我上传的识别素材都是1000像素以上的图片。里面的文字众多，所以识别效率比较低。但是腾讯提供的免费OCR服务有劣化服务质量的嫌疑，毕竟如果免费的服务提供的过于的好，用户付费的热情肯定大幅度降低。很明显的是你上传一张图片得到结果，之后再次上传依旧是等待十几秒才得到结果，稍微正常的开发肯定都知道将结果缓存一下，再次相同的图片请求直接返回结果。鉴于腾讯OCR的低效，我不得不找其他的OCR服务同时使用，保证系统的可靠性，最终同时使用了以下服务</p><ul><li><a href="https://ai.qq.com/doc/ocridcardocr.shtml" target="_blank" rel="noopener">腾讯</a></li><li><a href="https://cloud.baidu.com/doc/OCR/OCR-API.html#.E8.BF.94.E5.9B.9E.E6.A0.BC.E5.BC.8F" target="_blank" rel="noopener">百度</a></li><li><a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/computer-vision/" target="_blank" rel="noopener">微软</a></li><li><a href="http://ai.sogou.com/ai-docs/api/ocr" target="_blank" rel="noopener">搜狗</a></li><li><a href="https://console.faceplusplus.com.cn/documents/7776484" target="_blank" rel="noopener">faceplusplus</a></li></ul><p>开发过程中的<span style="color:red"><strong>个人感觉</strong></span>,识别准确率依次是百度&gt;腾讯&gt;搜狗&gt;微软&gt;faceplusplus</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分别是百度  腾讯  搜狗  微软 face++     对同一张简单图片的识别结果</span><br><span class="line">[[&apos;这是第一段文字&apos;, 316, 123, 22, 131], [&apos;这个地方是第二段Ohye&apos;, 213, 286, 21, 195]]</span><br><span class="line">[[&apos;这是第一段文字&apos;, 316, 123, 22, 131], [&apos;这个地方是第二段Ohye&apos;, 213, 286, 21, 195]]</span><br><span class="line">[[&apos;这是第一段文字&apos;, 309, 122, 24, 149], [&apos;这个地方是第二段Ohye&apos;, 202, 283, 26, 213]]</span><br><span class="line">[[&apos;这是第一段文字&apos;, 318, 125, 21, 124], [&apos;这个地方是第二段Ohye&apos;, 220, 290, 21, 189]]</span><br><span class="line">[[&apos;这是第一段文字&apos;, 319, 125, 19, 128], [&apos;个地方是第段Oye&apos;, 232, 286, 22, 176]]</span><br></pre></td></tr></table></figure><p>基本上国内能免费使用的OCR服务我都给想办法整合了，它们的输出都差不多，提供文字在图片中的定位功能，除了腾讯返回很慢，其他服务基本都在四秒左右返回。搜狗的OCR服务很低调，好像知道的人都不多，而且是这些服务里面文档最奇葩的，文档几乎没有，就提供了一个PHP调用服务的demo。</p><p>即便同时使用了五个免费服务，依旧不够用，而且几乎除了腾讯是不限制每日调用次数，其他的服务都会限制每天最多调用多少次。最后预估每天可供识别的图片数量最多不超过3000页。<span style="color:red"><strong>底层OCR服务的限制直接导致了设计复杂度的成倍上升</strong></span>，如果本地能在500毫秒内识别得到一个结果，也就没那么多事儿了。</p><h3 id="问题三：更快的响应"><a href="#问题三：更快的响应" class="headerlink" title="问题三：更快的响应"></a>问题三：更快的响应</h3><p>如果是单人使用,那么一个任务进行完毕之后再进行下一个任务。不存在并发调度的问题。但是它作为一项web服务，势必会存在并发问题，当某个用户正在执行转换操作，此时另外一个用户又提交了一个任务请求。是选择继续将前面的任务执行完毕再执行后续的(先到先服务)，还是采取一定的策略进行乱序执行。本程序选择了<span style="color:red"><strong>短任务优先策略</strong></span>，以pdf中的单页作为最小任务单元，使用优先级队列对任务进行排序。将每一个任务未完成的页数作为比较元素。每次选择任务的时候总是从优先级中选择未完成页数最少的任务优先执行。同时为了避免饥饿，假设存在几百页的大文件，每隔一分钟，按照任务的创建时间来调整任务优先级</p><p>最开始的最简架构几乎是认为不存在并发的。但是不并发是不可能的，所以流程改成了这样<br><img src="https://blogimg.ficapy.com/blogimg/pdfaddtext_arch2.png" alt="pdfaddtext_arch2"></p><ol><li>用户将图片上传到阿里云OSS, 后台接收到回调后下载文件。返回给客户端任务id。</li><li>客户端根据此ID创建websocket连接。后台下载文件完毕后发送redis队列消息。</li><li>开启一个独立的PDF分片进程。接收到消息后进程获取文件地址，然后将PDF文件的每一页转换成图片(放到特定的目录)。</li><li>生产者负责轮询目录发现新生成的图片。然后每一张图片被封装成一个Task任务对象，被加入到全局队列，全局队列的基本格式是一个字典{file_md5:Queue}，每一个文件都拥有一个队列。</li><li><span style="color:red"><strong>消费者负责从队列中获取一个任务。获取的规则是从优先级队列中找到第一个文件md5。然后在全局队列中对应文件md5队列中取出一个任务</strong>，执行任务，更新优先级队列，如果该文件被全部执行完成则返回结果</span></li></ol><p>这里涉及到了三个很重要的地方、<span style="color:red"><strong>Task任务、全局队列、优先级队列</strong></span>。其中第五步是整个过程中最容易出现错误的地方。</p><p>后台整个是使用Tornado实现的，最开始我考虑的是将PDF分片使用multiprocess进程来实现就好了。后来考虑它要是挂了怎么办。如果它挂了整个流程就无法进行。如果一定要将它使用multiprocess，那么将不得不监控它是不是挂掉了对它进行重启。最后还是将它独立出来用supervisord处理了</p><h3 id="问题四-锁-amp-死锁"><a href="#问题四-锁-amp-死锁" class="headerlink" title="问题四: 锁&amp;死锁"></a>问题四: 锁&amp;死锁</h3><p>上图中的消费者和生产者并不是简单的共享同一个任务队列。消费者取出任务的流程是先读取优先级队列得到文件md5，再从全局队列字典中获得相应队列获得任务。设想程序最开始从优先级队列里面取得的是空值。再用空值去查找全局队列无疑会被报错。要么你就在获取任务的时候使用while语句不断的判断当前优先级任务队列是否有元素。然而在Tornado里面死循环这种方式是不允许的，会直接造成其他部分无法执行，无法响应用户请求。因此需要使用Tornado提供的tornado.lock.Event。在读取优先级队列之前先判断该事件锁是否被锁。如果被锁那么coroutine就被阻塞。这样只需要在优先级队列添加和删除元素的地方统一处理。添加元素的时候取消锁。取消元素的时候判断优先级队列是否为空。为空则设置锁</p><p>为了不浪费系统资源。如果一个用户的任务正在被执行，而此时用户退出了。毫无疑问，这种情况下本着快速响应的原则，我们会直接删掉该文件的所有任务。再删掉任务之前，该文件在优先级队列中排列在最前面，因此，就有可能有的消费者获取了该文件的队列锁。然而{file_md5: Queue}任务队列被删除，意味着获取到锁的消费者永远无法被执行，造成死锁，该消费者再也无法消费任务。亦或者一个文件任务在未完成之前所有的消费者都会去读取这个队列，当任务被完成的时候(该队列会被删除)总有消费者还在持有该锁。避免方法是获取锁设置超时时间(比如五秒)，如果没有获取到任务直接报告异常，捕获异常，返回一个空任务，消费者对空任务忽略处理，等待再次去全局队列获取任务，此时刚才的文件队列应该已经删除了。</p><p>注: 系统重启的时候清空redis优先级队列(后来想了一下优先级队列不必要放在redis当中,直接python实现也是可以的，它并没有持久化的需求)</p><h3 id="问题五-何时触发redis消息，何时将任务加入到优先级队列"><a href="#问题五-何时触发redis消息，何时将任务加入到优先级队列" class="headerlink" title="问题五: 何时触发redis消息，何时将任务加入到优先级队列"></a>问题五: 何时触发redis消息，何时将任务加入到优先级队列</h3><p>这好像不是一个问题。最开始的时候我选择在文件下载完成后发送redis消息并加入到优先级队列。<br>先想这样一个问题，当用户断开后为了节省资源势必会选择立刻删掉优先级队列(同时删掉全局队列的相关项TODO:我好像没有考虑两个用户正在处理同一个PDF一个用户断线的情况)。假设用户是非正常断开(它过几秒后会再次连接，我是不是闲的蛋疼。考虑这种情况😕)。为了更好的体验会选择前端重连机制。我们希望重连后任务能恢复并继续。如果在下载完成后发送redis消息。那么websocket重连就不会发消息了。此时这个任务就没办法继续了</p><p>你会想，前端重连我也可以采用模拟重新上传文件的步骤啊<del>~</del>，too navie! 上传的时候添加了google验证码这一步。重新模拟上传自动化是做不到的。所以发送redis这一步再建立websocket连接后发比较合适<br>问题又来了。建立websocket后文件还没有下载完毕，此时发送redis消息到分片进程，分片进程无疑会出错。解决方法就和上面那个锁一样。添加Event事件锁，下载的时候执行set</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">download_event = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> self.file_md5 <span class="keyword">in</span> download_event:</span><br><span class="line">    download_event[self.file_md5].set()</span><br><span class="line">    IOLoop().instance().call_later(<span class="number">2</span>, <span class="keyword">lambda</span>: download_event.pop(self.file_md5, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>优先级队列可供选择的地方就更多了</p><ol><li>文件下载完成后</li><li>websocket建立连接后</li><li>生产者添加任务后<br>这里最重要的是不要在多个地方插入同一个事件，出了问题不好debug。下载完成前标志着第一次建立连接，websocket有可能标志着断线重连。它们最终都会走向生产者这个地方，所以我选择在生产者这里添加。先检测该file_md5是否存在对应的websocket连接，如果存在则加入全局队列，同时加入优先级队列</li></ol><h3 id="优化一：重复文件直接得到结果"><a href="#优化一：重复文件直接得到结果" class="headerlink" title="优化一：重复文件直接得到结果"></a>优化一：重复文件直接得到结果</h3><p>如果文件在后台数据库存在记录，如果该文件全部结果都正确存在则直接返回结果。如果正在被执行或者有部分内容没有被OCR。则后台新建任务，总而言之，避免用户再次上传文件到阿里云OSS</p><h3 id="优化二：减少OCR次数"><a href="#优化二：减少OCR次数" class="headerlink" title="优化二：减少OCR次数"></a>优化二：减少OCR次数</h3><p>OCR的机会很宝贵,所以应该尽量减少OCR的次数，首先想到的是同一个文件如果得到了结果就不需要再次去调用OCR接口，再其次，一个PDF文件由N张图片组成。对每一张图片进行相似度判断，如果足够相似就认为它是同一张图片避免再次执行识别操作。图片相似度算法前面有博文提到，使用的是<a href="https://github.com/JohannesBuchner/imagehash" target="_blank" rel="noopener">imagehash</a>。对每张图片生成64bit的标识。比对的时候使用汉明距离检查是否相似。数据库优化汉明距离的方法前面博文也有提到</p><h3 id="优化三-使用浏览器客户端进行PDF合并"><a href="#优化三-使用浏览器客户端进行PDF合并" class="headerlink" title="优化三:  使用浏览器客户端进行PDF合并"></a>优化三:  使用浏览器客户端进行PDF合并</h3><p>如果用户上传的文件为100M，在后台生成文件并提供给用户下载，OSS外网下载的价格大概是1G五毛。嗯。上传几个大文件，来几次恶意下载，等着天价账单吧😀。因此这种应用采取客户端渲染是很有必要的，我先找了一下js的库。号称”任何能够用JavaScript实现的应用系统，最终都必将用JavaScript实现”~~,然并卵，我并没有找到允许修改PDF文件的开源js库，关于PDF的要么是渲染用，要么就是从0生成一个新的PDF文件。后来我找到了商业的js库pspdfkit(也有一些其他的，当然它们价格都不菲)，它让我知道了有webassembly这个东东的存在，它允许c/c++/rust代码再浏览器端执行。虽然c/c++/rust我一个都不会, 但是我还是找到了一个c++的库<a href="https://github.com/galkahana/PDF-Writer" target="_blank" rel="noopener">PDF-Writer</a>，看到了希望的曙光内心是激动的。然后我去刷C的教程，再刷了一遍C++的教程，知道了Hello World怎么写。参照了几个webassembly的项目(大多数都是用C写的)。重点参照了这个<a href="https://github.com/antelle/wasm-image-compressor" target="_blank" rel="noopener">wasm-image-compressor</a>。最终还真给折腾出来了(前端耗费的时间占据了整个开发的一大半)。结果是编译后大小为1.5M，实现了两个功能。验证PDF文件是否有效(可以正常解析，页数是否符合要求，每页大小是否符合要求)，传入PDF文件和json结果，生成一个新的文件。<br>别说效率还真不错，生成文件过程比python快很多</p><p>该项目提供了两种生成PDF的方式，<a href="https://ocr.ficapy.com" target="_blank" rel="noopener">浏览器端</a> 和<a href="https://gist.github.com/ficapy/baef42b378685e5853d709f2a69eadd1" target="_blank" rel="noopener">python脚本</a>,这两种方式生成的PDF文件方式是不一样的。python的方式是合并两个图层，新的canvas图层透明度为完全透明.c++的方式是采取追加的方式，设置每个元素的可见性为不可见</p><p>其次是字体的问题，写入文字的时候都需要指明字体。然而附带一个完整的字体会浪费巨大的空间。我找了一个比较小一点的中文字体，大小是1.5M。感觉这些文字不需要真正的显示出来，所以自己制作一个最小的字体带她这个中文字体是有可能的，但是我失败了。制作出来后电脑能够正常识别，C++库结果无法正常打开该字体</p><h3 id="优化四-采用msgpack进行传输"><a href="#优化四-采用msgpack进行传输" class="headerlink" title="优化四: 采用msgpack进行传输"></a>优化四: 采用msgpack进行传输</h3><p>直接对结果进行json编码传输还是很不划算的,因此本项目数据存储以及前后端传输采用msgpack进行压缩后传输。需要注意的是websocket对二进制流需要特殊指定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(url);</span><br><span class="line">socket.binaryType = <span class="string">'arraybuffer'</span>;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> raw_data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(event.data);</span><br><span class="line">    ret = msgpack.decode(raw_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进方向"><a href="#改进方向" class="headerlink" title="改进方向"></a>改进方向</h3><ol><li>目前20页的限制让网页端几乎没有作用,提供一个稍有质量的本地OCR,对于数百页的PDF选择在本地识别</li><li>解决中文字体过大的问题，同时优化前端大小，尽量让压缩后的页面加载大小到1M以内</li><li>后台对PDF进行预处理,如果发现可直接读取文字表示该页不需要被OCR</li><li>改进前端发布逻辑，每次变动文件名让CDN缓存很尴尬</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://bertanguven.com/faster-conversions-from-pdf-to-pngjpeg-imagemagick-vs-ghostscript" target="_blank" rel="noopener">Faster conversions from PDF to PNG/JPEG, imagemagick vs ghostscript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为个人需求，写了一个很小众的作品，&lt;a href=&quot;https://ocr.ficapy.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ocr.ficapy.com&lt;/a&gt;，我给它起的项目名是pdfaddtext，用途是给扫描版本的PDF文件加上搜索功能。使用场景是我有几本扫描版本的PDF书籍(网上有特别多的扫描版书籍)，有时候想搜索书中有没有提到某个知识点，纯图片是无法搜索的，你只能凭记忆去找。&lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;本项目作用就是将PDF的文本内容识别出来，然后写入一层隐藏的文字层，这样PDF阅读器就能够搜索这些文字了，同时尽量保证将识别出来的文字写到原图片对应的位置&lt;/strong&gt;&lt;/span&gt;,类似的工具有&lt;a href=&quot;https://github.com/jbarlow83/OCRmyPDF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OCRmyPDF&lt;/a&gt;，它的缺点很明显，使用Tesseract OCR引擎，对比识别效果，简直被商用OCR吊打。&lt;/p&gt;
&lt;p&gt;最开始有了这个想法，我大概花费了一个下午的时间用python写出了基本的demo。将每一页PDF转换成图片，然后用免费的OCR服务去识别，得到结果，最后合并出一个新的pdf出来。过程算是比较顺利。本着独乐乐不如众乐乐的心态。我计划将它转变成一项web服务，于是挖坑之旅就此开始了&lt;/p&gt;
&lt;p&gt;TLDR&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 杂项</title>
    <link href="https://www.zoulei.net/2018/03/20/Tornado_misc/"/>
    <id>https://www.zoulei.net/2018/03/20/Tornado_misc/</id>
    <published>2018-03-20T06:50:09.000Z</published>
    <updated>2018-03-20T07:23:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado系列基本介绍的差不多了，本篇介绍一些零散的东西。有了前面的知识，本篇会讲的比较粗略</p><a id="more"></a><h3 id="set-blocking-signal-threshold"><a href="#set-blocking-signal-threshold" class="headerlink" title="set_blocking_signal_threshold"></a>set_blocking_signal_threshold</h3><p>因为Tornado是单线程的，因此当一个任务被阻塞一两秒钟基本就是哪里出问题了，该函数给了我们一个机会察觉这些问题。可以当发生阻塞超过阈值的时候执行相关回调函数</p><p>实现原理就是使用信号机制，先使用<code>signal.signal(signal.SIGALRM,callback)</code>注册信号回调函数。在ioloop主循环中每次事件完成后将实时计时器归零<code>signal.setitimer(signal.ITIMER_REAL, 0, 0)</code>后再重新开始计时。如果主循环被阻塞没有被执行计时器归零则会被触发</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>有一些情况我们会部署多个Tornado实例用来增加系统整体吞吐量，有两种方案，一：将Tornado程序单独执行N份，每一个实例单独监听一个端口，然后使用Nginx实现负载均衡。二：使用Tornado提供的多进程，该模块实现在process.py(最简单的版本为v2.1.0)，实现原理为开启一个主进程，开启N个工作进程，主进程主要负责这些工作进程的重启工作(比如某进程挂掉了，那么会重新启动一个，维持总进程数量)。没一个工作进程都有一个主循环，它们均分处理http请求</p><h3 id="gen-sleep"><a href="#gen-sleep" class="headerlink" title="gen.sleep"></a>gen.sleep</h3><p>等待N秒钟，这个功能直到4.1版本才被加入，还是挺奇怪的。实现原理就是新建一个Future对象，同时添加回调到主循环，设置N秒后将Future对象设置为任意一个值。</p><h3 id="gen-run-on-executer"><a href="#gen-run-on-executer" class="headerlink" title="gen.run_on_executer"></a>gen.run_on_executer</h3><p>使用单独的线程来完成阻塞的任务。同时能够使用yield异步接收到返回的值。实现原理主要依靠concurrent.future模块，concurrent.future.submit会返回一个Future对象。yield接收到这个对象控制权转移。当线程内容执行完毕后会设置Future的值。yield被恢复</p><h3 id="run-sync"><a href="#run-sync" class="headerlink" title="run_sync"></a>run_sync</h3><p>经常用于调试。比如写了一个异步函数，要验证一下正确性。那么就不需要使用IOLoop.instance().start()让它无法终止。假设a函数被coroutine装饰，那么a()返回一个Future对象，此时执行IOLoop.instance().start()。整个主循环就会被执行。而run_sync仅仅只是在中间做了一件事情。对于一个Future对象，拥有add_done_callback函数，表示该Future完成后做某事，因此它只是添加了一个回调让主循环停止</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tornado系列基本介绍的差不多了，本篇介绍一些零散的东西。有了前面的知识，本篇会讲的比较粗略&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之queue</title>
    <link href="https://www.zoulei.net/2018/03/19/tornado_queue/"/>
    <id>https://www.zoulei.net/2018/03/19/tornado_queue/</id>
    <published>2018-03-19T06:24:05.000Z</published>
    <updated>2018-03-20T06:44:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍完StackContext、gen.engine、gen.coroutine之后Tornado3.0以前的核心内容基本已经完结了。本篇介绍一下gen.coroutine中Future的应用，在tornado中生成一个队列的数据结构。如果经常写web的情况，单单只处理用户的输入给出输出，那么要求不会太多，也不会用到队列。可是如果你去写一个爬虫，肯定需要限速啥的，此时队列就是一个很有用的东西，很容易实现生产者消费者模型。Tornado官方的demo中也有一个[爬虫代码(<a href="https://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py)]演示如何使用队列(本篇基于v5.0.0)" target="_blank" rel="noopener">https://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py)]演示如何使用队列(本篇基于v5.0.0)</a></p><a id="more"></a><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解Queue模块给出的例子就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"><span class="keyword">from</span> tornado.queues <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(maxsize=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = <span class="keyword">yield</span> q.get()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">'Doing work on %s'</span> % item)</span><br><span class="line">            <span class="keyword">yield</span> gen.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> q.put(item)</span><br><span class="line">        print(<span class="string">'Put %s'</span> % item)</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Start consumer without waiting (since it never finishes).</span></span><br><span class="line">    IOLoop.current().spawn_callback(consumer)</span><br><span class="line">    <span class="keyword">yield</span> producer()  <span class="comment"># Wait for producer to put all tasks.</span></span><br><span class="line">    <span class="keyword">yield</span> q.join()  <span class="comment"># Wait for consumer to finish all tasks.</span></span><br><span class="line">    print(<span class="string">'Done'</span>)</span><br><span class="line"></span><br><span class="line">IOLoop.current().run_sync(main)</span><br></pre></td></tr></table></figure><h3 id="控制权转移"><a href="#控制权转移" class="headerlink" title="控制权转移"></a>控制权转移</h3><p>在python自带模块里面的queue是给多线程使用的.意味着当队列里面没有元素的时候会阻塞主线程。阻塞主线程这种操作在协程里面当然是不允许的。协程里面需要的是当某事需要进行等待的时候主动让出控制权限，让其他的事件执行。具体来说，如何让出控制权呢。理解上一篇的coroutine就可以发现。<span style="color:red"><strong>yield 一个暂时还没有结果的Future就会导致控制权转移，等Future结果到来yield就会被恢复</strong></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.gen <span class="keyword">import</span> coroutine,sleep</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xx</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">()</span>:</span></span><br><span class="line">    xx()</span><br><span class="line">    print(<span class="string">"x"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x()</span></span><br><span class="line"><span class="comment"># IOLoop.instance().start()</span></span><br><span class="line">IOLoop.instance().run_sync(x)</span><br></pre></td></tr></table></figure><p>观察这个例子。正常的写法是<code>yield xx()</code>，然后会调用xx(),过一秒之后打印xx再打印x。如果直接使用xx，其实这段代码也没有什么问题。xx返回了一个Future对象。因为没有使用yield，所以它不必等待xx函数执行完再进行下面的操作。xx返回的Future已经开始了运行(它并不会什么都不发生)，它依旧在一秒钟之后被执行然后打印xx。</p><h3 id="Queue的实现思路"><a href="#Queue的实现思路" class="headerlink" title="Queue的实现思路"></a>Queue的实现思路</h3><p>核心思路是</p><ul><li>get、put操作均返回Future对象</li><li>没有被设置值的Future执行yield会有阻塞效果</li></ul><p>创建三个队列分别为正常队列_queue、未来get队列_getters，未来put队列_putters。<br>执行get操作的时候创建一个Future对象。优先从_putters里面获取.获得的是一个值和一个Future对象，执行Future.set_result。此时代表put被阻塞，执行set_result取消阻塞。再考虑从_queue里面取，代表正常取值。如果都没有则放入_getters队列(此时因为Futures没有值，取值的地方被阻塞)。</p><p>执行put就是相反的操作，优先从_getters里面取(有值则执行Future.set_result，取消获取过程的阻塞)。再检查正常队列的元素是否超过最大值。否则加入未来队列</p><p>那么队列还有task_done和join操作，前者每一个任务执行完毕都会被调用表示该任务完成，后者表示等待加入到队列的所有任务都完成，否则阻塞。顺便说一下tornado的锁是怎么实现的</p><p>依旧是依靠没有被设置值的Future被yield会造成阻塞。该Future被设置值则会继续执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f = Future()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.f.done():</span><br><span class="line">            self.f.set_result(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.f.done():</span><br><span class="line">            self.f = Future()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.f</span><br></pre></td></tr></table></figure><p>注意。这个地方调用set和clear都是不带yield的，只有当最后调用wait才使用yield。</p><h3 id="Queue的实现"><a href="#Queue的实现" class="headerlink" title="Queue的实现"></a>Queue的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        self.max_size = maxsize <span class="keyword">or</span> <span class="number">2</span> &lt;&lt; <span class="number">16</span></span><br><span class="line">        self._queue = collections.deque([])</span><br><span class="line">        self._getters = collections.deque([]) </span><br><span class="line">        self._putters = collections.deque([]) </span><br><span class="line">        self._unfinished_tasks = <span class="number">0</span></span><br><span class="line">        self._finished = Event()</span><br><span class="line">        self._finished.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        f = Future()</span><br><span class="line">        <span class="keyword">if</span> len(self._queue) &gt; <span class="number">0</span>:</span><br><span class="line">            value = self._queue.popleft()</span><br><span class="line">            f.set_result(value)</span><br><span class="line">        <span class="keyword">elif</span> len(self._putters) &gt; <span class="number">0</span>:</span><br><span class="line">            item, future = self._putters.popleft()</span><br><span class="line">            f.set_result(item)</span><br><span class="line">            future.set_result(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._getters.append(f)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._unfinished_tasks += <span class="number">1</span></span><br><span class="line">        self._finished.clear()</span><br><span class="line"></span><br><span class="line">        f = Future()</span><br><span class="line">        <span class="keyword">if</span>  len(self._getters) &gt; <span class="number">0</span>:</span><br><span class="line">            future = self._getters.pop()</span><br><span class="line">            f.set_result(<span class="literal">None</span>)</span><br><span class="line">            future.set_result(value)</span><br><span class="line">        <span class="keyword">elif</span> len(self._queue) &lt; self.max_size:</span><br><span class="line">            self._queue.append(value)</span><br><span class="line">            f.set_result(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._putters.append((value, f))</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">task_done</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._unfinished_tasks -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._unfinished_tasks == <span class="number">0</span>:</span><br><span class="line">            self._finished.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._finished.wait()</span><br></pre></td></tr></table></figure><p>源码做了更多的适配将_get和_put独立出来。然后使用优先级队列，先进后出队列满足不同的出入顺序要求</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍完StackContext、gen.engine、gen.coroutine之后Tornado3.0以前的核心内容基本已经完结了。本篇介绍一下gen.coroutine中Future的应用，在tornado中生成一个队列的数据结构。如果经常写web的情况，单单只处理用户的输入给出输出，那么要求不会太多，也不会用到队列。可是如果你去写一个爬虫，肯定需要限速啥的，此时队列就是一个很有用的东西，很容易实现生产者消费者模型。Tornado官方的demo中也有一个[爬虫代码(&lt;a href=&quot;https://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py)]演示如何使用队列(本篇基于v5.0.0)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py)]演示如何使用队列(本篇基于v5.0.0)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之gen.coroutine</title>
    <link href="https://www.zoulei.net/2018/03/17/Tornado_gen_coroutine/"/>
    <id>https://www.zoulei.net/2018/03/17/Tornado_gen_coroutine/</id>
    <published>2018-03-17T07:54:43.000Z</published>
    <updated>2018-03-17T11:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>2013年Tornado3.0版本。gen.coroutine上线，直到今天它依旧是目前Tornado中使用最为广泛的装饰器。同时它也是接替gen.engine的存在。它基本去掉了gen.Task的套路。相对gen.engine而言。它只需要gen.coroutine就够了，写法上更为美观</p><a id="more"></a><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>需要实现的目标是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenAsyncHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @asynchronous</span></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_client = AsyncHTTPClient()</span><br><span class="line">        response = <span class="keyword">yield</span> http_client.fetch(<span class="string">"http://example.com"</span>)</span><br><span class="line">        do_something_with_response(response)</span><br><span class="line">        self.render(<span class="string">"template.html"</span>)</span><br></pre></td></tr></table></figure><p>在这里，它并不是gen.engine时代的作风。在上一篇中可以看到，添加gen.engine的时候没有改动过任何已有代码。可是在gen.coroutine时代。它去掉了gen.Task。于此同时，改动的是http_client.fetch。</p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Task这个名词不够炫酷，然后它新增了一个类叫做Future。<code>未来</code>这个词看起来就很有科技感。是的，它表述的是，在未来某一刻，这个对象会得到结果，当然这背后的一切仍然是换汤不换药由回调操作来完成。看一下Future都有啥</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._val = <span class="literal">None</span></span><br><span class="line">        self._callback = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._val = value</span><br><span class="line">        <span class="keyword">for</span> callback <span class="keyword">in</span> self._callback:</span><br><span class="line">            callback(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">        self._callback.add(callback)</span><br></pre></td></tr></table></figure><p>一个Future类可以如此的简单。它只是提供了一个_val的存储场所，另外当使用set_result设置值的时候会顺便将加入到该对象的回调进行调用。提供了添加回调的函数add_done_callback</p><p>回忆gen.Task，它做的事情是对包含callback参数的函数A进行包装，当函数A的callback被调用的时候，实际上调用的是Runner.result_callback。这种做法的缺点呢就是在RequestHandler.get里面需要出现gen.Task。现在我们不希望它出现。我们完全可以改变这一逻辑。因为http_client.fetch肯定是会调用callback的。可以想象它最终的语句是<code>callback(result)</code>。<span style="color:red"><strong>既然框架希望让用户不必输入gen.Task，那么可以选择在http_client.fetch中加入Future,设置它的callback为Future.set_result</strong></span>。随便举例如下。假设有一个函数是add_one,原本逻辑如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(ret, callback)</span>:</span></span><br><span class="line">    ret += <span class="number">1</span></span><br><span class="line">    IOLoop.instance().add_callback(<span class="keyword">lambda</span>: callback(ret))</span><br></pre></td></tr></table></figure><p>改写成这个样子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(ret)</span>:</span></span><br><span class="line">    future = Future()</span><br><span class="line">    ret += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> future.set_result(ret)</span><br><span class="line">    IOLoop.instance().add_callback(callback)</span><br><span class="line">    <span class="keyword">return</span> future</span><br></pre></td></tr></table></figure><p>虽然这个地方最终被future.set_result执行。可是Future提供了add_done_callback接口，<span style="color:red"><strong>意味着允许我们自己的callback能够在add_one执行完毕后被future.set_result所触发</strong></span>，同时注意add_one返回的是一个future对象</p><h3 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h3><p>假如我们类比gen.engine去实现它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, g)</span>:</span></span><br><span class="line">        self.g = g</span><br><span class="line">        <span class="comment"># 得到一个Future</span></span><br><span class="line">        self.yielded = self.g.send(<span class="literal">None</span>)</span><br><span class="line">        self.yielded.add_done_callback(self.future_callback)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">future_callback</span><span class="params">(self, future)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.result_callback(future.result())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result_callback</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.result = value</span><br><span class="line">        self.run()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.yielded = self.g.send(self.yielded.result())</span><br><span class="line">            self.yielded.add_done_callback(self.future_callback)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Runner(result)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>是不是几乎一模一样，还可以正常运行。但是这里有一个极大的缺陷。它无法被嵌套使用，什么意思呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.gen <span class="keyword">import</span> coroutine</span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> b()</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>同时在gen.engine时代, 这种调用方式也是不被允许的，可是gen.coroutine实现了这种方式的调用。主要原理是我们规定，所有yield右边的值全部是Future对象，对一个Future对象处理完毕后再处理下一个。那么就要修改coroutine了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        f = Future()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">final_callback</span><span class="params">(value)</span>:</span></span><br><span class="line">            f.set_result(value)</span><br><span class="line">        Runner(func, final_callback)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>对于每一个子coroutine，它们都会生成一个Runner对象(此时Runner已经将生成器进行初始化，执行send(None)，并add_done_callback)，只是它们返回的并不是Runner，而是Future.在Future被执行set_result操作的时候子coroutine的yield往下走。直到遇到StopIteration异常，此时final_callback函数被调用，它被父coroutine所接受，触发父coroutine的yield往下走。。。。堪称完美。。。。</p><p>就这样，它实现了和yield from差不多的逻辑。父生成器调用子生成器，简直六的飞起不服不行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen, final_callback)</span>:</span></span><br><span class="line">        self.final_callback = final_callback</span><br><span class="line">        self.gen = gen()</span><br><span class="line">        self.yielded = self.gen.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 会回调future对象</span></span><br><span class="line">        self.yielded.add_done_callback(self.future_callback)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">future_callback</span><span class="params">(self, future)</span>:</span></span><br><span class="line">        self.run()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.yielded = self.gen.send(self.yielded.result())</span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">            self.final_callback(e.value)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.yielded.add_done_callback(self.future_callback)</span><br></pre></td></tr></table></figure><p>说实话，还是感觉有点绕，希望你能够看明白</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>和上面的简易写法不同。Tornado源码的实现要复杂一些，因为它要考虑更复杂的需求</p><ul><li>兼容性，它不能因为有了Future对象后就完全不顾以前gen.Task的写法</li><li>它同样需要实现一次yield多个Future的需求</li></ul><p>所以，它另外生成了一个和gen.Task类似的对象YieldFuture。和gen.Task拥有的成员对象一样<br><code>start</code>、<code>is_ready</code>、<code>get_result</code>。同时由于Future在Tornado中应用是如此的普遍。IOLoop新增了一个方法add_future函数(还有一方面就是前面提到的callback异常问题)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_future</span><span class="params">(self, future, callback)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(future, Future)</span><br><span class="line">    callback = stack_context.wrap(callback)</span><br><span class="line">    future.add_done_callback(</span><br><span class="line">        <span class="keyword">lambda</span> future: self.add_callback(callback, future))</span><br></pre></td></tr></table></figure><p>在使用的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.runner = runner</span><br><span class="line">self.key = object()</span><br><span class="line">runner.register_callback(self.key)</span><br><span class="line">self.io_loop.add_future(self.future, runner.result_callback(self.key))</span><br></pre></td></tr></table></figure><p>实际上如果不考虑异常情况，和它是等价的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future.add_done_callback(self.future_callback)</span><br></pre></td></tr></table></figure><p>和gen.engine一样。coroutine也会遇到这种问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response1, response2 = <span class="keyword">yield</span> [http_client.fetch(url1),</span><br><span class="line">                                  http_client.fetch(url2)]</span><br><span class="line">    response_dict = <span class="keyword">yield</span> dict(response3=http_client.fetch(url3),</span><br><span class="line">                               response4=http_client.fetch(url4))</span><br><span class="line">    response3 = response_dict[<span class="string">'response3'</span>]</span><br><span class="line">    response4 = response_dict[<span class="string">'response4'</span>]</span><br></pre></td></tr></table></figure><p>一次yield 多个Future对象。那么解决办法也是和engine差不多的。当发现send(value)返回值是一个list或者dict对象时。它会使用Multi进行封装。在被回调的时候检查Multi对象的is_ready状态。仅仅当都得到结果才算完成</p><p>另外在Tornado3.1版本HandlerRequest._execute进行改动。被coroutine装饰的函数不需要再被asynchronous所装饰。至此这个从1.0.0跨越到3.1.0版本的装饰器的生命走到了尽头。然而依旧很多人不管不顾硬是要加上这个装饰器才安心</p><h3 id="应用一"><a href="#应用一" class="headerlink" title="应用一"></a>应用一</h3><p>可以说自此之后Tornado只存在Future配合yield、coroutine的操作。你从头新建一个Tornado的异步库。用户调用最后必定是返回给用户Future对象。这里我印象比较深的就是用Future实现了celery结果的异步获取。说是异步。实质上就是轮询。<a href="https://github.com/mayflaver/tornado-celery/blob/master/torncelery.py" target="_blank" rel="noopener">代码在这里</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.concurrent <span class="keyword">import</span> TracebackFuture</span><br><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async</span><span class="params">(task, *args, **kwargs)</span>:</span></span><br><span class="line">    future = TracebackFuture()</span><br><span class="line">    callback = kwargs.pop(<span class="string">"callback"</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> callback:</span><br><span class="line">        IOLoop.instance().add_future(future,</span><br><span class="line">                                     <span class="keyword">lambda</span> future: callback(future.result()))</span><br><span class="line">    result = task.delay(*args, **kwargs)</span><br><span class="line">    IOLoop.instance().add_callback(_on_result, result, future)</span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_on_result</span><span class="params">(result, future)</span>:</span></span><br><span class="line">    <span class="comment"># if result is not ready, add callback function to next loop,</span></span><br><span class="line">    <span class="keyword">if</span> result.ready():</span><br><span class="line">        future.set_result(result.result)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        IOLoop.instance().add_callback(_on_result, result, future)</span><br></pre></td></tr></table></figure><p>celery执行task.delay立刻返回了result对象。然后将resule和future加入回调，查询resule.ready确定任务是否完成。一旦完成则调用future.set_resule。Future对象设置值之后yield就会继续往下走。完美<del>~</del>，否则它会再次循环，直到得到结果为止。可以看到它这种方式还是相当的粗暴的，因为一旦没有结果就会不停的循环。可是这种方式胜在代码简单</p><h3 id="应用二"><a href="#应用二" class="headerlink" title="应用二"></a>应用二</h3><p>再来一个简单的例子，gen.sleep() 比较没有想到，它会是4.1.0版本才加入的，实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(duration)</span>:</span></span><br><span class="line">    f = Future()</span><br><span class="line">    IOLoop.current().call_later(duration, <span class="keyword">lambda</span>: f.set_result(<span class="literal">None</span>))</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><p>(⊙v⊙)嗯，意不意外。这应该是我在Tornado里面发现最简单的代码了，创建一个Future对象，然后在IOLoop的_timeout列表中加入一个到期执行回调，设置Future的值。至此yield继续往下走~~</p><h3 id="简易代码"><a href="#简易代码" class="headerlink" title="简易代码"></a>简易代码</h3><p>可以用下面这段简易代码观察一下coroutine的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._val = <span class="literal">None</span></span><br><span class="line">        self._callback = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._val = value</span><br><span class="line">        <span class="keyword">for</span> callback <span class="keyword">in</span> self._callback:</span><br><span class="line">            callback(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span><span class="params">(self, callback)</span>:</span></span><br><span class="line">        self._callback.add(callback)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen, final_callback)</span>:</span></span><br><span class="line">        self.final_callback = final_callback</span><br><span class="line">        self.gen = gen()</span><br><span class="line">        self.yielded = self.gen.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 会回调future对象</span></span><br><span class="line">        self.yielded.add_done_callback(self.future_callback)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">future_callback</span><span class="params">(self, future)</span>:</span></span><br><span class="line">        self.run()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.yielded = self.gen.send(self.yielded.result())</span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">            self.final_callback(e.value)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.yielded.add_done_callback(self.future_callback)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        f = Future()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">final_callback</span><span class="params">(value)</span>:</span></span><br><span class="line">            f.set_result(value)</span><br><span class="line">        Runner(func, final_callback)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">()</span>:</span></span><br><span class="line">    c = <span class="keyword">yield</span> haha1()</span><br><span class="line">    r = <span class="keyword">yield</span> add_one(<span class="number">1</span>)</span><br><span class="line">    b = <span class="keyword">yield</span> add_one(<span class="number">2</span>)</span><br><span class="line">    print(r, b, c)</span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha1</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="keyword">yield</span> add_one(<span class="number">1</span>)</span><br><span class="line">    b = <span class="keyword">yield</span> add_one(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> r + b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(ret)</span>:</span></span><br><span class="line">    f = Future()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future, result)</span>:</span></span><br><span class="line">        future.set_result(result)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().add_callback(partial(callback, f, ret + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">haha()</span><br><span class="line"></span><br><span class="line">tornado.ioloop.IOLoop().instance().start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2013年Tornado3.0版本。gen.coroutine上线，直到今天它依旧是目前Tornado中使用最为广泛的装饰器。同时它也是接替gen.engine的存在。它基本去掉了gen.Task的套路。相对gen.engine而言。它只需要gen.coroutine就够了，写法上更为美观&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之gen.engine</title>
    <link href="https://www.zoulei.net/2018/03/17/tornado_gen_engine/"/>
    <id>https://www.zoulei.net/2018/03/17/tornado_gen_engine/</id>
    <published>2018-03-17T04:13:51.000Z</published>
    <updated>2018-03-17T07:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado在2011年的2.1版本加入了gen.engine模块，该模块主要为了解决异步程序编写不够优雅的问题。力图让使用者离callback更远，这也是Tornado厉害的地方。本来内部各种事件处理，callback满天飞，可是在用户眼里，它那个class Handler(web.RequestHandler)下面get的写法和同步写法差不多嘛。和同步的写法一样，获得了更高的性能，我想这也是为什么Tornado能出彩的地方吧(本文代码基于v2.3.0)</p><a id="more"></a><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>主要起因就是不够优雅的callback,假设有一个需求，我们需要向第三方api请求数据，然后返回给客户端。此时写法是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @asynchronous</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_client = AsyncHTTPClient()</span><br><span class="line">        http_client.fetch(<span class="string">"http://example.com"</span>,</span><br><span class="line">                          callback=self.on_fetch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_fetch</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        do_something_with_response(response)</span><br><span class="line">        self.render(<span class="string">"template.html"</span>)</span><br></pre></td></tr></table></figure><p>这种写法会有什么问题？假设我现在需要对返回的数据进行处理，那么我必须要写到回调函数里面。另外，如果在回调函数里面继续要使用其他的回调逻辑，那么肯定也是需要继续在回调函数里面编写，最后就形成了著名的回调地狱。明显这种方式是很让人恶心的，Tornado在这一版本上改动成了这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenAsyncHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @asynchronous</span></span><br><span class="line"><span class="meta">    @gen.engine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_client = AsyncHTTPClient()</span><br><span class="line">        response = <span class="keyword">yield</span> gen.Task(http_client.fetch, <span class="string">"http://example.com"</span>)</span><br><span class="line">        do_something_with_response(response)</span><br><span class="line">        self.render(<span class="string">"template.html"</span>)</span><br></pre></td></tr></table></figure><p>这样就好很多了嘛，更符合人们同步编写代码的直觉。观察改变有三个地方</p><ul><li>整个函数添加了gen.engine装饰器</li><li>添加了yield语句</li><li>http_client.fetch被gen.Task封装起来</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>先说一下这个地方的改动。<span style="color:red"><strong>v2.1.0版本并没有改动任何已有的代码，仅仅是添加了gen.py模块</strong></span>，<a href="https://github.com/tornadoweb/tornado/commit/e4ead597956457aada766b09d624a3d9f7b888d9" target="_blank" rel="noopener">该commitz在这里</a>。我觉得这算是比较厉害的地方了</p><p>回顾这里用到的知识点，毫无疑问，Tornado里面最核心的yield终于在这个版本上场了。原来http_client.fetch是需要传入一个callback回调函数进行回调的。那么被gen.Task封装之后，这个回调函数不存在了，可以认为这里是gen.Task自己内部传入了一个回调函数。而只要是函数用到了yield关键字，那么它就是一个生成器对象。生成器对象有两个基本的特性,执行get()并不会立即开始执行、执行send后遇到yield会被暂停</p><p>考虑到上面说的gen.py是一个很独立的函数，并没有改动任何已有的代码。那么gen.engine装饰器肯定对get()执行了初始化并执行了send(None)让它开始运行起来。可是遇到yield会停止。同时上面的语义是再次恢复后以前http_client.fetch传递给回调函数的值需要赋值给response变量，生成器的send方法是可以做到这一点的，这里可能并不太好理解。</p><p>现在对功能进行划分</p><ul><li>gen.engine装饰器的主要作用是让生成器运行起来(调用后再执行send(None))</li><li>gen.Task的作用是将http_client.fetch 封装成Task对象，并传入一个回调，该回调使得send被再次调用</li><li>Runner 这是一个对用户无感知的类。连接gen.engine和gen.Task</li></ul><p>基础实现代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen)</span>:</span></span><br><span class="line">        self.gen = gen()</span><br><span class="line">        self.yielded = self.gen.send(<span class="literal">None</span>)</span><br><span class="line">        self.yielded.start(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result_callback</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.result = value</span><br><span class="line">        self.run()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.yielded = self.gen.send(self.result)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.yielded.start(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self, runner)</span>:</span></span><br><span class="line">        self.func(callback=runner.result_callback)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">engine</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Runner(func)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><p>可以看到gen.engine是一个非常简单的装饰器，将生成器传递给Runner并返回。在Runner里面它被执行send(None)。这个时候send(None)返回的是Task(http_client.fetch, “<a href="http://example.com&quot;)。" target="_blank" rel="noopener">http://example.com&quot;)。</a></p><p>Task的封装也可以很简单，它仅仅存在一个start。传入runner并将http_client.fetch的回调设置为runner.result_callback</p><p>Runner呢，它负责了让生成器开始运行，并拥有result_callback函数，在callback里面，它调用了自身的run函数。在run里面再次调用send，此时send的值是http_client.fetch返回的值。如果没有触发StopIteration异常则表明再一次返回了Task对象。重复过程执行Task.start</p><p>这样它很巧妙的将callback驱动变成了yield驱动，要知道Task必定会调用callback函数，当callback被调用的时候就等同于赋值给了yield左边的变量</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面的代码并没有考虑异常情况，另外可能存在这种情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response1, response2 = <span class="keyword">yield</span> [gen.Task(http_client.fetch, url1),</span><br><span class="line">                                  gen.Task(http_client.fetch, url2)]</span><br></pre></td></tr></table></figure><p>我们希望两个Task同时执行，而不是等一个得到结果后，再去请求第二个结果。因此需要稍微复杂一些。我们给每一个Task标记一个独立的key，并修改Task的callback部分，让回调的时候知道属于哪一个Task对象。于此同时Task多了两个方法<code>get_result</code>和<code>is_ready</code>方法。在首次得到yielded对象后。如果判断是list对象，那么对该list再次进行封装得到Multi对象,它的is_ready会检查多个Task是不是都得到结果。在被执行回调后执行到Runner.run(),会先检查是否满足is_ready。如果不满足说明还有的Task并没有返回结果，直接返回。等待下一次被回调。均满足才得到全部结果执行send操作</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码非常独立，还是很有看头很精彩的。被gen.engine修饰一次意味着存在一个Runner，这个Runner配合着多个Task，主要可以看做Task和Runner互相调用的过程。Task每被回调一次则Runner.run()被调用一次，执行一次send操作，yield往下走一次返回下一个Task对象。另外这段代码里面还提供了很坑爹的Callback、Wait控制方式。思维有点奇葩，一般人不太会去用，实现倒是并不复杂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tornado在2011年的2.1版本加入了gen.engine模块，该模块主要为了解决异步程序编写不够优雅的问题。力图让使用者离callback更远，这也是Tornado厉害的地方。本来内部各种事件处理，callback满天飞，可是在用户眼里，它那个class Handler(web.RequestHandler)下面get的写法和同步写法差不多嘛。和同步的写法一样，获得了更高的性能，我想这也是为什么Tornado能出彩的地方吧(本文代码基于v2.3.0)&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之StackContext</title>
    <link href="https://www.zoulei.net/2018/03/16/Tornado_StackContext/"/>
    <id>https://www.zoulei.net/2018/03/16/Tornado_StackContext/</id>
    <published>2018-03-16T08:14:25.000Z</published>
    <updated>2018-03-17T04:01:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>yield这个关键字在2001年2.2版本的时候就出现了。2006加入yield.send功能。然而直到2006年2.5版本才看到使用在contextmanager上，tornado 2011年才用它实现了神奇的gen逻辑。令我没想到的是</p><ol><li>yield出现的这么早</li><li>yield厉害一点的应用(contentmanager)居然过了五年才加入到标准库。</li><li>tornado的1.0.0版根本和yield没有一毛钱关系</li><li>tornado最先引入yield居然并不是实现了gen</li></ol><p>yield最先在tornado里面展露头角是在<span style="color:red"><strong><a href="https://github.com/tornadoweb/tornado/commit/721e25d0acc68d751073261bec150ac12a9f88ab" target="_blank" rel="noopener">这个commit</a></strong></span>里面。大神就是大神，虽然这个代码仅仅只有几十行。可是我觉得思路很新奇，膜拜😀(代码基于v1.0.0和v1.1.0)</p><a id="more"></a><p>建议打开该commit，先看一看它做了什么事情。除去测试用例，它改动的地方可谓非常少了</p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>观察下面的代码(可以将tornado的源码在1.0.0版本和1.1.0版本切换发现不同，在1.0.0版本客户端无法得到响应，1.1.0版本客户端得到500错误)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @tornado.web.asynchronous</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        tornado.ioloop.IOLoop.instance().add_callback(self.callback)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self,*args)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Error"</span>)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application(handlers=[(<span class="string">'/'</span>, Index)])</span><br><span class="line">tornado.httpserver.HTTPServer(application).listen(<span class="number">8888</span>)</span><br><span class="line">tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p>这是一个异步的http响应。在接受到请求之后执行get函数体，最终它将self.callback加入到IOLoop循环列表，get函数结束。因为存在asynchronous装饰器，所以并没有主动调用self.finish()。待IOLoop执行self.callback回调时。此时并函数内部触发了异常。<span style="color:red"><strong>但是这个异常已经和get函数没有任何关系，因此get函数无法捕获到这个异常</strong></span><br>对比一下get函数体自身触发异常。由web.RequestHandler._execute调用get函数。此时它将捕获异常并调用self._handle_request_exception.最简流程如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self, transforms, *args, **kwargs)</span>:</span></span><br><span class="line">    self._transforms = transforms</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        getattr(self, self.request.method.lower())(*args, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> self._auto_finish <span class="keyword">and</span> <span class="keyword">not</span> self._finished:</span><br><span class="line">            self.finish()</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        self._handle_request_exception(e)</span><br></pre></td></tr></table></figure><p>self._handler_request_exception的流程也比较简单输出异常调用栈。返回客户端500错误，该http流程结束</p><p>可是对于一个回调，它的异常由IOLoop捕获，然而可悲的是它捕获到异常却并不能确定是谁添加到IOLoop里面的，异常捕获之后是不是只用输出调用栈就好。所以需求出来了，对于凡是由get操作下面加入到IOLoop的回调，我们期待能和get的异常处理逻辑一致</p><h3 id="历史上这个问题是怎么处理的"><a href="#历史上这个问题是怎么处理的" class="headerlink" title="历史上这个问题是怎么处理的"></a>历史上这个问题是怎么处理的</h3><p>这肯定是一个非常常见的问题，当执行<code>ioloop.IOLoop.instance().add_callback</code>之后。callback函数触发的异常添加回调的函数无法感知。最容易想到的方法就是我们把callback整体加上异常捕捉逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self,*args)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">                ...</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                self._handle_request_exception(e)</span><br></pre></td></tr></table></figure><p>但是这么恶心的方法明显是不可取的。意味着我们每写一个回调逻辑都需要在外部加上try..except。在1.0.0版本提供了一个装饰器函数提供类似的功能async_callback,所以上面的写法只需要将<code>tornado.ioloop.IOLoop.instance().add_callback(self.callback)</code>变更成<code>tornado.ioloop.IOLoop.instance().add_callback(self.async_callback(self.callback))</code>就可以了。虽然方法很不好，可是临时解决了问题，在1.1.0版本就引入了StackContext逻辑，解决了这个问题</p><h3 id="预备知识Yield"><a href="#预备知识Yield" class="headerlink" title="预备知识Yield"></a>预备知识Yield</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fn</span><span class="params">()</span>:</span></span><br><span class="line">    result = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">"result of yueld: "</span>+result)</span><br><span class="line">    result2 = <span class="keyword">yield</span>  <span class="number">2</span></span><br><span class="line">    print(<span class="string">"result of 2nd yield: "</span> + result2)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'we are done'</span></span><br><span class="line"></span><br><span class="line">caller = gen_fn()</span><br><span class="line">x = caller.send(<span class="literal">None</span>)</span><br><span class="line">print(x)</span><br><span class="line">y = caller.send(<span class="string">'joe'</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    caller.send(<span class="string">"bob"</span>)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><ol><li>对于一个生成器来说，调用它(gen())并不会立即被执行。只是生成了一个生成器对象</li><li>nex(g)等同于g.send(None)。所以对于生成器只需要掌握send函数就可以了</li><li>send(value)返回的是yield右边的值，同时value赋值给yield左边的对象，<span style="color:red"><strong>千万不要被第一次的send(None)误导，认为经过第一次send(None)后result的值为None</strong></span>,你可以在心目中将没一个yield划上竖线，运行到那里就返回，然后下一次send的值被赋值给yield左边</li><li>上例中<code>we are done</code>没有被打印，因为不断的被send后生成器会触发StopIteration异常。最终被except StopIteration所捕获。可是他并没有将捕获的值输出，因而没有被显示处理。同时python2不允许在生成器执行return，所以在tornado中经常看到raise gen.Return(value)这种写法，它实质就是触发StopIteration异常，然后被except捕获后得到值，完成传递过程，到了python3语法就直接允许执行return了</li></ol><h3 id="预备知识-with"><a href="#预备知识-with" class="headerlink" title="预备知识 with"></a>预备知识 with</h3><p>python有很多魔术方法(可以参考<a href="https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html" target="_blank" rel="noopener">这篇文章</a>)。其中如果一个类存在<code>__enter__</code>和<code>__exit__</code>方法。那么当使用with语句之后。会执行<code>__enter__</code>后得到对象返回给<code>with as</code>后面的变量。在退出的时候执行<code>__exit__</code>方法，最常见的就是我们使用<code>with open() as f</code>去打开一个文件了，处理完成后自动关闭文件，避免了内存泄漏。仔细想一下，其实用装饰器是很容易实现的。可是with语句还有以一个很大的优点，Python的编码是基于缩进来决定代码块的，装饰器是作用在函数上，而with是当跳出它的缩进则执行<code>__exit__</code>(可能描述的不太好)，很多情况下with要比装饰器的写法优美很多。</p><p>将with和yield联合起来使用还真的是挺神奇的。from contextlib import contextmanager，该模块将with语句做到了装饰器的效果。比如计算一个with语句下面的执行时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">()</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">"elapsed time: &#123;&#125;"</span>.format(time.time() - start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> timeit():</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>作为不明白它实现的人，也能够很容易看出来。yield将timeit划分为了两部分。前面的相当于执行<code>__enter__</code>动作，后面的相当于执行<code>__exit__</code>动作。</p><p>想象一下它的内部contextmanager装饰器是如何实现的。首先被装饰的函数timeit是一个生成器。因此，在执行<code>__enter__</code>的时候只需要执行send(None)操作就能到达yield的右边并暂停，再<code>__exit__</code>的时候再次执行send(None)，此时执行到了finally语句并触发StopIteration异常，流程结束。整个过程可以这样认为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contextmanager</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        g = func(*args,**kwargs)</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">w</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">                g.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    g.send(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">except</span> Exception:</span><br><span class="line">                    print(<span class="string">"4"</span>)</span><br><span class="line">        <span class="keyword">return</span> w()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"1"</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"E"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> log():</span><br><span class="line">    print(<span class="string">"2"</span>)</span><br></pre></td></tr></table></figure><p>是否还是感觉相对比较简单呢</p><h3 id="StackContext的实现"><a href="#StackContext的实现" class="headerlink" title="StackContext的实现"></a>StackContext的实现</h3><p>在起因部分，解释了callback中会存在的问题(期待RequestHandler.get里面所有相关内容发生错误都会导致返回500错误给客户端)。1.0版本的解决方案就是给每个回调函数套上一个装饰器。触发错误的时候就可以返回500了，感觉不太好讲述这段天才般的代码了😕</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line">_state = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StackContext</span><span class="params">(context_factory)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _state</span><br><span class="line">    old_contexts = _state</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        _state = old_contexts + (context_factory,)</span><br><span class="line">        <span class="keyword">with</span> context_factory():</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        _state = old_contexts</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ErrorCapture</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> StackContext(ErrorCapture):</span><br><span class="line">    print(_state)</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"Error"</span>)</span><br><span class="line">print(_state)</span><br></pre></td></tr></table></figure><p>这个地方StackContext是一个工厂模式，它传入的参数context_factory也是一个被contextlib.contextmanager装饰的对象。在StackContext的内部它又执行了with语句来初始化我们的context_factory，emmm.这个其实和多层嵌套装饰器并没有太大的区别，它实现了什么效果呢，在调用with StackContext(context_factory)的时候将context_factory加入到老的里面。<span style="color:red"><strong>注意，当前的context_factory和1.0.0版本里面的async_callback效果是一样样的，在with的语句块下面，我们可以使用_state变量。当跳出with之后_state就被恢复到原来的样子</strong></span>。</p><p>那么我们该如何使用这个_state变量呢，注意到with语句进入的时候会加入context_factory，退出的时候会清除。这意味着在with下面的代码块里面我们可以安全的使用它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(callback, contexts)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> contextlib.nested(*[i() <span class="keyword">for</span> i <span class="keyword">in</span> contexts]):</span><br><span class="line">            callback()</span><br><span class="line">    contexts = _state</span><br><span class="line">    result = functools.partial(wrapped, fn, contexts)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这里，我们添加一个装饰器。在IOLoop中所有需要添加回调的地方均由wrap包装起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     def add_callback(self, callback):</span><br><span class="line">         &quot;&quot;&quot;Calls the given callback on the next I/O loop iteration.&quot;&quot;&quot;</span><br><span class="line">-        self._callbacks.add(callback)</span><br><span class="line">+        self._callbacks.add(stack_context.wrap(callback))</span><br><span class="line">         self._wake()</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>那么，在它被调用的时候实际执行的是wrapped函数，它会先调用with contextlib.nested(*[i() for i in contexts]).此步骤恢复了with StackContext时期加入的对象(即人们常说的上下文)。对于异常捕获来说，就是能够正确的捕获callback的异常并且返回500给客户端。另外，最开始的时候捕获RequestHandle.get的异常是在_execute套上try…except,将他变动为with StackContext就好了。这里应该谨记下面两点</p><ul><li>Tornado的运行是单线程的,with StackContext运行的过程中不可能存在别的步骤另外去改变了_state的值(这个值很重要)</li><li>StackContext是可以进行嵌套的</li></ul><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>当然以上只是为了表述原理讲解的最简代码，实际上源码中略有不同。首先考虑多线程的情况，在单线程中_state的改动是很显然的，执行<code>with StackContext</code>即允许改动。在多线程中就不太一样了。多线程中如果也执行了<code>with StackContext</code>操作，那么有可能造成_state被改动。因此，_state被继承自thread.local对象。那么不同线程内的修改是互相独立的<br>其次如果一个函数已经被wrapped包装，那么就不必要再次进行包装了(想象一下递归调用add_callback)。对于不存在的<code>with StackContext</code>也需要考虑，如果执行contextlib.nested的参数为空，无疑是会报错的。<br>其他有的独立的运行的模块不希望被已存在的_state影响，因此独立设置了NullContext</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NullContext</span><span class="params">()</span>:</span></span><br><span class="line">    old_contexts = _state.contexts</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        _state.contexts = ()</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        _state.contexts = old_contexts</span><br></pre></td></tr></table></figure><p>如果不希望被_state干扰，那么在前面加上<code>with StackContext(NullContext)</code>。_state即被置为空。显然add_callback传入的contexts为空。在它被执行的时候，也和with语句没什么事情了</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>我最开始看到的应用是这个,<a href="https://gist.github.com/Hackforid/7130a5d59463186e217e" target="_blank" rel="noopener">在Tornado里面使用Sqlalchemy</a>。默认Sqlalchemy存在sessionmaker一个工厂函数，它会确定如何生成一个session会话对象以供使用。默认的情况是使用线程id，这对于多线程环境非常非常方便。因为多线程web框架中每一个HTTP请求的处理都是在独立的线程内进行的，那么一个http处理生命周期对应一个sqlalchemy的session生命周期非常完美。<br>可是在Tornado这种单线程的框架中发生了变化，因为它不好确定每一个http的生命周期标识。StackContext给了我们方法，虽然起因是callback的异常处理，可是我们一样可以参照它的套路，在_execute执行期间写入变量，在单个http生命周期均可以访问变量，http完结后清除它。代码可以参考给出的gist链接</p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>下面给一个整篇文章的代码总结</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> contextlib <span class="keyword">import</span> nested</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> contextlib <span class="keyword">import</span> ExitStack, contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">    @contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(*contexts)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> ExitStack() <span class="keyword">as</span> stack:</span><br><span class="line">            <span class="keyword">for</span> ctx <span class="keyword">in</span> contexts:</span><br><span class="line">                stack.enter_context(ctx)</span><br><span class="line">            <span class="keyword">yield</span> contexts</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StackContext</span><span class="params">(context_factory)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _state</span><br><span class="line">    old_contexts = _state</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        _state = old_contexts + (context_factory,)</span><br><span class="line">        <span class="keyword">with</span> context_factory():</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        _state = old_contexts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ErrorCapture</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">_state = ()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(callback, contexts)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> nested(*[i() <span class="keyword">for</span> i <span class="keyword">in</span> contexts]):</span><br><span class="line">            callback()</span><br><span class="line"></span><br><span class="line">    contexts = _state</span><br><span class="line">    result = functools.partial(wrapped, fn, contexts)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"WTF"</span>)</span><br><span class="line">    print(get_current_request_id())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ThreadRequestContext</span><span class="params">(**data)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        g = data</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        g.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_request_id</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> g[<span class="string">'request_id'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">global_data = &#123;<span class="string">"request_id"</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">with</span> StackContext(functools.partial(ThreadRequestContext, **global_data)):</span><br><span class="line">    <span class="keyword">with</span> StackContext(ErrorCapture):</span><br><span class="line">        loop_list.append(wrap(call_back))</span><br><span class="line">        print(get_current_request_id())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> loop_list:</span><br><span class="line">    i()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yield这个关键字在2001年2.2版本的时候就出现了。2006加入yield.send功能。然而直到2006年2.5版本才看到使用在contextmanager上，tornado 2011年才用它实现了神奇的gen逻辑。令我没想到的是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;yield出现的这么早&lt;/li&gt;
&lt;li&gt;yield厉害一点的应用(contentmanager)居然过了五年才加入到标准库。&lt;/li&gt;
&lt;li&gt;tornado的1.0.0版根本和yield没有一毛钱关系&lt;/li&gt;
&lt;li&gt;tornado最先引入yield居然并不是实现了gen&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;yield最先在tornado里面展露头角是在&lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/tornadoweb/tornado/commit/721e25d0acc68d751073261bec150ac12a9f88ab&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个commit&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;里面。大神就是大神，虽然这个代码仅仅只有几十行。可是我觉得思路很新奇，膜拜😀(代码基于v1.0.0和v1.1.0)&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之WSGI</title>
    <link href="https://www.zoulei.net/2018/03/16/tornado_wsgi/"/>
    <id>https://www.zoulei.net/2018/03/16/tornado_wsgi/</id>
    <published>2018-03-16T03:28:02.000Z</published>
    <updated>2018-03-16T07:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>WSGI毕竟是Python社区官方认可的规范，可是这种规范在多线程多进程模式下实现很简单，不太适合单线程异步这种情况。鉴于此Tornado并没有按照这个框架去实现一个WSGI的web框架，可是它却提供了基本的兼容，1.允许Tornado的application对象转变成WSGI application。2. 允许WSGI application在tornado ioloop中执行，只是这一切都不是完美的，它仅仅提供了基本的兼容，效率和可用性得不到保证。因此个人还是感觉很鸡肋的</p><a id="more"></a><h3 id="回顾WSGI"><a href="#回顾WSGI" class="headerlink" title="回顾WSGI"></a>回顾WSGI</h3><p>wsgi由<a href="https://www.python.org/dev/peps/pep-0333/" target="_blank" rel="noopener">PEP333</a>开始，在<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP3333</a>得到增强。分为两部分，一部分为容器，另一部分为应用。应用的最简形式如下<br>传入environ基础环境字典(必须包含一些值)和回调函数，最终返回一个可迭代对线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</span><br></pre></td></tr></table></figure><p>对于容器。则是每接收到一个http请求则调用一次应用。这样的好处是容器和应用可以完全隔离，应用可以使用任意容器来执行</p><h3 id="Tornado-application转变成WSGI-application"><a href="#Tornado-application转变成WSGI-application" class="headerlink" title="Tornado application转变成WSGI application"></a>Tornado application转变成WSGI application</h3><p>实现效果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.wsgi</span><br><span class="line"><span class="keyword">import</span> wsgiref.simple_server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"Hello, world"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    application = tornado.wsgi.WSGIApplication([</span><br><span class="line">        (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line">    server = wsgiref.simple_server.make_server(<span class="string">''</span>, <span class="number">8888</span>, application)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure><p>在Tornado里面application接受一个参数调用，传入Requests对象。调用的结果是最终生成header以及handler._write_buffer对象(会触发iostream的写事件，最终由IOLoop触发socket写操作)。因此虽然它执行了RequestsHandler._execute操作，实际并没有发生socket发送操作，我们可以从handler对象取得完整的HTTP回复报文。然后调用start_response和返回一个可迭代对象<br>可以看到重点就是从WSGI server传递的environ字典里面重组出一个Request对象(模拟到和httpserver模块中的HTTPRequest对象一样)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIApplication</span><span class="params">(web.Application)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=<span class="string">""</span>, **settings)</span>:</span></span><br><span class="line">        web.Application.__init__(self, handlers, default_host, transforms=[],</span><br><span class="line">                                 wsgi=<span class="literal">True</span>, **settings)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        handler = web.Application.__call__(self, HTTPRequest(environ))</span><br><span class="line">        <span class="keyword">assert</span> handler._finished</span><br><span class="line">        status = str(handler._status_code) + <span class="string">" "</span> + \</span><br><span class="line">            httplib.responses[handler._status_code]</span><br><span class="line">        headers = handler._headers.items()</span><br><span class="line">        <span class="keyword">for</span> cookie_dict <span class="keyword">in</span> getattr(handler, <span class="string">"_new_cookies"</span>, []):</span><br><span class="line">            <span class="keyword">for</span> cookie <span class="keyword">in</span> cookie_dict.values():</span><br><span class="line">                headers.append((<span class="string">"Set-Cookie"</span>, cookie.OutputString(<span class="literal">None</span>)))</span><br><span class="line">        start_response(status, headers)</span><br><span class="line">        <span class="keyword">return</span> handler._write_buffer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPRequest</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>可以看到重点就是从environ里面构建出一个兼容httpserver的HTTPRequest对象。另外由于IOLoop在这种情况下不允许使用，所以依赖IOLoop的异步特性也就不存在了。而且连同多线程的特性也不在存在。所以只是一个玩具罢了吧</p><h3 id="在Tornado中运行WSGI-application"><a href="#在Tornado中运行WSGI-application" class="headerlink" title="在Tornado中运行WSGI application"></a>在Tornado中运行WSGI application</h3><p>上面的是将tornado的应用转变成WSGI兼容，然后让WSGI的容器去运行。这一个是反过来，让tornado作为容器去运行WSGI应用。实现这样的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    status = <span class="string">"200 OK"</span></span><br><span class="line">    response_headers = [(<span class="string">"Content-type"</span>, <span class="string">"text/plain"</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"Hello world!\n"</span>]</span><br><span class="line"></span><br><span class="line">container = tornado.wsgi.WSGIContainer(simple_app)</span><br><span class="line">http_server = tornado.httpserver.HTTPServer(container)</span><br><span class="line">http_server.listen(<span class="number">8888</span>)</span><br><span class="line">tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure><p>tornado.httpserver.HTTPServer会调用函数并传入一个Request对象。<span style="color:red"><strong>刚好和上面的过程相反</strong></span>。将Request对象分割为<code>environ</code>和<code>start_response</code>。直接贴1.0.0的原始代码吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIContainer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, wsgi_application)</span>:</span></span><br><span class="line">        self.wsgi_application = wsgi_application</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        response = []</span><br><span class="line">        <span class="comment"># 将status和headers放入字典中,后续调用则写入body</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">            data[<span class="string">"status"</span>] = status</span><br><span class="line">            data[<span class="string">"headers"</span>] = response_headers</span><br><span class="line">            <span class="keyword">return</span> response.append</span><br><span class="line">        <span class="comment"># wsgi app最终返回可迭代对象作为body</span></span><br><span class="line">        app_response = self.wsgi_application(</span><br><span class="line">            WSGIContainer.environ(request), start_response)</span><br><span class="line">        response.extend(app_response)</span><br><span class="line">        body = <span class="string">""</span>.join(response)</span><br><span class="line">        <span class="keyword">if</span> hasattr(app_response, <span class="string">"close"</span>):</span><br><span class="line">            app_response.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">raise</span> Exception(<span class="string">"WSGI app did not call start_response"</span>)</span><br><span class="line">        <span class="comment"># 组合成整个http报文</span></span><br><span class="line">        status_code = int(data[<span class="string">"status"</span>].split()[<span class="number">0</span>])</span><br><span class="line">        headers = data[<span class="string">"headers"</span>]</span><br><span class="line">        header_set = set(k.lower() <span class="keyword">for</span> (k,v) <span class="keyword">in</span> headers)</span><br><span class="line">        body = escape.utf8(body)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"content-length"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</span><br><span class="line">            headers.append((<span class="string">"Content-Length"</span>, str(len(body))))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"content-type"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</span><br><span class="line">            headers.append((<span class="string">"Content-Type"</span>, <span class="string">"text/html; charset=UTF-8"</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"server"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</span><br><span class="line">            headers.append((<span class="string">"Server"</span>, <span class="string">"TornadoServer/0.1"</span>))</span><br><span class="line"></span><br><span class="line">        parts = [<span class="string">"HTTP/1.1 "</span> + data[<span class="string">"status"</span>] + <span class="string">"\r\n"</span>]</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> headers:</span><br><span class="line">            parts.append(escape.utf8(key) + <span class="string">": "</span> + escape.utf8(value) + <span class="string">"\r\n"</span>)</span><br><span class="line">        parts.append(<span class="string">"\r\n"</span>)</span><br><span class="line">        parts.append(body)</span><br><span class="line">        <span class="comment"># 发送完成</span></span><br><span class="line">        request.write(<span class="string">""</span>.join(parts))</span><br><span class="line">        request.finish()</span><br><span class="line">        self._log(status_code, request)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">environ</span><span class="params">(request)</span>:</span></span><br><span class="line">        hostport = request.host.split(<span class="string">":"</span>)</span><br><span class="line">        <span class="keyword">if</span> len(hostport) == <span class="number">2</span>:</span><br><span class="line">            host = hostport[<span class="number">0</span>]</span><br><span class="line">            port = int(hostport[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            host = request.host</span><br><span class="line">            port = <span class="number">443</span> <span class="keyword">if</span> request.protocol == <span class="string">"https"</span> <span class="keyword">else</span> <span class="number">80</span></span><br><span class="line">        environ = &#123;</span><br><span class="line">            <span class="string">"REQUEST_METHOD"</span>: request.method,</span><br><span class="line">            <span class="string">"SCRIPT_NAME"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"PATH_INFO"</span>: request.path,</span><br><span class="line">            <span class="string">"QUERY_STRING"</span>: request.query,</span><br><span class="line">            <span class="string">"REMOTE_ADDR"</span>: request.remote_ip,</span><br><span class="line">            <span class="string">"SERVER_NAME"</span>: host,</span><br><span class="line">            <span class="string">"SERVER_PORT"</span>: port,</span><br><span class="line">            <span class="string">"SERVER_PROTOCOL"</span>: request.version,</span><br><span class="line">            <span class="string">"wsgi.version"</span>: (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="string">"wsgi.url_scheme"</span>: request.protocol,</span><br><span class="line">            <span class="string">"wsgi.input"</span>: cStringIO.StringIO(escape.utf8(request.body)),</span><br><span class="line">            <span class="string">"wsgi.errors"</span>: sys.stderr,</span><br><span class="line">            <span class="string">"wsgi.multithread"</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">"wsgi.multiprocess"</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">"wsgi.run_once"</span>: <span class="literal">False</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"Content-Type"</span> <span class="keyword">in</span> request.headers:</span><br><span class="line">            environ[<span class="string">"CONTENT_TYPE"</span>] = request.headers[<span class="string">"Content-Type"</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"Content-Length"</span> <span class="keyword">in</span> request.headers:</span><br><span class="line">            environ[<span class="string">"CONTENT_LENGTH"</span>] = request.headers[<span class="string">"Content-Length"</span>]</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> request.headers.iteritems():</span><br><span class="line">            environ[<span class="string">"HTTP_"</span> + key.replace(<span class="string">"-"</span>, <span class="string">"_"</span>).upper()] = value</span><br><span class="line">        <span class="keyword">return</span> environ</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_log</span><span class="params">(self, status_code, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> status_code &lt; <span class="number">400</span>:</span><br><span class="line">            log_method = logging.info</span><br><span class="line">        <span class="keyword">elif</span> status_code &lt; <span class="number">500</span>:</span><br><span class="line">            log_method = logging.warning</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            log_method = logging.error</span><br><span class="line">        request_time = <span class="number">1000.0</span> * request.request_time()</span><br><span class="line">        summary = request.method + <span class="string">" "</span> + request.uri + <span class="string">" ("</span> + \</span><br><span class="line">            request.remote_ip + <span class="string">")"</span></span><br><span class="line">        log_method(<span class="string">"%d %s %.2fms"</span>, status_code, summary, request_time)</span><br></pre></td></tr></table></figure><p>主要是将Requests转变成environ，传入给WSGI应用。最终根据应用的返回重组成一个HTTP回复报文字符串调用发送逻辑，流程完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WSGI毕竟是Python社区官方认可的规范，可是这种规范在多线程多进程模式下实现很简单，不太适合单线程异步这种情况。鉴于此Tornado并没有按照这个框架去实现一个WSGI的web框架，可是它却提供了基本的兼容，1.允许Tornado的application对象转变成WSGI application。2. 允许WSGI application在tornado ioloop中执行，只是这一切都不是完美的，它仅仅提供了基本的兼容，效率和可用性得不到保证。因此个人还是感觉很鸡肋的&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
</feed>
