<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邹雷</title>
  <subtitle>刨过的坑,自己慢慢来填</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zoulei.net/"/>
  <updated>2018-06-05T23:52:21.886Z</updated>
  <id>https://www.zoulei.net/</id>
  
  <author>
    <name>ficapy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第二章(程序结构)</title>
    <link href="https://www.zoulei.net/2018/06/05/the_go_programming_lang_usage_answer_2/"/>
    <id>https://www.zoulei.net/2018/06/05/the_go_programming_lang_usage_answer_2/</id>
    <published>2018-06-05T15:52:24.000Z</published>
    <updated>2018-06-05T23:52:21.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ul>
<li>名称</li>
<li>声明</li>
<li>变量</li>
<li>赋值</li>
<li>类型声明</li>
<li>包和文件</li>
<li>作用域</li>
</ul>
<a id="more"></a>
<h4 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2.1:"></a>练习2.1:</h4><p>添加类型、常量和函数到tempconv包中，处理以开尔文为单位(K)的温度值,0K=-273.15℃,变化1K和变化1℃是等价的</p>
<ul>
<li>很水的题</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> tempconv</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Kelvin <span class="keyword">float64</span></div><div class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k Kelvin)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%gK"</span>, k)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToK</span><span class="params">(c Celsius)</span> <span class="title">Kelvin</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> Kelvin(c - <span class="number">273.15</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">KToC</span><span class="params">(k Kelvin)</span> <span class="title">Celsius</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> Celsius(k + <span class="number">273.15</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="练习2-2"><a href="#练习2-2" class="headerlink" title="练习2.2"></a>练习2.2</h5><p>写一个类似于cf的通用的单位转换程序,从命令行参数或者标准输入(如果没有参数)获取数字,然后将每一个数字转换为以摄氏温度和华氏温度表示的温度,以英寸和米表示的长度单位,以磅和千克表示的重量单位,等等</p>
<ul>
<li>略，同很水</li>
</ul>
<h4 id="练习2-3"><a href="#练习2-3" class="headerlink" title="练习2.3:"></a>练习2.3:</h4><p>使用循环重写PopCount来代替单个表达式.对比两个版本的效率</p>
<ul>
<li>下面连续三道题都是经典面试题，求二进制数中1的个数，限定了正整数</li>
<li>书上的代码主要是预先计算,将64bit每8bit一组,8bit会有二的八次方种结果，共256种结果，将所有的结果都先计算出来(空间换时间)</li>
<li>预计算主要是这一步<code>pc[i] = pc[i/2] + byte(i&amp;1)</code>，注意此处的含义是除以二表示二进制数右移一位，后面表示最后一位是1还是0</li>
<li>代码中<code>[256]byte</code>换成<code>[256]int</code>，更好理解。可能这样写只是为了让人更加能搞明白byte和int的各种转换吧</li>
<li>注意这种预计算的执行效率是很高的</li>
</ul>
<p>书上给的代码还是比较扭曲的<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 2000000000	         0.32 ns/op</span></div><div class="line"><span class="keyword">package</span> tempconv</div><div class="line"></div><div class="line"><span class="keyword">var</span> pc [<span class="number">256</span>]<span class="keyword">byte</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</div><div class="line">		pc[i] = pc[i/<span class="number">2</span>] + <span class="keyword">byte</span>(i&amp;<span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">0</span>*<span class="number">8</span>))] +</div><div class="line">		pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">1</span>*<span class="number">8</span>))] +</div><div class="line">		pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">2</span>*<span class="number">8</span>))] +</div><div class="line">		pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">3</span>*<span class="number">8</span>))] +</div><div class="line">		pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">4</span>*<span class="number">8</span>))] +</div><div class="line">		pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">5</span>*<span class="number">8</span>))] +</div><div class="line">		pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">6</span>*<span class="number">8</span>))] +</div><div class="line">		pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">7</span>*<span class="number">8</span>))])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>改成循环</p>
<ul>
<li>惊不惊喜，意不意外，速度居然爆降低100倍</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount1</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	ret := <span class="keyword">byte</span>(<span class="number">0</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="keyword">uint8</span>(<span class="number">0</span>); i &lt; <span class="number">8</span>; i++ &#123;</div><div class="line">		ret += pc[<span class="keyword">byte</span>(x&gt;&gt;(i*<span class="number">8</span>))]</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(ret)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPopCount1</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	<span class="comment">// 100000000	        21.4 ns/op</span></div><div class="line">	<span class="comment">// 循环</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		PopCount1(<span class="number">2</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习2-4"><a href="#练习2-4" class="headerlink" title="练习2.4"></a>练习2.4</h4><p>写一个用于统计位的PopCount,它在其实际参数的64位上执行移位操作,每次判断最右边的位,进而实现统计功能.把它与快查表版本的性能进行对比</p>
<ul>
<li>很普通的写法</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount2</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	ret := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">64</span>; i++ &#123;</div><div class="line">		<span class="keyword">if</span> x&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</div><div class="line">			ret += <span class="number">1</span></div><div class="line">		&#125;</div><div class="line">		x = x &gt;&gt; <span class="number">1</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPopCount2</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	<span class="comment">// 20000000	        60.5 ns/op</span></div><div class="line">	<span class="comment">// &gt;&gt; 循环</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		PopCount2(<span class="number">2</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习2-5"><a href="#练习2-5" class="headerlink" title="练习2.5"></a>练习2.5</h4><p>使用x&amp;(x-1)可以清除x最右边的非零位,利用该特点写一个PopCount,然后评价它的性能</p>
<ul>
<li>x&amp;(x-1)面试基础题</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">PopCount3</span><span class="params">(x <span class="keyword">uint64</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	ret := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> x != <span class="number">0</span> &#123;</div><div class="line">		x = (x - <span class="number">1</span>) &amp; x</div><div class="line">		ret += <span class="number">1</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ret</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPopCount3</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	<span class="comment">// 30000000	        50.5 ns/op</span></div><div class="line">	<span class="comment">// x&amp;(x-1)</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		PopCount3(<span class="number">2</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后~~~还是挺奇葩，书上的写法居然是最快的，改成循环速度居然爆降，也不知道Go编译器是如何优化代码的╭(╯^╰)╮</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;名称&lt;/li&gt;
&lt;li&gt;声明&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;赋值&lt;/li&gt;
&lt;li&gt;类型声明&lt;/li&gt;
&lt;li&gt;包和文件&lt;/li&gt;
&lt;li&gt;作用域&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Go程序设计语言课后习题答案-第一章(入门)</title>
    <link href="https://www.zoulei.net/2018/06/03/the_go_programming_language_answer_1/"/>
    <id>https://www.zoulei.net/2018/06/03/the_go_programming_language_answer_1/</id>
    <published>2018-06-03T12:56:37.000Z</published>
    <updated>2018-06-04T14:15:32.894Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个初学者超级喜欢这本书，值得反复阅读，常读常新。因为读了好多时间了，因此有一个计划把课后习题全部做完，每天做五题~~</p>
<p>Golang版本:1.10.1<br>IDE: GoLand<br>操作系统: 10.13.4</p>
<a id="more"></a>
<h4 id="练习1-1"><a href="#练习1-1" class="headerlink" title="练习1.1"></a>练习1.1</h4><p>修改echo程序输出os.Args[0],即命令的名字</p>
<ul>
<li><code>os.Args</code>是一个slice</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOutputName</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	fmt.Println(os.Args[<span class="number">0</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习1-2"><a href="#练习1-2" class="headerlink" title="练习1.2"></a>练习1.2</h4><p>修改echo程序,输出参数的索引和值,每行一个</p>
<ul>
<li><code>for range</code>结构的使用</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestListArgs</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> os.Args &#123;</div><div class="line">		fmt.Printf(<span class="string">"%d\t%s\n"</span>, k, v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习1-3"><a href="#练习1-3" class="headerlink" title="练习1.3"></a>练习1.3</h4><p>尝试测量可能低效的程序和使用strings.Join的程序在执行时间上的差异</p>
<ul>
<li>该用例大概显示相比<code>+=</code>,使用strings.Join要快1782倍</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringJoin1</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	<span class="comment">// 1	1581441327 ns/op</span></div><div class="line">	<span class="keyword">var</span> a [<span class="number">100000</span>]<span class="keyword">string</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</div><div class="line">		a[i] = <span class="string">"1"</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		<span class="keyword">var</span> ret <span class="keyword">string</span></div><div class="line">		<span class="keyword">for</span> _, i := <span class="keyword">range</span> a &#123;</div><div class="line">			ret += i</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStringJoin2</span><span class="params">(b *testing.B)</span></span> &#123;</div><div class="line">	<span class="comment">// 2000	    844351 ns/op</span></div><div class="line">	<span class="keyword">var</span> a [<span class="number">100000</span>]<span class="keyword">string</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</div><div class="line">		a[i] = <span class="string">"1"</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</div><div class="line">		_ = strings.Join(a[:], <span class="string">""</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习1-4"><a href="#练习1-4" class="headerlink" title="练习1.4"></a>练习1.4</h4><p>修改dup2程序,输出出现重复行的文件的名称</p>
<ul>
<li>用结构体代替原有的string类型</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"bufio"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> line <span class="keyword">struct</span> &#123;</div><div class="line">	FileName <span class="keyword">string</span></div><div class="line">	String   <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	counts := <span class="built_in">make</span>(<span class="keyword">map</span>[line]<span class="keyword">int</span>)</div><div class="line">	files := os.Args[<span class="number">1</span>:]</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</div><div class="line">		countLines(os.Stdin, counts, <span class="string">"ARGS"</span>)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</div><div class="line">			f, err := os.Open(arg)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				fmt.Fprintf(os.Stderr, <span class="string">"dup2: %v\n"</span>, err)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			countLines(f, counts, f.Name())</div><div class="line">			f.Close()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</div><div class="line">		<span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</div><div class="line">			fmt.Printf(<span class="string">"%s\t%s\t%d\n"</span>, line.FileName, line.String, n)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(file *os.File, counts <span class="keyword">map</span>[line]<span class="keyword">int</span>, fileName <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	input := bufio.NewScanner(file)</div><div class="line">	<span class="keyword">for</span> input.Scan() &#123;</div><div class="line">		counts[line&#123;</div><div class="line">			FileName: fileName,</div><div class="line">			String:   input.Text(),</div><div class="line">		&#125;]++</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="练习1-5"><a href="#练习1-5" class="headerlink" title="练习1.5"></a>练习1.5</h4><p>改变利萨如程序的画板颜色为绿色黑底来增加真实性。使用color.RGBA{0xRR,0xGG,0xBB,0xff}创建一种web颜色#RRGGBB,每一对十六进制数组表示组成一个像素红、绿、蓝分量的亮度。</p>
<ul>
<li>画板底色为palette的第一个元素，可采用<code>0x</code>表示十六进制数字</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"image/color"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"image/gif"</span></div><div class="line">	<span class="string">"image"</span></div><div class="line">	<span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> palette = []color.Color&#123;color.Black, color.RGBA&#123;</div><div class="line">	R: <span class="number">0</span>,</div><div class="line">	G: <span class="number">0xFF</span>,</div><div class="line">	B: <span class="number">0</span>,</div><div class="line">	A: <span class="number">0xFF</span>,</div><div class="line">&#125;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	rand.Seed(time.Now().UTC().UnixNano())</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">"web"</span> &#123;</div><div class="line">		handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">			lissajous(w)</div><div class="line">		&#125;</div><div class="line">		http.HandleFunc(<span class="string">"/"</span>, handler)</div><div class="line">		log.Fatal(http.ListenAndServe(<span class="string">"localhost:8000"</span>, <span class="literal">nil</span>))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	lissajous(os.Stdout)</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</div><div class="line">	<span class="keyword">const</span> (</div><div class="line">		cycles  = <span class="number">5</span>     <span class="comment">// 完整的x振荡器变化的个数</span></div><div class="line">		res     = <span class="number">0.001</span> <span class="comment">//	角度分辨率</span></div><div class="line">		size    = <span class="number">100</span>   <span class="comment">//	图像画布包含 [-size..+size]</span></div><div class="line">		nframes = <span class="number">64</span>    <span class="comment">//	动画中的帧数</span></div><div class="line">		delay   = <span class="number">8</span>     <span class="comment">//	以10ms为单位的帧间延迟</span></div><div class="line">	)</div><div class="line">	freq := rand.Float64() * <span class="number">3.0</span> <span class="comment">// y振荡器的相对频率</span></div><div class="line">	anim := gif.GIF&#123;LoopCount: nframes&#125;</div><div class="line">	phase := <span class="number">0.0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</div><div class="line">		rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</div><div class="line">		img := image.NewPaletted(rect, palette)</div><div class="line">		<span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</div><div class="line">			x := math.Sin(t)</div><div class="line">			y := math.Sin(t*freq + phase)</div><div class="line">			img.SetColorIndex(size+<span class="keyword">int</span>(x*size+<span class="number">0.5</span>), size+<span class="keyword">int</span>(y*size+<span class="number">0.5</span>), <span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">		phase += <span class="number">0.1</span></div><div class="line">		anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</div><div class="line">		anim.Image = <span class="built_in">append</span>(anim.Image, img)</div><div class="line">	&#125;</div><div class="line">	gif.EncodeAll(out, &amp;anim)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习1-6"><a href="#练习1-6" class="headerlink" title="练习1.6"></a>练习1.6</h4><p>通过在画板中添加更多颜色，然后通过有趣的方式改变SetColorIndex的第三个参数,修改利萨如程序来产生多彩的图片</p>
<ul>
<li>没想到什么有趣的方式，随便用了个随机生成，<code>rand.Intn</code>,注意init在main前面被执行，因此随机种子需要放在init里面</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"image/color"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"image/gif"</span></div><div class="line">	<span class="string">"image"</span></div><div class="line">	<span class="string">"math"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> palette []color.Color</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	rand.Seed(time.Now().UTC().UnixNano())</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">256</span>; i++ &#123;</div><div class="line">		palette = <span class="built_in">append</span>(palette, color.RGBA&#123;</div><div class="line">			R: <span class="keyword">uint8</span>(rand.Intn(<span class="number">256</span>)),</div><div class="line">			G: <span class="keyword">uint8</span>(rand.Intn(<span class="number">256</span>)),</div><div class="line">			B: <span class="keyword">uint8</span>(rand.Intn(<span class="number">256</span>)),</div><div class="line">			A: <span class="number">0xFF</span>,</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">"web"</span> &#123;</div><div class="line">		handler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">			lissajous(w)</div><div class="line">		&#125;</div><div class="line">		http.HandleFunc(<span class="string">"/"</span>, handler)</div><div class="line">		log.Fatal(http.ListenAndServe(<span class="string">"localhost:8000"</span>, <span class="literal">nil</span>))</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	lissajous(os.Stdout)</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">lissajous</span><span class="params">(out io.Writer)</span></span> &#123;</div><div class="line">	<span class="keyword">const</span> (</div><div class="line">		cycles  = <span class="number">5</span>     <span class="comment">// 完整的x振荡器变化的个数</span></div><div class="line">		res     = <span class="number">0.001</span> <span class="comment">//	角度分辨率</span></div><div class="line">		size    = <span class="number">100</span>   <span class="comment">//	图像画布包含 [-size..+size]</span></div><div class="line">		nframes = <span class="number">64</span>    <span class="comment">//	动画中的帧数</span></div><div class="line">		delay   = <span class="number">8</span>     <span class="comment">//	以10ms为单位的帧间延迟</span></div><div class="line">	)</div><div class="line">	freq := rand.Float64() * <span class="number">3.0</span> <span class="comment">// y振荡器的相对频率</span></div><div class="line">	anim := gif.GIF&#123;LoopCount: nframes&#125;</div><div class="line">	phase := <span class="number">0.0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nframes; i++ &#123;</div><div class="line">		rect := image.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>*size+<span class="number">1</span>, <span class="number">2</span>*size+<span class="number">1</span>)</div><div class="line">		img := image.NewPaletted(rect, palette)</div><div class="line">		<span class="keyword">for</span> t := <span class="number">0.0</span>; t &lt; cycles*<span class="number">2</span>*math.Pi; t += res &#123;</div><div class="line">			x := math.Sin(t)</div><div class="line">			y := math.Sin(t*freq + phase)</div><div class="line">			img.SetColorIndex(size+<span class="keyword">int</span>(x*size+<span class="number">0.5</span>), size+<span class="keyword">int</span>(y*size+<span class="number">0.5</span>), <span class="keyword">uint8</span>(rand.Intn(<span class="built_in">len</span>(palette))))</div><div class="line">		&#125;</div><div class="line">		phase += <span class="number">0.1</span></div><div class="line">		anim.Delay = <span class="built_in">append</span>(anim.Delay, delay)</div><div class="line">		anim.Image = <span class="built_in">append</span>(anim.Image, img)</div><div class="line">	&#125;</div><div class="line">	gif.EncodeAll(out, &amp;anim)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习1-7"><a href="#练习1-7" class="headerlink" title="练习1.7"></a>练习1.7</h4><p>函数io.Copy(dst,src)从src读,并且写入dst.使用它代替ioutil.ReadAll来复制响应内容到os.StdOut,这样不需要装下整个数据流的缓冲区.确保检查io.Copy返回的错误结果</p>
<ul>
<li>io.Copy代替ioutil.ReadAll更省内存，同时也可以把它看做是一个同步的操作，返回了最终传输数据的大小</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"time"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"io/ioutil"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</div><div class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</div><div class="line">		<span class="keyword">go</span> fetch(url, ch)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</div><div class="line">		fmt.Println(&lt;-ch)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"%.2f elapsed\n"</span>, time.Since(start).Seconds())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="keyword">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	start := time.Now()</div><div class="line">	resp, err := http.Get(url)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		ch &lt;- fmt.Sprint(err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	nbytes, err := io.Copy(ioutil.Discard, resp.Body)</div><div class="line">	resp.Body.Close()</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		ch &lt;- fmt.Sprintf(<span class="string">"while reading %s: %v"</span>, url, err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	secs := time.Since(start).Seconds()</div><div class="line">	ch &lt;- fmt.Sprintf(<span class="string">"%.2fs %7d %s"</span>, secs, nbytes, url)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习1-8"><a href="#练习1-8" class="headerlink" title="练习1.8"></a>练习1.8</h4><p>修改fetch程序添加一个<a href="http://前缀(假如该URL参数缺失协议前缀).可能会用到strings.HasPrefix">http://前缀(假如该URL参数缺失协议前缀).可能会用到strings.HasPrefix</a></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddPrefix</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	inputURL := <span class="string">"z.cn"</span></div><div class="line">	<span class="keyword">if</span> ! strings.HasPrefix(inputURL, <span class="string">"http"</span>) &#123;</div><div class="line">		inputURL = <span class="string">"http://"</span> + inputURL</div><div class="line">	&#125;</div><div class="line">	fmt.Println(inputURL)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习1-9"><a href="#练习1-9" class="headerlink" title="练习1.9"></a>练习1.9</h4><p>修改fetch来输出http状态码,可以在resp.Status中找到它</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestOutputStatusCode</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	resp, _ := http.Get(<span class="string">"http://z.cn"</span>)</div><div class="line">	fmt.Println(<span class="string">"StatusCode: "</span>, resp.StatusCode)</div><div class="line">	io.Copy(os.Stdout, resp.Body)</div><div class="line">	resp.Body.Close()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="练习1-10"><a href="#练习1-10" class="headerlink" title="练习1.10"></a>练习1.10</h4><p>找一个产生大量数据的网站.连续两次运行fetchall,看报告的时间是否会有大的变化,调查缓存情况.每一次获取的内容一样吗?修改fetchall将内容输出到文件,这样可以检查它是否一致</p>
<ul>
<li>这问题不是他傻就是我傻，我还是偏向是他傻。猜测有可能说的是访问网站第一次很慢，第二次会因为缓存策略加速传输(比如http运营商缓存啥的)，亦或者是本机缓存304状态码(但是两次完全独立的访问和这个扯不上什么关系)</li>
</ul>
<h4 id="练习1-11"><a href="#练习1-11" class="headerlink" title="练习1.11"></a>练习1.11</h4><p>使用更长的参数列表来尝试fetchall,例如使用alexa.com排名前100万的网站,如果一个网站没有响应,程序的行为是则么样的</p>
<ul>
<li><a href="http://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/">Go net/http 超时机制完全手册</a></li>
<li>虽然每个URL都对应了一个chan，但是有可能某几个URL特别慢，那么所有的请求都需要等到最慢的那个完成，比如你在本地<code>nc -l 8000</code>监听端口，再直接使用<code>http.Get</code>访问。它默认永不超时，直到tcp连接被中断</li>
<li>打开太多的链接会启用N多的goroutine，这样会达到系统上限，比如触发常见的<code>too many open files</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个初学者超级喜欢这本书，值得反复阅读，常读常新。因为读了好多时间了，因此有一个计划把课后习题全部做完，每天做五题~~&lt;/p&gt;
&lt;p&gt;Golang版本:1.10.1&lt;br&gt;IDE: GoLand&lt;br&gt;操作系统: 10.13.4&lt;/p&gt;
    
    </summary>
    
      <category term="Go程序设计语言" scheme="https://www.zoulei.net/categories/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>mac上使用mitmproxy对ios app进行抓包</title>
    <link href="https://www.zoulei.net/2018/05/25/mitmproxy_transparent_model_network_capture/"/>
    <id>https://www.zoulei.net/2018/05/25/mitmproxy_transparent_model_network_capture/</id>
    <published>2018-05-25T09:45:59.000Z</published>
    <updated>2018-05-25T10:52:46.862Z</updated>
    
    <content type="html"><![CDATA[<p>对ios app抓包的方式挺多的，最常规的方案就是本机开启一个http代理。然后手机进行设置，将本机内网ip以及端口设置上去。安装一个https证书，设置为信任就可以开始抓包了。这个方案非常通用。类似的实现以Fiddler、charles为代表，它们确实很好用，也很好理解。但是缺点也是有的</p>
<ul>
<li>最大的缺点就是每一次使用都需要设置代理，你需要查看本机内网ip，然后填写到手机上。调试完成后再将手机的代理设置清除</li>
<li>Fiddler只有windows版本可用，意味着mac需要使用虚拟机，charles并没有Fiddler好用，然而还卖的贼贵</li>
</ul>
<p>同类型的开源方案最常见的是Python实现的mitmproxy。mitmweb也提供图形界面，别说，只要你不嫌弃还是挺好用的</p>
<p>osx上还有个比较奇葩的所谓网络调试软件Surge。99美刀，卖的还是挺贵的，功能还行，界面也挺花哨，忽悠小白是足够了。用它也能够远程调试，代价是需要用有线连接到mac电脑上，然后mac端软件就能捕获远程手机的网络请求数据，这个软件界面确实挺不错，然而请求过滤查找对比下Fiddler而言就是个渣渣吧。</p>
<p>因此想了一个比较另类的方案，手机使用mac电脑的网络，同时使用pf对请求进行转发。使用mitmproxy的透明代理模式获得手机端的数据，使用mitmweb进行展示</p>
<a id="more"></a>
<h3 id="本篇环境"><a href="#本篇环境" class="headerlink" title="本篇环境"></a>本篇环境</h3><ul>
<li>机器 MBP 2015/ ipad mini</li>
<li>系统  osx 10.13/ ios 11.3</li>
</ul>
<h3 id="1-让ipad通过蓝牙连上osx的网络"><a href="#1-让ipad通过蓝牙连上osx的网络" class="headerlink" title="1. 让ipad通过蓝牙连上osx的网络"></a>1. 让ipad通过蓝牙连上osx的网络</h3><p>参照<a href="https://www.zhihu.com/question/24480413">https://www.zhihu.com/question/24480413</a>，先让手机通过蓝牙连接上电脑，在电脑设置网络共享，选择蓝牙的方式，这一步基本就配置好了</p>
<p>接下来是验证。通过<code>ifconfig</code>命令查看目前存在哪些网络接口，查看active状态的接口，自己排除一下。像我的就是<code>bridge100</code>。然后可以使用wireshark看一下这个网络接口是否正常收到了手机端的数据请求<code>sudo /Applications/Wireshark.app/Contents/MacOS/Wireshark</code>。待能正常通过电脑网络访问后进行后续操作</p>
<h3 id="通过PF对网络数据进行转发"><a href="#通过PF对网络数据进行转发" class="headerlink" title="通过PF对网络数据进行转发"></a>通过PF对网络数据进行转发</h3><ol>
<li><p>允许ip转发</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo sysctl -w net.inet.ip.forwarding=1</div></pre></td></tr></table></figure>
</li>
<li><p>设置pf转发规则(将80、443端口的内容转发到本地8080端口)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/pf.conf</div><div class="line">添加如下行(记住使用对应的网络接口)</div><div class="line">另外pf的配置对顺序有要求，像我本机就需要将它放到rdr-anchor &quot;com.apple/*&quot;下一行</div><div class="line">rdr on bridge100 inet proto tcp to any port &#123;80, 443&#125; -&gt; 127.0.0.1 port 8080</div></pre></td></tr></table></figure>
</li>
<li><p>启用pf规则</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pfctl -e</div></pre></td></tr></table></figure>
</li>
<li><p>配置sudoer文件允许mitmproxy访问pfctl</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/sudoers</div><div class="line">添加以下行</div><div class="line">ALL ALL=NOPASSWD: /sbin/pfctl -s state</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="安装mitmproxy使用"><a href="#安装mitmproxy使用" class="headerlink" title="安装mitmproxy使用"></a>安装mitmproxy使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install mitmproxy</div><div class="line">mitmweb -T --ignore apple</div></pre></td></tr></table></figure>
<p>手机端访问<code>http://mimt.it</code>点击安装https证书。除此之外还需要设置-&gt; 通用 -&gt; 关于  -&gt; 信任证书设置 -&gt; 设置为可信。<br>上面ignore参数是正则匹配。忽略对域名包含apple的处理。因为在客户端强制证书验证的时候伪造证书是过不了的，这样会在调试的时候影响ios消息推送啥的<br>bingo~~ 结束了</p>
<p>不足之处就是它并不会显示访问的域名，只会显示ip(感觉这是一个bug，因为mitmproxy使用–host参数是能够看到正确的地址的)</p>
<p>然后就是学习一下mitmproxy的过滤语句了，很简单，在web操作上会有提示</p>
<p>整个过程就是这样，让手机通过电脑进行上网，用mitmproxy的透明代理模式从三层网络上捕获数据(这样就避免了在手机端设置代理)，希望能对你们有所帮助┑(￣Д ￣)┍</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://docs.mitmproxy.org/stable/howto-transparent/">https://docs.mitmproxy.org/stable/howto-transparent/</a><br><a href="https://medium.com/bugbountywriteup/intercepting-network-data-with-mitmproxy-on-macos-3e3f2f0123b2">https://medium.com/bugbountywriteup/intercepting-network-data-with-mitmproxy-on-macos-3e3f2f0123b2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对ios app抓包的方式挺多的，最常规的方案就是本机开启一个http代理。然后手机进行设置，将本机内网ip以及端口设置上去。安装一个https证书，设置为信任就可以开始抓包了。这个方案非常通用。类似的实现以Fiddler、charles为代表，它们确实很好用，也很好理解。但是缺点也是有的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大的缺点就是每一次使用都需要设置代理，你需要查看本机内网ip，然后填写到手机上。调试完成后再将手机的代理设置清除&lt;/li&gt;
&lt;li&gt;Fiddler只有windows版本可用，意味着mac需要使用虚拟机，charles并没有Fiddler好用，然而还卖的贼贵&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同类型的开源方案最常见的是Python实现的mitmproxy。mitmweb也提供图形界面，别说，只要你不嫌弃还是挺好用的&lt;/p&gt;
&lt;p&gt;osx上还有个比较奇葩的所谓网络调试软件Surge。99美刀，卖的还是挺贵的，功能还行，界面也挺花哨，忽悠小白是足够了。用它也能够远程调试，代价是需要用有线连接到mac电脑上，然后mac端软件就能捕获远程手机的网络请求数据，这个软件界面确实挺不错，然而请求过滤查找对比下Fiddler而言就是个渣渣吧。&lt;/p&gt;
&lt;p&gt;因此想了一个比较另类的方案，手机使用mac电脑的网络，同时使用pf对请求进行转发。使用mitmproxy的透明代理模式获得手机端的数据，使用mitmweb进行展示&lt;/p&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>ocr.ficapy.com 后台实现</title>
    <link href="https://www.zoulei.net/2018/04/01/pdfaddtext_architecture/"/>
    <id>https://www.zoulei.net/2018/04/01/pdfaddtext_architecture/</id>
    <published>2018-04-01T06:34:38.000Z</published>
    <updated>2018-04-01T12:19:21.171Z</updated>
    
    <content type="html"><![CDATA[<p>因为个人需求，写了一个很小众的作品，<a href="https://ocr.ficapy.com">https://ocr.ficapy.com</a>，我给它起的项目名是pdfaddtext，用途是给扫描版本的PDF文件加上搜索功能。使用场景是我有几本扫描版本的PDF书籍(网上有特别多的扫描版书籍)，有时候想搜索书中有没有提到某个知识点，纯图片是无法搜索的，你只能凭记忆去找。<span style="color:red"><strong>本项目作用就是将PDF的文本内容识别出来，然后写入一层隐藏的文字层，这样PDF阅读器就能够搜索这些文字了，同时尽量保证将识别出来的文字写到原图片对应的位置</strong></span>,类似的工具有<a href="https://github.com/jbarlow83/OCRmyPDF">OCRmyPDF</a>，它的缺点很明显，使用Tesseract OCR引擎，对比识别效果，简直被商用OCR吊打。</p>
<p>最开始有了这个想法，我大概花费了一个下午的时间用python写出了基本的demo。将每一页PDF转换成图片，然后用免费的OCR服务去识别，得到结果，最后合并出一个新的pdf出来。过程算是比较顺利。本着独乐乐不如众乐乐的心态。我计划将它转变成一项web服务，于是挖坑之旅就此开始了</p>
<p>TLDR</p>
<a id="more"></a>
<p>开始的构思是这个样子的<img src="https://ficapy.b0.upaiyun.com/blogimg/pdfaddtext_arch1.png" alt="pdfaddtext1"><br>后台接收到文件进行拆分，依次获取结果最后服务端生成文件返回给客户端。流程完成，是不是特简单😕</p>
<h3 id="问题一-pdf转换生成jpg效率过低"><a href="#问题一-pdf转换生成jpg效率过低" class="headerlink" title="问题一: pdf转换生成jpg效率过低"></a>问题一: pdf转换生成jpg效率过低</h3><p>python的生态无需质疑，各种包齐全到你怀疑人生。pdf转换成jpg也都是有的，比如<a href="https://github.com/Belval/pdf2image">pdf2image</a>。它有一个无法忽视的缺点，效率太低。个人处理少量问题可以，但是如果用于web服务。每生成一张照片卡两秒，肯定无法忍受，后来对比imagemagick和ghostscript，ghostscript的效率比imagemagick高一些，当然比python不知道高到哪里去了。注: imagemagick的pdf转图片底层使用的是ghostscript，最后选择了subprocess调用ghostscript</p>
<h3 id="问题二-OCR效率过低"><a href="#问题二-OCR效率过低" class="headerlink" title="问题二: OCR效率过低"></a>问题二: OCR效率过低</h3><p>目前没有能力搭建一个识别准确度比较高的文字识别引擎，于是使用了免费的OCR。在网上腾讯的免费OCR口碑是很不错的，超高的识别准确率，而且看文档发现不限制识别次数，只是不保证并发(是不是感觉超级良心！)。醒醒了少年，哪里有这么好的事情！！！</p>
<p>我刚开始用的时候大概四五秒返回结果。识别准确率网上没有瞎吹，对中文的准确率还是很不错的，后来可能该服务用的人太多，效率大幅度降低。降低到10到20秒才会返回结果。而且经常性返回系统繁忙的错误。这也可能和我的需求有关，因为我上传的识别素材都是1000像素以上的图片。里面的文字众多，所以识别效率比较低。但是腾讯提供的免费OCR服务有劣化服务质量的嫌疑，毕竟如果免费的服务提供的过于的好，用户付费的热情肯定大幅度降低。很明显的是你上传一张图片得到结果，之后再次上传依旧是等待十几秒才得到结果，稍微正常的开发肯定都知道将结果缓存一下，再次相同的图片请求直接返回结果。鉴于腾讯OCR的低效，我不得不找其他的OCR服务同时使用，保证系统的可靠性，最终同时使用了以下服务</p>
<ul>
<li><a href="https://ai.qq.com/doc/ocridcardocr.shtml">腾讯</a></li>
<li><a href="https://cloud.baidu.com/doc/OCR/OCR-API.html#.E8.BF.94.E5.9B.9E.E6.A0.BC.E5.BC.8F">百度</a></li>
<li><a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/computer-vision/">微软</a></li>
<li><a href="http://ai.sogou.com/ai-docs/api/ocr">搜狗</a></li>
<li><a href="https://console.faceplusplus.com.cn/documents/7776484">faceplusplus</a></li>
</ul>
<p>开发过程中的<span style="color:red"><strong>个人感觉</strong></span>,识别准确率依次是百度&gt;腾讯&gt;搜狗&gt;微软&gt;faceplusplus<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">分别是百度  腾讯  搜狗  微软 face++     对同一张简单图片的识别结果</div><div class="line">[[&apos;这是第一段文字&apos;, 316, 123, 22, 131], [&apos;这个地方是第二段Ohye&apos;, 213, 286, 21, 195]]</div><div class="line">[[&apos;这是第一段文字&apos;, 316, 123, 22, 131], [&apos;这个地方是第二段Ohye&apos;, 213, 286, 21, 195]]</div><div class="line">[[&apos;这是第一段文字&apos;, 309, 122, 24, 149], [&apos;这个地方是第二段Ohye&apos;, 202, 283, 26, 213]]</div><div class="line">[[&apos;这是第一段文字&apos;, 318, 125, 21, 124], [&apos;这个地方是第二段Ohye&apos;, 220, 290, 21, 189]]</div><div class="line">[[&apos;这是第一段文字&apos;, 319, 125, 19, 128], [&apos;个地方是第段Oye&apos;, 232, 286, 22, 176]]</div></pre></td></tr></table></figure></p>
<p>基本上国内能免费使用的OCR服务我都给想办法整合了，它们的输出都差不多，提供文字在图片中的定位功能，除了腾讯返回很慢，其他服务基本都在四秒左右返回。搜狗的OCR服务很低调，好像知道的人都不多，而且是这些服务里面文档最奇葩的，文档几乎没有，就提供了一个PHP调用服务的demo。</p>
<p>即便同时使用了五个免费服务，依旧不够用，而且几乎除了腾讯是不限制每日调用次数，其他的服务都会限制每天最多调用多少次。最后预估每天可供识别的图片数量最多不超过3000页。<span style="color:red"><strong>底层OCR服务的限制直接导致了设计复杂度的成倍上升</strong></span>，如果本地能在500毫秒内识别得到一个结果，也就没那么多事儿了。</p>
<h3 id="问题三：更快的响应"><a href="#问题三：更快的响应" class="headerlink" title="问题三：更快的响应"></a>问题三：更快的响应</h3><p>如果是单人使用,那么一个任务进行完毕之后再进行下一个任务。不存在并发调度的问题。但是它作为一项web服务，势必会存在并发问题，当某个用户正在执行转换操作，此时另外一个用户又提交了一个任务请求。是选择继续将前面的任务执行完毕再执行后续的(先到先服务)，还是采取一定的策略进行乱序执行。本程序选择了<span style="color:red"><strong>短任务优先策略</strong></span>，以pdf中的单页作为最小任务单元，使用优先级队列对任务进行排序。将每一个任务未完成的页数作为比较元素。每次选择任务的时候总是从优先级中选择未完成页数最少的任务优先执行。同时为了避免饥饿，假设存在几百页的大文件，每隔一分钟，按照任务的创建时间来调整任务优先级</p>
<p>最开始的最简架构几乎是认为不存在并发的。但是不并发是不可能的，所以流程改成了这样<br><img src="https://ficapy.b0.upaiyun.com/blogimg/pdfaddtext_arch2.png" alt="pdfaddtext_arch2"></p>
<ol>
<li>用户将图片上传到阿里云OSS, 后台接收到回调后下载文件。返回给客户端任务id。</li>
<li>客户端根据此ID创建websocket连接。后台下载文件完毕后发送redis队列消息。</li>
<li>开启一个独立的PDF分片进程。接收到消息后进程获取文件地址，然后将PDF文件的每一页转换成图片(放到特定的目录)。</li>
<li>生产者负责轮询目录发现新生成的图片。然后每一张图片被封装成一个Task任务对象，被加入到全局队列，全局队列的基本格式是一个字典{file_md5:Queue}，每一个文件都拥有一个队列。</li>
<li><span style="color:red"><strong>消费者负责从队列中获取一个任务。获取的规则是从优先级队列中找到第一个文件md5。然后在全局队列中对应文件md5队列中取出一个任务</strong>，执行任务，更新优先级队列，如果该文件被全部执行完成则返回结果</span></li>
</ol>
<p>这里涉及到了三个很重要的地方、<span style="color:red"><strong>Task任务、全局队列、优先级队列</strong></span>。其中第五步是整个过程中最容易出现错误的地方。</p>
<p>后台整个是使用Tornado实现的，最开始我考虑的是将PDF分片使用multiprocess进程来实现就好了。后来考虑它要是挂了怎么办。如果它挂了整个流程就无法进行。如果一定要将它使用multiprocess，那么将不得不监控它是不是挂掉了对它进行重启。最后还是将它独立出来用supervisord处理了</p>
<h3 id="问题四-锁-amp-死锁"><a href="#问题四-锁-amp-死锁" class="headerlink" title="问题四: 锁&amp;死锁"></a>问题四: 锁&amp;死锁</h3><p>上图中的消费者和生产者并不是简单的共享同一个任务队列。消费者取出任务的流程是先读取优先级队列得到文件md5，再从全局队列字典中获得相应队列获得任务。设想程序最开始从优先级队列里面取得的是空值。再用空值去查找全局队列无疑会被报错。要么你就在获取任务的时候使用while语句不断的判断当前优先级任务队列是否有元素。然而在Tornado里面死循环这种方式是不允许的，会直接造成其他部分无法执行，无法响应用户请求。因此需要使用Tornado提供的tornado.lock.Event。在读取优先级队列之前先判断该事件锁是否被锁。如果被锁那么coroutine就被阻塞。这样只需要在优先级队列添加和删除元素的地方统一处理。添加元素的时候取消锁。取消元素的时候判断优先级队列是否为空。为空则设置锁</p>
<p>为了不浪费系统资源。如果一个用户的任务正在被执行，而此时用户退出了。毫无疑问，这种情况下本着快速响应的原则，我们会直接删掉该文件的所有任务。再删掉任务之前，该文件在优先级队列中排列在最前面，因此，就有可能有的消费者获取了该文件的队列锁。然而{file_md5: Queue}任务队列被删除，意味着获取到锁的消费者永远无法被执行，造成死锁，该消费者再也无法消费任务。亦或者一个文件任务在未完成之前所有的消费者都会去读取这个队列，当任务被完成的时候(该队列会被删除)总有消费者还在持有该锁。避免方法是获取锁设置超时时间(比如五秒)，如果没有获取到任务直接报告异常，捕获异常，返回一个空任务，消费者对空任务忽略处理，等待再次去全局队列获取任务，此时刚才的文件队列应该已经删除了。</p>
<p>注: 系统重启的时候清空redis优先级队列(后来想了一下优先级队列不必要放在redis当中,直接python实现也是可以的，它并没有持久化的需求)</p>
<h3 id="问题五-何时触发redis消息，何时将任务加入到优先级队列"><a href="#问题五-何时触发redis消息，何时将任务加入到优先级队列" class="headerlink" title="问题五: 何时触发redis消息，何时将任务加入到优先级队列"></a>问题五: 何时触发redis消息，何时将任务加入到优先级队列</h3><p>这好像不是一个问题。最开始的时候我选择在文件下载完成后发送redis消息并加入到优先级队列。<br>先想这样一个问题，当用户断开后为了节省资源势必会选择立刻删掉优先级队列(同时删掉全局队列的相关项TODO:我好像没有考虑两个用户正在处理同一个PDF一个用户断线的情况)。假设用户是非正常断开(它过几秒后会再次连接，我是不是闲的蛋疼。考虑这种情况😕)。为了更好的体验会选择前端重连机制。我们希望重连后任务能恢复并继续。如果在下载完成后发送redis消息。那么websocket重连就不会发消息了。此时这个任务就没办法继续了</p>
<p>你会想，前端重连我也可以采用模拟重新上传文件的步骤啊~~~，too navie! 上传的时候添加了google验证码这一步。重新模拟上传自动化是做不到的。所以发送redis这一步再建立websocket连接后发比较合适<br>问题又来了。建立websocket后文件还没有下载完毕，此时发送redis消息到分片进程，分片进程无疑会出错。解决方法就和上面那个锁一样。添加Event事件锁，下载的时候执行set<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">download_event = &#123;&#125;</div><div class="line"><span class="keyword">if</span> self.file_md5 <span class="keyword">in</span> download_event:</div><div class="line">    download_event[self.file_md5].set()</div><div class="line">    IOLoop().instance().call_later(<span class="number">2</span>, <span class="keyword">lambda</span>: download_event.pop(self.file_md5, <span class="number">1</span>))</div></pre></td></tr></table></figure></p>
<p>优先级队列可供选择的地方就更多了</p>
<ol>
<li>文件下载完成后</li>
<li>websocket建立连接后</li>
<li>生产者添加任务后<br>这里最重要的是不要在多个地方插入同一个事件，出了问题不好debug。下载完成前标志着第一次建立连接，websocket有可能标志着断线重连。它们最终都会走向生产者这个地方，所以我选择在生产者这里添加。先检测该file_md5是否存在对应的websocket连接，如果存在则加入全局队列，同时加入优先级队列</li>
</ol>
<h3 id="优化一：重复文件直接得到结果"><a href="#优化一：重复文件直接得到结果" class="headerlink" title="优化一：重复文件直接得到结果"></a>优化一：重复文件直接得到结果</h3><p>如果文件在后台数据库存在记录，如果该文件全部结果都正确存在则直接返回结果。如果正在被执行或者有部分内容没有被OCR。则后台新建任务，总而言之，避免用户再次上传文件到阿里云OSS</p>
<h3 id="优化二：减少OCR次数"><a href="#优化二：减少OCR次数" class="headerlink" title="优化二：减少OCR次数"></a>优化二：减少OCR次数</h3><p>OCR的机会很宝贵,所以应该尽量减少OCR的次数，首先想到的是同一个文件如果得到了结果就不需要再次去调用OCR接口，再其次，一个PDF文件由N张图片组成。对每一张图片进行相似度判断，如果足够相似就认为它是同一张图片避免再次执行识别操作。图片相似度算法前面有博文提到，使用的是<a href="https://github.com/JohannesBuchner/imagehash">imagehash</a>。对每张图片生成64bit的标识。比对的时候使用汉明距离检查是否相似。数据库优化汉明距离的方法前面博文也有提到</p>
<h3 id="优化三-使用浏览器客户端进行PDF合并"><a href="#优化三-使用浏览器客户端进行PDF合并" class="headerlink" title="优化三:  使用浏览器客户端进行PDF合并"></a>优化三:  使用浏览器客户端进行PDF合并</h3><p>如果用户上传的文件为100M，在后台生成文件并提供给用户下载，OSS外网下载的价格大概是1G五毛。嗯。上传几个大文件，来几次恶意下载，等着天价账单吧😀。因此这种应用采取客户端渲染是很有必要的，我先找了一下js的库。号称”任何能够用JavaScript实现的应用系统，最终都必将用JavaScript实现”~~,然并卵，我并没有找到允许修改PDF文件的开源js库，关于PDF的要么是渲染用，要么就是从0生成一个新的PDF文件。后来我找到了商业的js库pspdfkit(也有一些其他的，当然它们价格都不菲)，它让我知道了有webassembly这个东东的存在，它允许c/c++/rust代码再浏览器端执行。虽然c/c++/rust我一个都不会, 但是我还是找到了一个c++的库<a href="https://github.com/galkahana/PDF-Writer">PDF-Writer</a>，看到了希望的曙光内心是激动的。然后我去刷C的教程，再刷了一遍C++的教程，知道了Hello World怎么写。参照了几个webassembly的项目(大多数都是用C写的)。重点参照了这个<a href="https://github.com/antelle/wasm-image-compressor">wasm-image-compressor</a>。最终还真给折腾出来了(前端耗费的时间占据了整个开发的一大半)。结果是编译后大小为1.5M，实现了两个功能。验证PDF文件是否有效(可以正常解析，页数是否符合要求，每页大小是否符合要求)，传入PDF文件和json结果，生成一个新的文件。<br>别说效率还真不错，生成文件过程比python快很多</p>
<p>该项目提供了两种生成PDF的方式，<a href="https://ocr.ficapy.com">浏览器端</a> 和<a href="https://gist.github.com/ficapy/baef42b378685e5853d709f2a69eadd1">python脚本</a>,这两种方式生成的PDF文件方式是不一样的。python的方式是合并两个图层，新的canvas图层透明度为完全透明.c++的方式是采取追加的方式，设置每个元素的可见性为不可见</p>
<p>其次是字体的问题，写入文字的时候都需要指明字体。然而附带一个完整的字体会浪费巨大的空间。我找了一个比较小一点的中文字体，大小是1.5M。感觉这些文字不需要真正的显示出来，所以自己制作一个最小的字体带她这个中文字体是有可能的，但是我失败了。制作出来后电脑能够正常识别，C++库结果无法正常打开该字体</p>
<h3 id="优化四-采用msgpack进行传输"><a href="#优化四-采用msgpack进行传输" class="headerlink" title="优化四: 采用msgpack进行传输"></a>优化四: 采用msgpack进行传输</h3><p>直接对结果进行json编码传输还是很不划算的,因此本项目数据存储以及前后端传输采用msgpack进行压缩后传输。需要注意的是websocket对二进制流需要特殊指定<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(url);</div><div class="line">socket.binaryType = <span class="string">'arraybuffer'</span>;</div><div class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> raw_data = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(event.data);</div><div class="line">    ret = msgpack.decode(raw_data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="改进方向"><a href="#改进方向" class="headerlink" title="改进方向"></a>改进方向</h3><ol>
<li>目前20页的限制让网页端几乎没有作用,提供一个稍有质量的本地OCR,对于数百页的PDF选择在本地识别</li>
<li>解决中文字体过大的问题，同时优化前端大小，尽量让压缩后的页面加载大小到1M以内</li>
<li>后台对PDF进行预处理,如果发现可直接读取文字表示该页不需要被OCR</li>
<li>改进前端发布逻辑，每次变动文件名让CDN缓存很尴尬</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://bertanguven.com/faster-conversions-from-pdf-to-pngjpeg-imagemagick-vs-ghostscript">Faster conversions from PDF to PNG/JPEG, imagemagick vs ghostscript</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为个人需求，写了一个很小众的作品，&lt;a href=&quot;https://ocr.ficapy.com&quot;&gt;https://ocr.ficapy.com&lt;/a&gt;，我给它起的项目名是pdfaddtext，用途是给扫描版本的PDF文件加上搜索功能。使用场景是我有几本扫描版本的PDF书籍(网上有特别多的扫描版书籍)，有时候想搜索书中有没有提到某个知识点，纯图片是无法搜索的，你只能凭记忆去找。&lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;本项目作用就是将PDF的文本内容识别出来，然后写入一层隐藏的文字层，这样PDF阅读器就能够搜索这些文字了，同时尽量保证将识别出来的文字写到原图片对应的位置&lt;/strong&gt;&lt;/span&gt;,类似的工具有&lt;a href=&quot;https://github.com/jbarlow83/OCRmyPDF&quot;&gt;OCRmyPDF&lt;/a&gt;，它的缺点很明显，使用Tesseract OCR引擎，对比识别效果，简直被商用OCR吊打。&lt;/p&gt;
&lt;p&gt;最开始有了这个想法，我大概花费了一个下午的时间用python写出了基本的demo。将每一页PDF转换成图片，然后用免费的OCR服务去识别，得到结果，最后合并出一个新的pdf出来。过程算是比较顺利。本着独乐乐不如众乐乐的心态。我计划将它转变成一项web服务，于是挖坑之旅就此开始了&lt;/p&gt;
&lt;p&gt;TLDR&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 杂项</title>
    <link href="https://www.zoulei.net/2018/03/20/Tornado_misc/"/>
    <id>https://www.zoulei.net/2018/03/20/Tornado_misc/</id>
    <published>2018-03-20T06:50:09.000Z</published>
    <updated>2018-03-20T07:23:11.034Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado系列基本介绍的差不多了，本篇介绍一些零散的东西。有了前面的知识，本篇会讲的比较粗略</p>
<a id="more"></a>
<h3 id="set-blocking-signal-threshold"><a href="#set-blocking-signal-threshold" class="headerlink" title="set_blocking_signal_threshold"></a>set_blocking_signal_threshold</h3><p>因为Tornado是单线程的，因此当一个任务被阻塞一两秒钟基本就是哪里出问题了，该函数给了我们一个机会察觉这些问题。可以当发生阻塞超过阈值的时候执行相关回调函数</p>
<p>实现原理就是使用信号机制，先使用<code>signal.signal(signal.SIGALRM,callback)</code>注册信号回调函数。在ioloop主循环中每次事件完成后将实时计时器归零<code>signal.setitimer(signal.ITIMER_REAL, 0, 0)</code>后再重新开始计时。如果主循环被阻塞没有被执行计时器归零则会被触发</p>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>有一些情况我们会部署多个Tornado实例用来增加系统整体吞吐量，有两种方案，一：将Tornado程序单独执行N份，每一个实例单独监听一个端口，然后使用Nginx实现负载均衡。二：使用Tornado提供的多进程，该模块实现在process.py(最简单的版本为v2.1.0)，实现原理为开启一个主进程，开启N个工作进程，主进程主要负责这些工作进程的重启工作(比如某进程挂掉了，那么会重新启动一个，维持总进程数量)。没一个工作进程都有一个主循环，它们均分处理http请求</p>
<h3 id="gen-sleep"><a href="#gen-sleep" class="headerlink" title="gen.sleep"></a>gen.sleep</h3><p>等待N秒钟，这个功能直到4.1版本才被加入，还是挺奇怪的。实现原理就是新建一个Future对象，同时添加回调到主循环，设置N秒后将Future对象设置为任意一个值。</p>
<h3 id="gen-run-on-executer"><a href="#gen-run-on-executer" class="headerlink" title="gen.run_on_executer"></a>gen.run_on_executer</h3><p>使用单独的线程来完成阻塞的任务。同时能够使用yield异步接收到返回的值。实现原理主要依靠concurrent.future模块，concurrent.future.submit会返回一个Future对象。yield接收到这个对象控制权转移。当线程内容执行完毕后会设置Future的值。yield被恢复</p>
<h3 id="run-sync"><a href="#run-sync" class="headerlink" title="run_sync"></a>run_sync</h3><p>经常用于调试。比如写了一个异步函数，要验证一下正确性。那么就不需要使用IOLoop.instance().start()让它无法终止。假设a函数被coroutine装饰，那么a()返回一个Future对象，此时执行IOLoop.instance().start()。整个主循环就会被执行。而run_sync仅仅只是在中间做了一件事情。对于一个Future对象，拥有add_done_callback函数，表示该Future完成后做某事，因此它只是添加了一个回调让主循环停止</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tornado系列基本介绍的差不多了，本篇介绍一些零散的东西。有了前面的知识，本篇会讲的比较粗略&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之queue</title>
    <link href="https://www.zoulei.net/2018/03/19/tornado_queue/"/>
    <id>https://www.zoulei.net/2018/03/19/tornado_queue/</id>
    <published>2018-03-19T06:24:05.000Z</published>
    <updated>2018-03-20T06:44:46.310Z</updated>
    
    <content type="html"><![CDATA[<p>介绍完StackContext、gen.engine、gen.coroutine之后Tornado3.0以前的核心内容基本已经完结了。本篇介绍一下gen.coroutine中Future的应用，在tornado中生成一个队列的数据结构。如果经常写web的情况，单单只处理用户的输入给出输出，那么要求不会太多，也不会用到队列。可是如果你去写一个爬虫，肯定需要限速啥的，此时队列就是一个很有用的东西，很容易实现生产者消费者模型。Tornado官方的demo中也有一个[爬虫代码(<a href="https://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py)]演示如何使用队列(本篇基于v5.0.0">https://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py)]演示如何使用队列(本篇基于v5.0.0</a>)</p>
<a id="more"></a>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解Queue模块给出的例子就可以了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</div><div class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</div><div class="line"><span class="keyword">from</span> tornado.queues <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line">q = Queue(maxsize=<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        item = <span class="keyword">yield</span> q.get()</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            print(<span class="string">'Doing work on %s'</span> % item)</div><div class="line">            <span class="keyword">yield</span> gen.sleep(<span class="number">0.01</span>)</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            q.task_done()</div><div class="line"></div><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        <span class="keyword">yield</span> q.put(item)</div><div class="line">        print(<span class="string">'Put %s'</span> % item)</div><div class="line"></div><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># Start consumer without waiting (since it never finishes).</span></div><div class="line">    IOLoop.current().spawn_callback(consumer)</div><div class="line">    <span class="keyword">yield</span> producer()  <span class="comment"># Wait for producer to put all tasks.</span></div><div class="line">    <span class="keyword">yield</span> q.join()  <span class="comment"># Wait for consumer to finish all tasks.</span></div><div class="line">    print(<span class="string">'Done'</span>)</div><div class="line"></div><div class="line">IOLoop.current().run_sync(main)</div></pre></td></tr></table></figure></p>
<h3 id="控制权转移"><a href="#控制权转移" class="headerlink" title="控制权转移"></a>控制权转移</h3><p>在python自带模块里面的queue是给多线程使用的.意味着当队列里面没有元素的时候会阻塞主线程。阻塞主线程这种操作在协程里面当然是不允许的。协程里面需要的是当某事需要进行等待的时候主动让出控制权限，让其他的事件执行。具体来说，如何让出控制权呢。理解上一篇的coroutine就可以发现。<span style="color:red"><strong>yield 一个暂时还没有结果的Future就会导致控制权转移，等Future结果到来yield就会被恢复</strong></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado.gen <span class="keyword">import</span> coroutine,sleep</div><div class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</div><div class="line"></div><div class="line"><span class="meta">@coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">xx</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> sleep(<span class="number">1</span>)</div><div class="line">    print(<span class="string">"xx"</span>)</div><div class="line"></div><div class="line"><span class="meta">@coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">()</span>:</span></div><div class="line">    xx()</div><div class="line">    print(<span class="string">"x"</span>)</div><div class="line"></div><div class="line"><span class="comment"># x()</span></div><div class="line"><span class="comment"># IOLoop.instance().start()</span></div><div class="line">IOLoop.instance().run_sync(x)</div></pre></td></tr></table></figure><br>观察这个例子。正常的写法是<code>yield xx()</code>，然后会调用xx(),过一秒之后打印xx再打印x。如果直接使用xx，其实这段代码也没有什么问题。xx返回了一个Future对象。因为没有使用yield，所以它不必等待xx函数执行完再进行下面的操作。xx返回的Future已经开始了运行(它并不会什么都不发生)，它依旧在一秒钟之后被执行然后打印xx。</p>
<h3 id="Queue的实现思路"><a href="#Queue的实现思路" class="headerlink" title="Queue的实现思路"></a>Queue的实现思路</h3><p>核心思路是</p>
<ul>
<li>get、put操作均返回Future对象</li>
<li>没有被设置值的Future执行yield会有阻塞效果</li>
</ul>
<p>创建三个队列分别为正常队列_queue、未来get队列_getters，未来put队列_putters。<br>执行get操作的时候创建一个Future对象。优先从_putters里面获取.获得的是一个值和一个Future对象，执行Future.set_result。此时代表put被阻塞，执行set_result取消阻塞。再考虑从_queue里面取，代表正常取值。如果都没有则放入_getters队列(此时因为Futures没有值，取值的地方被阻塞)。</p>
<p>执行put就是相反的操作，优先从_getters里面取(有值则执行Future.set_result，取消获取过程的阻塞)。再检查正常队列的元素是否超过最大值。否则加入未来队列</p>
<p>那么队列还有task_done和join操作，前者每一个任务执行完毕都会被调用表示该任务完成，后者表示等待加入到队列的所有任务都完成，否则阻塞。顺便说一下tornado的锁是怎么实现的</p>
<p>依旧是依靠没有被设置值的Future被yield会造成阻塞。该Future被设置值则会继续执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.f = Future()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.f.done():</div><div class="line">            self.f.set_result(<span class="keyword">None</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.f.done():</div><div class="line">            self.f = Future()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.f</div></pre></td></tr></table></figure><br>注意。这个地方调用set和clear都是不带yield的，只有当最后调用wait才使用yield。</p>
<h3 id="Queue的实现"><a href="#Queue的实现" class="headerlink" title="Queue的实现"></a>Queue的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=None)</span>:</span></div><div class="line">        self.max_size = maxsize <span class="keyword">or</span> <span class="number">2</span> &lt;&lt; <span class="number">16</span></div><div class="line">        self._queue = collections.deque([])</div><div class="line">        self._getters = collections.deque([]) </div><div class="line">        self._putters = collections.deque([]) </div><div class="line">        self._unfinished_tasks = <span class="number">0</span></div><div class="line">        self._finished = Event()</div><div class="line">        self._finished.set()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        f = Future()</div><div class="line">        <span class="keyword">if</span> len(self._queue) &gt; <span class="number">0</span>:</div><div class="line">            value = self._queue.popleft()</div><div class="line">            f.set_result(value)</div><div class="line">        <span class="keyword">elif</span> len(self._putters) &gt; <span class="number">0</span>:</div><div class="line">            item, future = self._putters.popleft()</div><div class="line">            f.set_result(item)</div><div class="line">            future.set_result(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self._getters.append(f)</div><div class="line">        <span class="keyword">return</span> f</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._unfinished_tasks += <span class="number">1</span></div><div class="line">        self._finished.clear()</div><div class="line"></div><div class="line">        f = Future()</div><div class="line">        <span class="keyword">if</span>  len(self._getters) &gt; <span class="number">0</span>:</div><div class="line">            future = self._getters.pop()</div><div class="line">            f.set_result(<span class="keyword">None</span>)</div><div class="line">            future.set_result(value)</div><div class="line">        <span class="keyword">elif</span> len(self._queue) &lt; self.max_size:</div><div class="line">            self._queue.append(value)</div><div class="line">            f.set_result(<span class="keyword">None</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self._putters.append((value, f))</div><div class="line">        <span class="keyword">return</span> f</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">task_done</span><span class="params">(self)</span>:</span></div><div class="line">        self._unfinished_tasks -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> self._unfinished_tasks == <span class="number">0</span>:</div><div class="line">            self._finished.set()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._finished.wait()</div></pre></td></tr></table></figure>
<p>源码做了更多的适配将_get和_put独立出来。然后使用优先级队列，先进后出队列满足不同的出入顺序要求</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍完StackContext、gen.engine、gen.coroutine之后Tornado3.0以前的核心内容基本已经完结了。本篇介绍一下gen.coroutine中Future的应用，在tornado中生成一个队列的数据结构。如果经常写web的情况，单单只处理用户的输入给出输出，那么要求不会太多，也不会用到队列。可是如果你去写一个爬虫，肯定需要限速啥的，此时队列就是一个很有用的东西，很容易实现生产者消费者模型。Tornado官方的demo中也有一个[爬虫代码(&lt;a href=&quot;https://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py)]演示如何使用队列(本篇基于v5.0.0&quot;&gt;https://github.com/tornadoweb/tornado/blob/master/demos/webspider/webspider.py)]演示如何使用队列(本篇基于v5.0.0&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之gen.coroutine</title>
    <link href="https://www.zoulei.net/2018/03/17/Tornado_gen_coroutine/"/>
    <id>https://www.zoulei.net/2018/03/17/Tornado_gen_coroutine/</id>
    <published>2018-03-17T07:54:43.000Z</published>
    <updated>2018-03-17T11:10:21.530Z</updated>
    
    <content type="html"><![CDATA[<p>2013年Tornado3.0版本。gen.coroutine上线，直到今天它依旧是目前Tornado中使用最为广泛的装饰器。同时它也是接替gen.engine的存在。它基本去掉了gen.Task的套路。相对gen.engine而言。它只需要gen.coroutine就够了，写法上更为美观</p>
<a id="more"></a>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>需要实现的目标是这样的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenAsyncHandler</span><span class="params">(RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @asynchronous</span></div><div class="line"><span class="meta">    @gen.coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        http_client = AsyncHTTPClient()</div><div class="line">        response = <span class="keyword">yield</span> http_client.fetch(<span class="string">"http://example.com"</span>)</div><div class="line">        do_something_with_response(response)</div><div class="line">        self.render(<span class="string">"template.html"</span>)</div></pre></td></tr></table></figure></p>
<p>在这里，它并不是gen.engine时代的作风。在上一篇中可以看到，添加gen.engine的时候没有改动过任何已有代码。可是在gen.coroutine时代。它去掉了gen.Task。于此同时，改动的是http_client.fetch。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Task这个名词不够炫酷，然后它新增了一个类叫做Future。<code>未来</code>这个词看起来就很有科技感。是的，它表述的是，在未来某一刻，这个对象会得到结果，当然这背后的一切仍然是换汤不换药由回调操作来完成。看一下Future都有啥<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._val = <span class="keyword">None</span></div><div class="line">        self._callback = set()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._val = value</div><div class="line">        <span class="keyword">for</span> callback <span class="keyword">in</span> self._callback:</div><div class="line">            callback(self)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._val</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span><span class="params">(self, callback)</span>:</span></div><div class="line">        self._callback.add(callback)</div></pre></td></tr></table></figure><br>一个Future类可以如此的简单。它只是提供了一个_val的存储场所，另外当使用set_result设置值的时候会顺便将加入到该对象的回调进行调用。提供了添加回调的函数add_done_callback</p>
<p>回忆gen.Task，它做的事情是对包含callback参数的函数A进行包装，当函数A的callback被调用的时候，实际上调用的是Runner.result_callback。这种做法的缺点呢就是在RequestHandler.get里面需要出现gen.Task。现在我们不希望它出现。我们完全可以改变这一逻辑。因为http_client.fetch肯定是会调用callback的。可以想象它最终的语句是<code>callback(result)</code>。<span style="color:red"><strong>既然框架希望让用户不必输入gen.Task，那么可以选择在http_client.fetch中加入Future,设置它的callback为Future.set_result</strong></span>。随便举例如下。假设有一个函数是add_one,原本逻辑如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(ret, callback)</span>:</span></div><div class="line">    ret += <span class="number">1</span></div><div class="line">    IOLoop.instance().add_callback(<span class="keyword">lambda</span>: callback(ret))</div></pre></td></tr></table></figure><br>改写成这个样子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(ret)</span>:</span></div><div class="line">    future = Future()</div><div class="line">    ret += <span class="number">1</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> future.set_result(ret)</div><div class="line">    IOLoop.instance().add_callback(callback)</div><div class="line">    <span class="keyword">return</span> future</div></pre></td></tr></table></figure><br>虽然这个地方最终被future.set_result执行。可是Future提供了add_done_callback接口，<span style="color:red"><strong>意味着允许我们自己的callback能够在add_one执行完毕后被future.set_result所触发</strong></span>，同时注意add_one返回的是一个future对象</p>
<h3 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h3><p>假如我们类比gen.engine去实现它<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, g)</span>:</span></div><div class="line">        self.g = g</div><div class="line">        <span class="comment"># 得到一个Future</span></div><div class="line">        self.yielded = self.g.send(<span class="keyword">None</span>)</div><div class="line">        self.yielded.add_done_callback(self.future_callback)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">future_callback</span><span class="params">(self, future)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.result_callback(future.result())</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result_callback</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.result = value</div><div class="line">        self.run()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self.yielded = self.g.send(self.yielded.result())</div><div class="line">            self.yielded.add_done_callback(self.future_callback)</div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">    @wraps(func)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        result = func(*args, **kwargs)</div><div class="line">        <span class="keyword">return</span> Runner(result)</div><div class="line">    <span class="keyword">return</span> inner</div></pre></td></tr></table></figure><br>是不是几乎一模一样，还可以正常运行。但是这里有一个极大的缺陷。它无法被嵌套使用，什么意思呢<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado.gen <span class="keyword">import</span> coroutine</div><div class="line"><span class="meta">@coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> b()</div><div class="line"></div><div class="line"><span class="meta">@coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div></pre></td></tr></table></figure><br>同时在gen.engine时代, 这种调用方式也是不被允许的，可是gen.coroutine实现了这种方式的调用。主要原理是我们规定，所有yield右边的值全部是Future对象，对一个Future对象处理完毕后再处理下一个。那么就要修改coroutine了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line">        f = Future()</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">final_callback</span><span class="params">(value)</span>:</span></div><div class="line">            f.set_result(value)</div><div class="line">        Runner(func, final_callback)</div><div class="line">        <span class="keyword">return</span> f</div><div class="line">    <span class="keyword">return</span> inner</div></pre></td></tr></table></figure><br>对于每一个子coroutine，它们都会生成一个Runner对象(此时Runner已经将生成器进行初始化，执行send(None)，并add_done_callback)，只是它们返回的并不是Runner，而是Future.在Future被执行set_result操作的时候子coroutine的yield往下走。直到遇到StopIteration异常，此时final_callback函数被调用，它被父coroutine所接受，触发父coroutine的yield往下走。。。。堪称完美。。。。</p>
<p>就这样，它实现了和yield from差不多的逻辑。父生成器调用子生成器，简直六的飞起不服不行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen, final_callback)</span>:</span></div><div class="line">        self.final_callback = final_callback</div><div class="line">        self.gen = gen()</div><div class="line">        self.yielded = self.gen.send(<span class="keyword">None</span>)</div><div class="line">        <span class="comment"># 会回调future对象</span></div><div class="line">        self.yielded.add_done_callback(self.future_callback)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">future_callback</span><span class="params">(self, future)</span>:</span></div><div class="line">        self.run()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self.yielded = self.gen.send(self.yielded.result())</div><div class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</div><div class="line">            self.final_callback(e.value)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.yielded.add_done_callback(self.future_callback)</div></pre></td></tr></table></figure></p>
<p>说实话，还是感觉有点绕，希望你能够看明白</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>和上面的简易写法不同。Tornado源码的实现要复杂一些，因为它要考虑更复杂的需求</p>
<ul>
<li>兼容性，它不能因为有了Future对象后就完全不顾以前gen.Task的写法</li>
<li>它同样需要实现一次yield多个Future的需求</li>
</ul>
<p>所以，它另外生成了一个和gen.Task类似的对象YieldFuture。和gen.Task拥有的成员对象一样<br><code>start</code>、<code>is_ready</code>、<code>get_result</code>。同时由于Future在Tornado中应用是如此的普遍。IOLoop新增了一个方法add_future函数(还有一方面就是前面提到的callback异常问题)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_future</span><span class="params">(self, future, callback)</span>:</span></div><div class="line">    <span class="keyword">assert</span> isinstance(future, Future)</div><div class="line">    callback = stack_context.wrap(callback)</div><div class="line">    future.add_done_callback(</div><div class="line">        <span class="keyword">lambda</span> future: self.add_callback(callback, future))</div></pre></td></tr></table></figure><br>在使用的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">self.runner = runner</div><div class="line">self.key = object()</div><div class="line">runner.register_callback(self.key)</div><div class="line">self.io_loop.add_future(self.future, runner.result_callback(self.key))</div></pre></td></tr></table></figure></p>
<p>实际上如果不考虑异常情况，和它是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Future.add_done_callback(self.future_callback)</div></pre></td></tr></table></figure></p>
<p>和gen.engine一样。coroutine也会遇到这种问题<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@gen.coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">    http_client = AsyncHTTPClient()</div><div class="line">    response1, response2 = <span class="keyword">yield</span> [http_client.fetch(url1),</div><div class="line">                                  http_client.fetch(url2)]</div><div class="line">    response_dict = <span class="keyword">yield</span> dict(response3=http_client.fetch(url3),</div><div class="line">                               response4=http_client.fetch(url4))</div><div class="line">    response3 = response_dict[<span class="string">'response3'</span>]</div><div class="line">    response4 = response_dict[<span class="string">'response4'</span>]</div></pre></td></tr></table></figure><br>一次yield 多个Future对象。那么解决办法也是和engine差不多的。当发现send(value)返回值是一个list或者dict对象时。它会使用Multi进行封装。在被回调的时候检查Multi对象的is_ready状态。仅仅当都得到结果才算完成</p>
<p>另外在Tornado3.1版本HandlerRequest._execute进行改动。被coroutine装饰的函数不需要再被asynchronous所装饰。至此这个从1.0.0跨越到3.1.0版本的装饰器的生命走到了尽头。然而依旧很多人不管不顾硬是要加上这个装饰器才安心</p>
<h3 id="应用一"><a href="#应用一" class="headerlink" title="应用一"></a>应用一</h3><p>可以说自此之后Tornado只存在Future配合yield、coroutine的操作。你从头新建一个Tornado的异步库。用户调用最后必定是返回给用户Future对象。这里我印象比较深的就是用Future实现了celery结果的异步获取。说是异步。实质上就是轮询。<a href="https://github.com/mayflaver/tornado-celery/blob/master/torncelery.py">代码在这里</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado.concurrent <span class="keyword">import</span> TracebackFuture</div><div class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">async</span><span class="params">(task, *args, **kwargs)</span>:</span></div><div class="line">    future = TracebackFuture()</div><div class="line">    callback = kwargs.pop(<span class="string">"callback"</span>, <span class="keyword">None</span>)</div><div class="line">    <span class="keyword">if</span> callback:</div><div class="line">        IOLoop.instance().add_future(future,</div><div class="line">                                     <span class="keyword">lambda</span> future: callback(future.result()))</div><div class="line">    result = task.delay(*args, **kwargs)</div><div class="line">    IOLoop.instance().add_callback(_on_result, result, future)</div><div class="line">    <span class="keyword">return</span> future</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_on_result</span><span class="params">(result, future)</span>:</span></div><div class="line">    <span class="comment"># if result is not ready, add callback function to next loop,</span></div><div class="line">    <span class="keyword">if</span> result.ready():</div><div class="line">        future.set_result(result.result)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        IOLoop.instance().add_callback(_on_result, result, future)</div></pre></td></tr></table></figure><br>celery执行task.delay立刻返回了result对象。然后将resule和future加入回调，查询resule.ready确定任务是否完成。一旦完成则调用future.set_resule。Future对象设置值之后yield就会继续往下走。完美~~~，否则它会再次循环，直到得到结果为止。可以看到它这种方式还是相当的粗暴的，因为一旦没有结果就会不停的循环。可是这种方式胜在代码简单</p>
<h3 id="应用二"><a href="#应用二" class="headerlink" title="应用二"></a>应用二</h3><p>再来一个简单的例子，gen.sleep() 比较没有想到，它会是4.1.0版本才加入的，实现如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(duration)</span>:</span></div><div class="line">    f = Future()</div><div class="line">    IOLoop.current().call_later(duration, <span class="keyword">lambda</span>: f.set_result(<span class="keyword">None</span>))</div><div class="line">    <span class="keyword">return</span> f</div></pre></td></tr></table></figure><br>(⊙v⊙)嗯，意不意外。这应该是我在Tornado里面发现最简单的代码了，创建一个Future对象，然后在IOLoop的_timeout列表中加入一个到期执行回调，设置Future的值。至此yield继续往下走~~</p>
<h3 id="简易代码"><a href="#简易代码" class="headerlink" title="简易代码"></a>简易代码</h3><p>可以用下面这段简易代码观察一下coroutine的逻辑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._val = <span class="keyword">None</span></div><div class="line">        self._callback = set()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._val = value</div><div class="line">        <span class="keyword">for</span> callback <span class="keyword">in</span> self._callback:</div><div class="line">            callback(self)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._val</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span><span class="params">(self, callback)</span>:</span></div><div class="line">        self._callback.add(callback)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen, final_callback)</span>:</span></div><div class="line">        self.final_callback = final_callback</div><div class="line">        self.gen = gen()</div><div class="line">        self.yielded = self.gen.send(<span class="keyword">None</span>)</div><div class="line">        <span class="comment"># 会回调future对象</span></div><div class="line">        self.yielded.add_done_callback(self.future_callback)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">future_callback</span><span class="params">(self, future)</span>:</span></div><div class="line">        self.run()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self.yielded = self.gen.send(self.yielded.result())</div><div class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</div><div class="line">            self.final_callback(e.value)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.yielded.add_done_callback(self.future_callback)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line">        f = Future()</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">final_callback</span><span class="params">(value)</span>:</span></div><div class="line">            f.set_result(value)</div><div class="line">        Runner(func, final_callback)</div><div class="line">        <span class="keyword">return</span> f</div><div class="line">    <span class="keyword">return</span> inner</div><div class="line"></div><div class="line"><span class="meta">@coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">()</span>:</span></div><div class="line">    c = <span class="keyword">yield</span> haha1()</div><div class="line">    r = <span class="keyword">yield</span> add_one(<span class="number">1</span>)</div><div class="line">    b = <span class="keyword">yield</span> add_one(<span class="number">2</span>)</div><div class="line">    print(r, b, c)</div><div class="line"></div><div class="line"><span class="meta">@coroutine</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha1</span><span class="params">()</span>:</span></div><div class="line">    r = <span class="keyword">yield</span> add_one(<span class="number">1</span>)</div><div class="line">    b = <span class="keyword">yield</span> add_one(<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> r + b</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(ret)</span>:</span></div><div class="line">    f = Future()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future, result)</span>:</span></div><div class="line">        future.set_result(result)</div><div class="line">    tornado.ioloop.IOLoop.instance().add_callback(partial(callback, f, ret + <span class="number">1</span>))</div><div class="line">    <span class="keyword">return</span> f</div><div class="line">haha()</div><div class="line"></div><div class="line">tornado.ioloop.IOLoop().instance().start()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2013年Tornado3.0版本。gen.coroutine上线，直到今天它依旧是目前Tornado中使用最为广泛的装饰器。同时它也是接替gen.engine的存在。它基本去掉了gen.Task的套路。相对gen.engine而言。它只需要gen.coroutine就够了，写法上更为美观&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之gen.engine</title>
    <link href="https://www.zoulei.net/2018/03/17/tornado_gen_engine/"/>
    <id>https://www.zoulei.net/2018/03/17/tornado_gen_engine/</id>
    <published>2018-03-17T04:13:51.000Z</published>
    <updated>2018-03-17T07:49:00.209Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado在2011年的2.1版本加入了gen.engine模块，该模块主要为了解决异步程序编写不够优雅的问题。力图让使用者离callback更远，这也是Tornado厉害的地方。本来内部各种事件处理，callback满天飞，可是在用户眼里，它那个class Handler(web.RequestHandler)下面get的写法和同步写法差不多嘛。和同步的写法一样，获得了更高的性能，我想这也是为什么Tornado能出彩的地方吧(本文代码基于v2.3.0)</p>
<a id="more"></a>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>主要起因就是不够优雅的callback,假设有一个需求，我们需要向第三方api请求数据，然后返回给客户端。此时写法是这样的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @asynchronous</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        http_client = AsyncHTTPClient()</div><div class="line">        http_client.fetch(<span class="string">"http://example.com"</span>,</div><div class="line">                          callback=self.on_fetch)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_fetch</span><span class="params">(self, response)</span>:</span></div><div class="line">        do_something_with_response(response)</div><div class="line">        self.render(<span class="string">"template.html"</span>)</div></pre></td></tr></table></figure><br>这种写法会有什么问题？假设我现在需要对返回的数据进行处理，那么我必须要写到回调函数里面。另外，如果在回调函数里面继续要使用其他的回调逻辑，那么肯定也是需要继续在回调函数里面编写，最后就形成了著名的回调地狱。明显这种方式是很让人恶心的，Tornado在这一版本上改动成了这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenAsyncHandler</span><span class="params">(RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @asynchronous</span></div><div class="line"><span class="meta">    @gen.engine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        http_client = AsyncHTTPClient()</div><div class="line">        response = <span class="keyword">yield</span> gen.Task(http_client.fetch, <span class="string">"http://example.com"</span>)</div><div class="line">        do_something_with_response(response)</div><div class="line">        self.render(<span class="string">"template.html"</span>)</div></pre></td></tr></table></figure><br>这样就好很多了嘛，更符合人们同步编写代码的直觉。观察改变有三个地方</p>
<ul>
<li>整个函数添加了gen.engine装饰器</li>
<li>添加了yield语句</li>
<li>http_client.fetch被gen.Task封装起来</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>先说一下这个地方的改动。<span style="color:red"><strong>v2.1.0版本并没有改动任何已有的代码，仅仅是添加了gen.py模块</strong></span>，<a href="https://github.com/tornadoweb/tornado/commit/e4ead597956457aada766b09d624a3d9f7b888d9">该commitz在这里</a>。我觉得这算是比较厉害的地方了</p>
<p>回顾这里用到的知识点，毫无疑问，Tornado里面最核心的yield终于在这个版本上场了。原来http_client.fetch是需要传入一个callback回调函数进行回调的。那么被gen.Task封装之后，这个回调函数不存在了，可以认为这里是gen.Task自己内部传入了一个回调函数。而只要是函数用到了yield关键字，那么它就是一个生成器对象。生成器对象有两个基本的特性,执行get()并不会立即开始执行、执行send后遇到yield会被暂停</p>
<p>考虑到上面说的gen.py是一个很独立的函数，并没有改动任何已有的代码。那么gen.engine装饰器肯定对get()执行了初始化并执行了send(None)让它开始运行起来。可是遇到yield会停止。同时上面的语义是再次恢复后以前http_client.fetch传递给回调函数的值需要赋值给response变量，生成器的send方法是可以做到这一点的，这里可能并不太好理解。</p>
<p>现在对功能进行划分</p>
<ul>
<li>gen.engine装饰器的主要作用是让生成器运行起来(调用后再执行send(None))</li>
<li>gen.Task的作用是将http_client.fetch 封装成Task对象，并传入一个回调，该回调使得send被再次调用</li>
<li>Runner 这是一个对用户无感知的类。连接gen.engine和gen.Task</li>
</ul>
<p>基础实现代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen)</span>:</span></div><div class="line">        self.gen = gen()</div><div class="line">        self.yielded = self.gen.send(<span class="keyword">None</span>)</div><div class="line">        self.yielded.start(self)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">result_callback</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.result = value</div><div class="line">        self.run()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            self.yielded = self.gen.send(self.result)</div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.yielded.start(self)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self, runner)</span>:</span></div><div class="line">        self.func(callback=runner.result_callback)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">engine</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> Runner(func)</div><div class="line">    <span class="keyword">return</span> inner</div></pre></td></tr></table></figure><br>可以看到gen.engine是一个非常简单的装饰器，将生成器传递给Runner并返回。在Runner里面它被执行send(None)。这个时候send(None)返回的是Task(http_client.fetch, “<a href="http://example.com&quot;)。">http://example.com&quot;)。</a></p>
<p>Task的封装也可以很简单，它仅仅存在一个start。传入runner并将http_client.fetch的回调设置为runner.result_callback</p>
<p>Runner呢，它负责了让生成器开始运行，并拥有result_callback函数，在callback里面，它调用了自身的run函数。在run里面再次调用send，此时send的值是http_client.fetch返回的值。如果没有触发StopIteration异常则表明再一次返回了Task对象。重复过程执行Task.start</p>
<p>这样它很巧妙的将callback驱动变成了yield驱动，要知道Task必定会调用callback函数，当callback被调用的时候就等同于赋值给了yield左边的变量</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面的代码并没有考虑异常情况，另外可能存在这种情况<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">    http_client = AsyncHTTPClient()</div><div class="line">    response1, response2 = <span class="keyword">yield</span> [gen.Task(http_client.fetch, url1),</div><div class="line">                                  gen.Task(http_client.fetch, url2)]</div></pre></td></tr></table></figure><br>我们希望两个Task同时执行，而不是等一个得到结果后，再去请求第二个结果。因此需要稍微复杂一些。我们给每一个Task标记一个独立的key，并修改Task的callback部分，让回调的时候知道属于哪一个Task对象。于此同时Task多了两个方法<code>get_result</code>和<code>is_ready</code>方法。在首次得到yielded对象后。如果判断是list对象，那么对该list再次进行封装得到Multi对象,它的is_ready会检查多个Task是不是都得到结果。在被执行回调后执行到Runner.run(),会先检查是否满足is_ready。如果不满足说明还有的Task并没有返回结果，直接返回。等待下一次被回调。均满足才得到全部结果执行send操作</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码非常独立，还是很有看头很精彩的。被gen.engine修饰一次意味着存在一个Runner，这个Runner配合着多个Task，主要可以看做Task和Runner互相调用的过程。Task每被回调一次则Runner.run()被调用一次，执行一次send操作，yield往下走一次返回下一个Task对象。另外这段代码里面还提供了很坑爹的Callback、Wait控制方式。思维有点奇葩，一般人不太会去用，实现倒是并不复杂</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tornado在2011年的2.1版本加入了gen.engine模块，该模块主要为了解决异步程序编写不够优雅的问题。力图让使用者离callback更远，这也是Tornado厉害的地方。本来内部各种事件处理，callback满天飞，可是在用户眼里，它那个class Handler(web.RequestHandler)下面get的写法和同步写法差不多嘛。和同步的写法一样，获得了更高的性能，我想这也是为什么Tornado能出彩的地方吧(本文代码基于v2.3.0)&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之StackContext</title>
    <link href="https://www.zoulei.net/2018/03/16/Tornado_StackContext/"/>
    <id>https://www.zoulei.net/2018/03/16/Tornado_StackContext/</id>
    <published>2018-03-16T08:14:25.000Z</published>
    <updated>2018-03-17T04:01:17.534Z</updated>
    
    <content type="html"><![CDATA[<p>yield这个关键字在2001年2.2版本的时候就出现了。2006加入yield.send功能。然而直到2006年2.5版本才看到使用在contextmanager上，tornado 2011年才用它实现了神奇的gen逻辑。令我没想到的是</p>
<ol>
<li>yield出现的这么早</li>
<li>yield厉害一点的应用(contentmanager)居然过了五年才加入到标准库。</li>
<li>tornado的1.0.0版根本和yield没有一毛钱关系</li>
<li>tornado最先引入yield居然并不是实现了gen</li>
</ol>
<p>yield最先在tornado里面展露头角是在<span style="color:red"><strong><a href="https://github.com/tornadoweb/tornado/commit/721e25d0acc68d751073261bec150ac12a9f88ab">这个commit</a></strong></span>里面。大神就是大神，虽然这个代码仅仅只有几十行。可是我觉得思路很新奇，膜拜😀(代码基于v1.0.0和v1.1.0)</p>
<a id="more"></a>
<p>建议打开该commit，先看一看它做了什么事情。除去测试用例，它改动的地方可谓非常少了</p>
<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>观察下面的代码(可以将tornado的源码在1.0.0版本和1.1.0版本切换发现不同，在1.0.0版本客户端无法得到响应，1.1.0版本客户端得到500错误)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">import</span> tornado.web</div><div class="line"><span class="keyword">import</span> tornado.httpserver</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @tornado.web.asynchronous</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        tornado.ioloop.IOLoop.instance().add_callback(self.callback)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self,*args)</span>:</span></div><div class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Error"</span>)</div><div class="line"></div><div class="line">application = tornado.web.Application(handlers=[(<span class="string">'/'</span>, Index)])</div><div class="line">tornado.httpserver.HTTPServer(application).listen(<span class="number">8888</span>)</div><div class="line">tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure><br>这是一个异步的http响应。在接受到请求之后执行get函数体，最终它将self.callback加入到IOLoop循环列表，get函数结束。因为存在asynchronous装饰器，所以并没有主动调用self.finish()。待IOLoop执行self.callback回调时。此时并函数内部触发了异常。<span style="color:red"><strong>但是这个异常已经和get函数没有任何关系，因此get函数无法捕获到这个异常</strong></span><br>对比一下get函数体自身触发异常。由web.RequestHandler._execute调用get函数。此时它将捕获异常并调用self._handle_request_exception.最简流程如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self, transforms, *args, **kwargs)</span>:</span></div><div class="line">    self._transforms = transforms</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        getattr(self, self.request.method.lower())(*args, **kwargs)</div><div class="line">        <span class="keyword">if</span> self._auto_finish <span class="keyword">and</span> <span class="keyword">not</span> self._finished:</div><div class="line">            self.finish()</div><div class="line">    <span class="keyword">except</span> Exception, e:</div><div class="line">        self._handle_request_exception(e)</div></pre></td></tr></table></figure><br>self._handler_request_exception的流程也比较简单输出异常调用栈。返回客户端500错误，该http流程结束</p>
<p>可是对于一个回调，它的异常由IOLoop捕获，然而可悲的是它捕获到异常却并不能确定是谁添加到IOLoop里面的，异常捕获之后是不是只用输出调用栈就好。所以需求出来了，对于凡是由get操作下面加入到IOLoop的回调，我们期待能和get的异常处理逻辑一致</p>
<h3 id="历史上这个问题是怎么处理的"><a href="#历史上这个问题是怎么处理的" class="headerlink" title="历史上这个问题是怎么处理的"></a>历史上这个问题是怎么处理的</h3><p>这肯定是一个非常常见的问题，当执行<code>ioloop.IOLoop.instance().add_callback</code>之后。callback函数触发的异常添加回调的函数无法感知。最容易想到的方法就是我们把callback整体加上异常捕捉逻辑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self,*args)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">                ...</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">                self._handle_request_exception(e)</div></pre></td></tr></table></figure><br>但是这么恶心的方法明显是不可取的。意味着我们每写一个回调逻辑都需要在外部加上try..except。在1.0.0版本提供了一个装饰器函数提供类似的功能async_callback,所以上面的写法只需要将<code>tornado.ioloop.IOLoop.instance().add_callback(self.callback)</code>变更成<code>tornado.ioloop.IOLoop.instance().add_callback(self.async_callback(self.callback))</code>就可以了。虽然方法很不好，可是临时解决了问题，在1.1.0版本就引入了StackContext逻辑，解决了这个问题</p>
<h3 id="预备知识Yield"><a href="#预备知识Yield" class="headerlink" title="预备知识Yield"></a>预备知识Yield</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_fn</span><span class="params">()</span>:</span></div><div class="line">    result = <span class="keyword">yield</span> <span class="number">1</span></div><div class="line">    print(<span class="string">"result of yueld: "</span>+result)</div><div class="line">    result2 = <span class="keyword">yield</span>  <span class="number">2</span></div><div class="line">    print(<span class="string">"result of 2nd yield: "</span> + result2)</div><div class="line">    <span class="keyword">return</span> <span class="string">'we are done'</span></div><div class="line"></div><div class="line">caller = gen_fn()</div><div class="line">x = caller.send(<span class="keyword">None</span>)</div><div class="line">print(x)</div><div class="line">y = caller.send(<span class="string">'joe'</span>)</div><div class="line">print(y)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    caller.send(<span class="string">"bob"</span>)</div><div class="line"><span class="keyword">except</span> StopIteration:</div><div class="line">    print()</div></pre></td></tr></table></figure>
<ol>
<li>对于一个生成器来说，调用它(gen())并不会立即被执行。只是生成了一个生成器对象</li>
<li>nex(g)等同于g.send(None)。所以对于生成器只需要掌握send函数就可以了</li>
<li>send(value)返回的是yield右边的值，同时value赋值给yield左边的对象，<span style="color:red"><strong>千万不要被第一次的send(None)误导，认为经过第一次send(None)后result的值为None</strong></span>,你可以在心目中将没一个yield划上竖线，运行到那里就返回，然后下一次send的值被赋值给yield左边</li>
<li>上例中<code>we are done</code>没有被打印，因为不断的被send后生成器会触发StopIteration异常。最终被except StopIteration所捕获。可是他并没有将捕获的值输出，因而没有被显示处理。同时python2不允许在生成器执行return，所以在tornado中经常看到raise gen.Return(value)这种写法，它实质就是触发StopIteration异常，然后被except捕获后得到值，完成传递过程，到了python3语法就直接允许执行return了</li>
</ol>
<h3 id="预备知识-with"><a href="#预备知识-with" class="headerlink" title="预备知识 with"></a>预备知识 with</h3><p>python有很多魔术方法(可以参考<a href="https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html">这篇文章</a>)。其中如果一个类存在<code>__enter__</code>和<code>__exit__</code>方法。那么当使用with语句之后。会执行<code>__enter__</code>后得到对象返回给<code>with as</code>后面的变量。在退出的时候执行<code>__exit__</code>方法，最常见的就是我们使用<code>with open() as f</code>去打开一个文件了，处理完成后自动关闭文件，避免了内存泄漏。仔细想一下，其实用装饰器是很容易实现的。可是with语句还有以一个很大的优点，Python的编码是基于缩进来决定代码块的，装饰器是作用在函数上，而with是当跳出它的缩进则执行<code>__exit__</code>(可能描述的不太好)，很多情况下with要比装饰器的写法优美很多。</p>
<p>将with和yield联合起来使用还真的是挺神奇的。from contextlib import contextmanager，该模块将with语句做到了装饰器的效果。比如计算一个with语句下面的执行时间<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">()</span>:</span></div><div class="line">    start = time.time()</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">yield</span></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        print(<span class="string">"elapsed time: &#123;&#125;"</span>.format(time.time() - start))</div><div class="line"></div><div class="line"><span class="keyword">with</span> timeit():</div><div class="line">    time.sleep(<span class="number">1</span>)</div></pre></td></tr></table></figure><br>作为不明白它实现的人，也能够很容易看出来。yield将timeit划分为了两部分。前面的相当于执行<code>__enter__</code>动作，后面的相当于执行<code>__exit__</code>动作。</p>
<p>想象一下它的内部contextmanager装饰器是如何实现的。首先被装饰的函数timeit是一个生成器。因此，在执行<code>__enter__</code>的时候只需要执行send(None)操作就能到达yield的右边并暂停，再<code>__exit__</code>的时候再次执行send(None)，此时执行到了finally语句并触发StopIteration异常，流程结束。整个过程可以这样认为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">contextmanager</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        g = func(*args,**kwargs)</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">w</span><span class="params">()</span>:</span></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">                g.send(<span class="keyword">None</span>)</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    g.send(<span class="keyword">None</span>)</div><div class="line">                <span class="keyword">except</span> Exception:</div><div class="line">                    print(<span class="string">"4"</span>)</div><div class="line">        <span class="keyword">return</span> w()</div><div class="line">    <span class="keyword">return</span> inner</div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        print(<span class="string">"1"</span>)</div><div class="line">        <span class="keyword">yield</span></div><div class="line">        <span class="keyword">raise</span> Exception(<span class="string">"E"</span>)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        print(<span class="string">"3"</span>)</div><div class="line"></div><div class="line"><span class="keyword">with</span> log():</div><div class="line">    print(<span class="string">"2"</span>)</div></pre></td></tr></table></figure><br>是否还是感觉相对比较简单呢</p>
<h3 id="StackContext的实现"><a href="#StackContext的实现" class="headerlink" title="StackContext的实现"></a>StackContext的实现</h3><p>在起因部分，解释了callback中会存在的问题(期待RequestHandler.get里面所有相关内容发生错误都会导致返回500错误给客户端)。1.0版本的解决方案就是给每个回调函数套上一个装饰器。触发错误的时候就可以返回500了，感觉不太好讲述这段天才般的代码了😕<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> contextlib</div><div class="line"></div><div class="line">_state = ()</div><div class="line"></div><div class="line"><span class="meta">@contextlib.contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">StackContext</span><span class="params">(context_factory)</span>:</span></div><div class="line">    <span class="keyword">global</span> _state</div><div class="line">    old_contexts = _state</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        _state = old_contexts + (context_factory,)</div><div class="line">        <span class="keyword">with</span> context_factory():</div><div class="line">            <span class="keyword">yield</span></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        _state = old_contexts</div><div class="line"></div><div class="line"><span class="meta">@contextlib.contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ErrorCapture</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">yield</span></div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> StackContext(ErrorCapture):</div><div class="line">    print(_state)</div><div class="line">    <span class="keyword">raise</span> Exception(<span class="string">"Error"</span>)</div><div class="line">print(_state)</div></pre></td></tr></table></figure><br>这个地方StackContext是一个工厂模式，它传入的参数context_factory也是一个被contextlib.contextmanager装饰的对象。在StackContext的内部它又执行了with语句来初始化我们的context_factory，emmm.这个其实和多层嵌套装饰器并没有太大的区别，它实现了什么效果呢，在调用with StackContext(context_factory)的时候将context_factory加入到老的里面。<span style="color:red"><strong>注意，当前的context_factory和1.0.0版本里面的async_callback效果是一样样的，在with的语句块下面，我们可以使用_state变量。当跳出with之后_state就被恢复到原来的样子</strong></span>。</p>
<p>那么我们该如何使用这个_state变量呢，注意到with语句进入的时候会加入context_factory，退出的时候会清除。这意味着在with下面的代码块里面我们可以安全的使用它<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(fn)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(callback, contexts)</span>:</span></div><div class="line">        <span class="keyword">with</span> contextlib.nested(*[i() <span class="keyword">for</span> i <span class="keyword">in</span> contexts]):</div><div class="line">            callback()</div><div class="line">    contexts = _state</div><div class="line">    result = functools.partial(wrapped, fn, contexts)</div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure><br>这里，我们添加一个装饰器。在IOLoop中所有需要添加回调的地方均由wrap包装起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     def add_callback(self, callback):</div><div class="line">         &quot;&quot;&quot;Calls the given callback on the next I/O loop iteration.&quot;&quot;&quot;</div><div class="line">-        self._callbacks.add(callback)</div><div class="line">+        self._callbacks.add(stack_context.wrap(callback))</div><div class="line">         self._wake()</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>那么，在它被调用的时候实际执行的是wrapped函数，它会先调用with contextlib.nested(*[i() for i in contexts]).此步骤恢复了with StackContext时期加入的对象(即人们常说的上下文)。对于异常捕获来说，就是能够正确的捕获callback的异常并且返回500给客户端。另外，最开始的时候捕获RequestHandle.get的异常是在_execute套上try…except,将他变动为with StackContext就好了。这里应该谨记下面两点</p>
<ul>
<li>Tornado的运行是单线程的,with StackContext运行的过程中不可能存在别的步骤另外去改变了_state的值(这个值很重要)</li>
<li>StackContext是可以进行嵌套的</li>
</ul>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>当然以上只是为了表述原理讲解的最简代码，实际上源码中略有不同。首先考虑多线程的情况，在单线程中_state的改动是很显然的，执行<code>with StackContext</code>即允许改动。在多线程中就不太一样了。多线程中如果也执行了<code>with StackContext</code>操作，那么有可能造成_state被改动。因此，_state被继承自thread.local对象。那么不同线程内的修改是互相独立的<br>其次如果一个函数已经被wrapped包装，那么就不必要再次进行包装了(想象一下递归调用add_callback)。对于不存在的<code>with StackContext</code>也需要考虑，如果执行contextlib.nested的参数为空，无疑是会报错的。<br>其他有的独立的运行的模块不希望被已存在的_state影响，因此独立设置了NullContext<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@contextlib.contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">NullContext</span><span class="params">()</span>:</span></div><div class="line">    old_contexts = _state.contexts</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        _state.contexts = ()</div><div class="line">        <span class="keyword">yield</span></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        _state.contexts = old_contexts</div></pre></td></tr></table></figure><br>如果不希望被_state干扰，那么在前面加上<code>with StackContext(NullContext)</code>。_state即被置为空。显然add_callback传入的contexts为空。在它被执行的时候，也和with语句没什么事情了</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>我最开始看到的应用是这个,<a href="https://gist.github.com/Hackforid/7130a5d59463186e217e">在Tornado里面使用Sqlalchemy</a>。默认Sqlalchemy存在sessionmaker一个工厂函数，它会确定如何生成一个session会话对象以供使用。默认的情况是使用线程id，这对于多线程环境非常非常方便。因为多线程web框架中每一个HTTP请求的处理都是在独立的线程内进行的，那么一个http处理生命周期对应一个sqlalchemy的session生命周期非常完美。<br>可是在Tornado这种单线程的框架中发生了变化，因为它不好确定每一个http的生命周期标识。StackContext给了我们方法，虽然起因是callback的异常处理，可是我们一样可以参照它的套路，在_execute执行期间写入变量，在单个http生命周期均可以访问变量，http完结后清除它。代码可以参考给出的gist链接</p>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>下面给一个整篇文章的代码总结<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">from</span> contextlib <span class="keyword">import</span> nested</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">    <span class="keyword">from</span> contextlib <span class="keyword">import</span> ExitStack, contextmanager</div><div class="line"></div><div class="line"><span class="meta">    @contextmanager</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">(*contexts)</span>:</span></div><div class="line">        <span class="keyword">with</span> ExitStack() <span class="keyword">as</span> stack:</div><div class="line">            <span class="keyword">for</span> ctx <span class="keyword">in</span> contexts:</div><div class="line">                stack.enter_context(ctx)</div><div class="line">            <span class="keyword">yield</span> contexts</div><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">StackContext</span><span class="params">(context_factory)</span>:</span></div><div class="line">    <span class="keyword">global</span> _state</div><div class="line">    old_contexts = _state</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        _state = old_contexts + (context_factory,)</div><div class="line">        <span class="keyword">with</span> context_factory():</div><div class="line">            <span class="keyword">yield</span></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        _state = old_contexts</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ErrorCapture</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">yield</span></div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">_state = ()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(fn)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(callback, contexts)</span>:</span></div><div class="line">        <span class="keyword">with</span> nested(*[i() <span class="keyword">for</span> i <span class="keyword">in</span> contexts]):</div><div class="line">            callback()</div><div class="line"></div><div class="line">    contexts = _state</div><div class="line">    result = functools.partial(wrapped, fn, contexts)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line"></div><div class="line">loop_list = []</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"WTF"</span>)</div><div class="line">    print(get_current_request_id())</div><div class="line"></div><div class="line"></div><div class="line">g = &#123;&#125;</div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ThreadRequestContext</span><span class="params">(**data)</span>:</span></div><div class="line">    <span class="keyword">global</span> g</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        g = data</div><div class="line">        <span class="keyword">yield</span></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        g.clear()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_request_id</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> g[<span class="string">'request_id'</span>]</div><div class="line"></div><div class="line"></div><div class="line">global_data = &#123;<span class="string">"request_id"</span>: <span class="number">12</span>&#125;</div><div class="line"><span class="keyword">with</span> StackContext(functools.partial(ThreadRequestContext, **global_data)):</div><div class="line">    <span class="keyword">with</span> StackContext(ErrorCapture):</div><div class="line">        loop_list.append(wrap(call_back))</div><div class="line">        print(get_current_request_id())</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> loop_list:</div><div class="line">    i()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yield这个关键字在2001年2.2版本的时候就出现了。2006加入yield.send功能。然而直到2006年2.5版本才看到使用在contextmanager上，tornado 2011年才用它实现了神奇的gen逻辑。令我没想到的是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;yield出现的这么早&lt;/li&gt;
&lt;li&gt;yield厉害一点的应用(contentmanager)居然过了五年才加入到标准库。&lt;/li&gt;
&lt;li&gt;tornado的1.0.0版根本和yield没有一毛钱关系&lt;/li&gt;
&lt;li&gt;tornado最先引入yield居然并不是实现了gen&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;yield最先在tornado里面展露头角是在&lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/tornadoweb/tornado/commit/721e25d0acc68d751073261bec150ac12a9f88ab&quot;&gt;这个commit&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;里面。大神就是大神，虽然这个代码仅仅只有几十行。可是我觉得思路很新奇，膜拜😀(代码基于v1.0.0和v1.1.0)&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之WSGI</title>
    <link href="https://www.zoulei.net/2018/03/16/tornado_wsgi/"/>
    <id>https://www.zoulei.net/2018/03/16/tornado_wsgi/</id>
    <published>2018-03-16T03:28:02.000Z</published>
    <updated>2018-03-16T07:39:45.556Z</updated>
    
    <content type="html"><![CDATA[<p>WSGI毕竟是Python社区官方认可的规范，可是这种规范在多线程多进程模式下实现很简单，不太适合单线程异步这种情况。鉴于此Tornado并没有按照这个框架去实现一个WSGI的web框架，可是它却提供了基本的兼容，1.允许Tornado的application对象转变成WSGI application。2. 允许WSGI application在tornado ioloop中执行，只是这一切都不是完美的，它仅仅提供了基本的兼容，效率和可用性得不到保证。因此个人还是感觉很鸡肋的</p>
<a id="more"></a>
<h3 id="回顾WSGI"><a href="#回顾WSGI" class="headerlink" title="回顾WSGI"></a>回顾WSGI</h3><p>wsgi由<a href="https://www.python.org/dev/peps/pep-0333/">PEP333</a>开始，在<a href="https://www.python.org/dev/peps/pep-3333/">PEP3333</a>得到增强。分为两部分，一部分为容器，另一部分为应用。应用的最简形式如下<br>传入environ基础环境字典(必须包含一些值)和回调函数，最终返回一个可迭代对线<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    status = <span class="string">'200 OK'</span></div><div class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</div><div class="line">    start_response(status, response_headers)</div><div class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</div></pre></td></tr></table></figure><br>对于容器。则是每接收到一个http请求则调用一次应用。这样的好处是容器和应用可以完全隔离，应用可以使用任意容器来执行</p>
<h3 id="Tornado-application转变成WSGI-application"><a href="#Tornado-application转变成WSGI-application" class="headerlink" title="Tornado application转变成WSGI application"></a>Tornado application转变成WSGI application</h3><p>实现效果如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado.web</div><div class="line"><span class="keyword">import</span> tornado.wsgi</div><div class="line"><span class="keyword">import</span> wsgiref.simple_server</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        self.write(<span class="string">"Hello, world"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    application = tornado.wsgi.WSGIApplication([</div><div class="line">        (<span class="string">r"/"</span>, MainHandler),</div><div class="line">    ])</div><div class="line">    server = wsgiref.simple_server.make_server(<span class="string">''</span>, <span class="number">8888</span>, application)</div><div class="line">    server.serve_forever()</div></pre></td></tr></table></figure></p>
<p>在Tornado里面application接受一个参数调用，传入Requests对象。调用的结果是最终生成header以及handler._write_buffer对象(会触发iostream的写事件，最终由IOLoop触发socket写操作)。因此虽然它执行了RequestsHandler._execute操作，实际并没有发生socket发送操作，我们可以从handler对象取得完整的HTTP回复报文。然后调用start_response和返回一个可迭代对象<br>可以看到重点就是从WSGI server传递的environ字典里面重组出一个Request对象(模拟到和httpserver模块中的HTTPRequest对象一样)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIApplication</span><span class="params">(web.Application)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=<span class="string">""</span>, **settings)</span>:</span></div><div class="line">        web.Application.__init__(self, handlers, default_host, transforms=[],</div><div class="line">                                 wsgi=<span class="keyword">True</span>, **settings)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></div><div class="line">        handler = web.Application.__call__(self, HTTPRequest(environ))</div><div class="line">        <span class="keyword">assert</span> handler._finished</div><div class="line">        status = str(handler._status_code) + <span class="string">" "</span> + \</div><div class="line">            httplib.responses[handler._status_code]</div><div class="line">        headers = handler._headers.items()</div><div class="line">        <span class="keyword">for</span> cookie_dict <span class="keyword">in</span> getattr(handler, <span class="string">"_new_cookies"</span>, []):</div><div class="line">            <span class="keyword">for</span> cookie <span class="keyword">in</span> cookie_dict.values():</div><div class="line">                headers.append((<span class="string">"Set-Cookie"</span>, cookie.OutputString(<span class="keyword">None</span>)))</div><div class="line">        start_response(status, headers)</div><div class="line">        <span class="keyword">return</span> handler._write_buffer</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPRequest</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure><br>可以看到重点就是从environ里面构建出一个兼容httpserver的HTTPRequest对象。另外由于IOLoop在这种情况下不允许使用，所以依赖IOLoop的异步特性也就不存在了。而且连同多线程的特性也不在存在。所以只是一个玩具罢了吧</p>
<h3 id="在Tornado中运行WSGI-application"><a href="#在Tornado中运行WSGI-application" class="headerlink" title="在Tornado中运行WSGI application"></a>在Tornado中运行WSGI application</h3><p>上面的是将tornado的应用转变成WSGI兼容，然后让WSGI的容器去运行。这一个是反过来，让tornado作为容器去运行WSGI应用。实现这样的效果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    status = <span class="string">"200 OK"</span></div><div class="line">    response_headers = [(<span class="string">"Content-type"</span>, <span class="string">"text/plain"</span>)]</div><div class="line">    start_response(status, response_headers)</div><div class="line">    <span class="keyword">return</span> [<span class="string">"Hello world!\n"</span>]</div><div class="line"></div><div class="line">container = tornado.wsgi.WSGIContainer(simple_app)</div><div class="line">http_server = tornado.httpserver.HTTPServer(container)</div><div class="line">http_server.listen(<span class="number">8888</span>)</div><div class="line">tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>
<p>tornado.httpserver.HTTPServer会调用函数并传入一个Request对象。<span style="color:red"><strong>刚好和上面的过程相反</strong></span>。将Request对象分割为<code>environ</code>和<code>start_response</code>。直接贴1.0.0的原始代码吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIContainer</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, wsgi_application)</span>:</span></div><div class="line">        self.wsgi_application = wsgi_application</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, request)</span>:</span></div><div class="line">        data = &#123;&#125;</div><div class="line">        response = []</div><div class="line">        <span class="comment"># 将status和headers放入字典中,后续调用则写入body</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></div><div class="line">            data[<span class="string">"status"</span>] = status</div><div class="line">            data[<span class="string">"headers"</span>] = response_headers</div><div class="line">            <span class="keyword">return</span> response.append</div><div class="line">        <span class="comment"># wsgi app最终返回可迭代对象作为body</span></div><div class="line">        app_response = self.wsgi_application(</div><div class="line">            WSGIContainer.environ(request), start_response)</div><div class="line">        response.extend(app_response)</div><div class="line">        body = <span class="string">""</span>.join(response)</div><div class="line">        <span class="keyword">if</span> hasattr(app_response, <span class="string">"close"</span>):</div><div class="line">            app_response.close()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">raise</span> Exception(<span class="string">"WSGI app did not call start_response"</span>)</div><div class="line">        <span class="comment"># 组合成整个http报文</span></div><div class="line">        status_code = int(data[<span class="string">"status"</span>].split()[<span class="number">0</span>])</div><div class="line">        headers = data[<span class="string">"headers"</span>]</div><div class="line">        header_set = set(k.lower() <span class="keyword">for</span> (k,v) <span class="keyword">in</span> headers)</div><div class="line">        body = escape.utf8(body)</div><div class="line">        <span class="keyword">if</span> <span class="string">"content-length"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</div><div class="line">            headers.append((<span class="string">"Content-Length"</span>, str(len(body))))</div><div class="line">        <span class="keyword">if</span> <span class="string">"content-type"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</div><div class="line">            headers.append((<span class="string">"Content-Type"</span>, <span class="string">"text/html; charset=UTF-8"</span>))</div><div class="line">        <span class="keyword">if</span> <span class="string">"server"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</div><div class="line">            headers.append((<span class="string">"Server"</span>, <span class="string">"TornadoServer/0.1"</span>))</div><div class="line"></div><div class="line">        parts = [<span class="string">"HTTP/1.1 "</span> + data[<span class="string">"status"</span>] + <span class="string">"\r\n"</span>]</div><div class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> headers:</div><div class="line">            parts.append(escape.utf8(key) + <span class="string">": "</span> + escape.utf8(value) + <span class="string">"\r\n"</span>)</div><div class="line">        parts.append(<span class="string">"\r\n"</span>)</div><div class="line">        parts.append(body)</div><div class="line">        <span class="comment"># 发送完成</span></div><div class="line">        request.write(<span class="string">""</span>.join(parts))</div><div class="line">        request.finish()</div><div class="line">        self._log(status_code, request)</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">environ</span><span class="params">(request)</span>:</span></div><div class="line">        hostport = request.host.split(<span class="string">":"</span>)</div><div class="line">        <span class="keyword">if</span> len(hostport) == <span class="number">2</span>:</div><div class="line">            host = hostport[<span class="number">0</span>]</div><div class="line">            port = int(hostport[<span class="number">1</span>])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            host = request.host</div><div class="line">            port = <span class="number">443</span> <span class="keyword">if</span> request.protocol == <span class="string">"https"</span> <span class="keyword">else</span> <span class="number">80</span></div><div class="line">        environ = &#123;</div><div class="line">            <span class="string">"REQUEST_METHOD"</span>: request.method,</div><div class="line">            <span class="string">"SCRIPT_NAME"</span>: <span class="string">""</span>,</div><div class="line">            <span class="string">"PATH_INFO"</span>: request.path,</div><div class="line">            <span class="string">"QUERY_STRING"</span>: request.query,</div><div class="line">            <span class="string">"REMOTE_ADDR"</span>: request.remote_ip,</div><div class="line">            <span class="string">"SERVER_NAME"</span>: host,</div><div class="line">            <span class="string">"SERVER_PORT"</span>: port,</div><div class="line">            <span class="string">"SERVER_PROTOCOL"</span>: request.version,</div><div class="line">            <span class="string">"wsgi.version"</span>: (<span class="number">1</span>, <span class="number">0</span>),</div><div class="line">            <span class="string">"wsgi.url_scheme"</span>: request.protocol,</div><div class="line">            <span class="string">"wsgi.input"</span>: cStringIO.StringIO(escape.utf8(request.body)),</div><div class="line">            <span class="string">"wsgi.errors"</span>: sys.stderr,</div><div class="line">            <span class="string">"wsgi.multithread"</span>: <span class="keyword">False</span>,</div><div class="line">            <span class="string">"wsgi.multiprocess"</span>: <span class="keyword">True</span>,</div><div class="line">            <span class="string">"wsgi.run_once"</span>: <span class="keyword">False</span>,</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> <span class="string">"Content-Type"</span> <span class="keyword">in</span> request.headers:</div><div class="line">            environ[<span class="string">"CONTENT_TYPE"</span>] = request.headers[<span class="string">"Content-Type"</span>]</div><div class="line">        <span class="keyword">if</span> <span class="string">"Content-Length"</span> <span class="keyword">in</span> request.headers:</div><div class="line">            environ[<span class="string">"CONTENT_LENGTH"</span>] = request.headers[<span class="string">"Content-Length"</span>]</div><div class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> request.headers.iteritems():</div><div class="line">            environ[<span class="string">"HTTP_"</span> + key.replace(<span class="string">"-"</span>, <span class="string">"_"</span>).upper()] = value</div><div class="line">        <span class="keyword">return</span> environ</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_log</span><span class="params">(self, status_code, request)</span>:</span></div><div class="line">        <span class="keyword">if</span> status_code &lt; <span class="number">400</span>:</div><div class="line">            log_method = logging.info</div><div class="line">        <span class="keyword">elif</span> status_code &lt; <span class="number">500</span>:</div><div class="line">            log_method = logging.warning</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            log_method = logging.error</div><div class="line">        request_time = <span class="number">1000.0</span> * request.request_time()</div><div class="line">        summary = request.method + <span class="string">" "</span> + request.uri + <span class="string">" ("</span> + \</div><div class="line">            request.remote_ip + <span class="string">")"</span></div><div class="line">        log_method(<span class="string">"%d %s %.2fms"</span>, status_code, summary, request_time)</div></pre></td></tr></table></figure></p>
<p>主要是将Requests转变成environ，传入给WSGI应用。最终根据应用的返回重组成一个HTTP回复报文字符串调用发送逻辑，流程完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WSGI毕竟是Python社区官方认可的规范，可是这种规范在多线程多进程模式下实现很简单，不太适合单线程异步这种情况。鉴于此Tornado并没有按照这个框架去实现一个WSGI的web框架，可是它却提供了基本的兼容，1.允许Tornado的application对象转变成WSGI application。2. 允许WSGI application在tornado ioloop中执行，只是这一切都不是完美的，它仅仅提供了基本的兼容，效率和可用性得不到保证。因此个人还是感觉很鸡肋的&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之web</title>
    <link href="https://www.zoulei.net/2018/03/15/tornado_web/"/>
    <id>https://www.zoulei.net/2018/03/15/tornado_web/</id>
    <published>2018-03-15T09:23:07.000Z</published>
    <updated>2018-03-16T03:25:03.691Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章讲解了httpserver。它最终传入的是一个函数，接受的是Request对象，这和Tornado所展示的Hello World有一些差距。tornado的web模块就是将它从一个函数变化成一个类对象，并且包含了基础的路由功能，最终实现类似与这样的Hello World(代码基于1.0.0版本)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> web</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> httpserver</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        self.write(<span class="string">b"Hello World"</span>)</div><div class="line"></div><div class="line">application = web.Application([</div><div class="line">    (<span class="string">r"/"</span>, MainHandler)</div><div class="line">])</div><div class="line"></div><div class="line">http_server = httpserver.HTTPServer(application)</div><div class="line">http_server.listen(<span class="number">8888</span>)</div><div class="line">ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="将handler-request回调封装为RequestHandler类和Application"><a href="#将handler-request回调封装为RequestHandler类和Application" class="headerlink" title="将handler_request回调封装为RequestHandler类和Application"></a>将handler_request回调封装为RequestHandler类和Application</h3><p>和上一篇的httpserver并没有太大的变动，传入的对象由单个函数变成了application对象，并且web模块有RequestHandler和Application类，能猜想到web模块提供了路由功能，对请求的HTTP。它先得到请求路径和HTTP方法。找到对应的类。调用对应的方法。由此写出以下最简代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, request, application)</span>:</span></div><div class="line">        self.request = request</div><div class="line">        self.application = application</div><div class="line">        self._write_chunk = <span class="string">b""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, chunk)</span>:</span></div><div class="line">        self._write_chunk += chunk</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></div><div class="line">        self.request.write(<span class="string">b"HTTP/1.0 200 OK\r\nContent-Length: %d\r\n\r\n%s"</span> % (</div><div class="line">            len(self._write_chunk), self._write_chunk))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self)</span>:</span></div><div class="line">        self.get()</div><div class="line">        self.finish()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers)</span>:</span></div><div class="line">        self.handlers = handlers</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, request)</span>:</span></div><div class="line">        <span class="comment"># 先从request得到访问host、url和method对handlers进行匹配</span></div><div class="line">        handler = self.handlers[<span class="number">0</span>][<span class="number">1</span>](request, self)</div><div class="line">        handler._execute()</div></pre></td></tr></table></figure></p>
<p>将所有的RequestHandler类均放置到Application下面。当它被tornado.httpserver调用传入request对象的时候会调用Application的<code>__call__</code>函数。因为self.handlers中，每一个handler均有对应的路由地址，毫无疑问，这个地方会存在一个匹配过程。因为调用<code>__call__</code>的时候request对象已经可以提取到host、port、url、header、body等各种信息，最常用的只需要使用host和url即可确定调用哪一个RequestHandler。匹配后对RestsHandler进行初始化,此时传入了request对象和Application对象本身，最后调用_execute完成整个过程的执行</p>
<h3 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h3><p>路由功能的实现主要依靠正则匹配。比如实现对博客地址的匹配<code>/(\d{4})/(\d{2})/(\d{2})/(.+?)</code>。分别表示年、月、日、主题，或者使用正则命名分组<code>/(?P&lt;year&gt;\d{4})/(?P&lt;month&gt;\d{2})/(?P&lt;day&gt;\d{2})/(?P&lt;theme&gt;.+?)</code>。那么我们只需要再添加的时候执行re.compile。在匹配的时候执行re.match即可。对于普通的不存在正则分组的情况，就不需要传入正则分组匹配的内容。否则像以下这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class BlogHandler(RequestHandler):</div><div class="line">        def get(self,year,month,day):</div><div class="line">                pass</div></pre></td></tr></table></figure></p>
<p>在Tornado里面它使用了URLSpec类来封装这个事情</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>和上一篇的httpserver中使用handler_request函数不同。本篇的web模块对它进行了进一步的封装。我们面对的编写主要的业务逻辑均是继承自RequestHandler对象。在上一章基本面对的还是直接对iostream进行写操作，写入header、写入cookies、写入etag、模板渲染这些都是没有直接提供的。web模块作为它的更高级别封装，它提供了这些功能。</p>
<ul>
<li>路由匹配</li>
<li>给RequestHandler对象暴露Application对象和Request对象</li>
<li>提供状态码、跳转、url参数、header、cookies、缓存头、模板渲染、CSRF、日志记录等功能</li>
<li>提供http请求生命周期内的各项hook事件prepare、on_finish、on_connection_close</li>
<li>提供最常用的辅助函数get_login_url、get_current_user等</li>
<li>基于RequestHandler继承出了一些其他对象，比如ErrorHandler、StaticFileHandler、RedirectHandler等。注意，这一些和Flask等web框架的用法不一样。在Flask中是直接return ErrorHandler()等等。可是在Tornado中最后执行的是RequestHandler._execute，它是不支持直接返回这一些对象的。比如跳转直接执行self.redirect即可。这一些继承对象应该使用Application.add_handler进行调用。配合url匹配规则，然后最终被调用ErrorHandler._execute等等</li>
</ul>
<p>web里面还存在一个装饰器函数asynchronous，这个装饰器在Tornado存在了很长时间，只是现在基本可以不使用它了。可是依旧很多人喜欢一言不合就带上它。用法是这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequestHandler</span><span class="params">(web.RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @web.asynchronous</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        http = httpclient.AsyncHTTPClient()</div><div class="line">        http.fetch(<span class="string">"http://friendfeed.com/"</span>, self._on_download)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_on_download</span><span class="params">(self, response)</span>:</span></div><div class="line">        self.write(<span class="string">"Downloaded!"</span>)</div><div class="line">        self.finish()</div></pre></td></tr></table></figure><br>产生的原因是最终web.RequestHandler._execute调用了get函数。get执行完http.fetch整个过程就完成了。只是http.fetch它并没有阻塞，最终的结果是加入了IOLoop的回调，_execute的默认逻辑是当get函数执行完毕后会立即调用self.finish表示请求流程结束。明显这不是我们需要的逻辑，正常逻辑是等待网页下载完毕后再返回内容，因此web.asynchronous的逻辑很简单。将get函数设置一个标志位<code>self._auto_finish = False</code>表明该函数不需要调用<code>self.finish()</code>操作，自然最后再手动调用finish就好了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章讲解了httpserver。它最终传入的是一个函数，接受的是Request对象，这和Tornado所展示的Hello World有一些差距。tornado的web模块就是将它从一个函数变化成一个类对象，并且包含了基础的路由功能，最终实现类似与这样的Hello World(代码基于1.0.0版本)&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; tornado &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; web&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; tornado &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; httpserver&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; tornado &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ioloop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(web.RequestHandler)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.write(&lt;span class=&quot;string&quot;&gt;b&quot;Hello World&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;application = web.Application([&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;r&quot;/&quot;&lt;/span&gt;, MainHandler)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;http_server = httpserver.HTTPServer(application)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;http_server.listen(&lt;span class=&quot;number&quot;&gt;8888&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ioloop.IOLoop.instance().start()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之httpserver</title>
    <link href="https://www.zoulei.net/2018/03/15/tornado_httpserver/"/>
    <id>https://www.zoulei.net/2018/03/15/tornado_httpserver/</id>
    <published>2018-03-15T03:37:29.000Z</published>
    <updated>2018-03-15T09:14:55.763Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado可以当做一个http客户端去发送请求，可以处理需要和客户端建立长连接的请求。可是Tornado最为知名的还是它作为一个HTTP web框架…,上一篇讲述了IOLoop的套路。本篇讲解一下如何将IOLoop和httpserver联系起来(本代码思路依据1.0.0版本)</p>
<a id="more"></a>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>本文的基本目标是实现这个需求<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> httpserver</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(request)</span>:</span></div><div class="line">    message = <span class="string">b"Hello World\n"</span></div><div class="line">    request.write(<span class="string">b"HTTP/1.0 200 OK\r\nContent-Length: %d\r\n\r\n%s"</span> % (</div><div class="line">        len(message), message))</div><div class="line">    request.finish()</div><div class="line"></div><div class="line">http_server = httpserver.HTTPServer(handle_request)</div><div class="line">http_server.listen(<span class="number">8888</span>)</div><div class="line">ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>
<h3 id="最简服务端"><a href="#最简服务端" class="headerlink" title="最简服务端"></a>最简服务端</h3><p>根据上一篇。我们可以想到当执行listen监听操作的时候，会创建一个监听socket.然后将处理函数添加到事件回调中。不考虑异常因素，最简单的是这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</div><div class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> EVENT_READ, EVENT_WRITE</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPServer</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handler)</span>:</span></div><div class="line">        self.handler = handler</div><div class="line">        self.io_loop = ioloop.IOLoop.instance()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port)</span>:</span></div><div class="line">        self.s = socket.socket()</div><div class="line">        self.s.setblocking(<span class="number">0</span>)</div><div class="line">        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</div><div class="line">        self.s.bind((<span class="string">'127.0.0.1'</span>, port))</div><div class="line">        self.s.listen(<span class="number">128</span>)</div><div class="line">        self.io_loop.add_handler(self.s.fileno(), EVENT_READ, self._handle)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_handle</span><span class="params">(self)</span>:</span></div><div class="line">        client_sock, _ = self.s.accept()</div><div class="line">        client_sock.send(<span class="string">b"HTTP/1.0 200 OK\r\nContent-Length: 12\r\n\r\nHello World\n"</span>)</div><div class="line">        client_sock.close()</div></pre></td></tr></table></figure><br>对于监听socket,当触发可读的时候意味有新的客户端连接进来了，此时调用回调进行accept得到交互socket连接。简单起见直接send发送一个简易的HTTP消息然后关闭socket</p>
<h3 id="封装Request对象"><a href="#封装Request对象" class="headerlink" title="封装Request对象"></a>封装Request对象</h3><p>从上面的示例中可以看到。它没有调用传入的request函数，因为socket对象并没有write和finish方法。此外，即使我们将socket的send和close当做write和finish。它还有一个巨大的缺陷。我们只是进行了发送，而没有对接收到的http报文进行任何处理。<br>一般而言，会从它的行首、头部、消息体得到某一些我们需要的内容，然后对内容进行处理，最终写入信息，过程结束。因此，封装一个Request对象是必须的，最后将封装的对象传入到handler函数以供使用。如何封装呢？我们只需要知道一个完整的HTTP报文即可以得到一个requests对象，而一个http报文又有明显的分隔符.例如下文这个请求报文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /docs/index.html HTTP/1.1</div><div class="line">Host: www.ipinfo.com</div><div class="line">Accept: image/gif, image/jpeg, */*</div><div class="line">Accept-Language: en-us</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)</div><div class="line">(blank line)</div></pre></td></tr></table></figure></p>
<p>获取流程如下。当读取到第一个<code>\r\n</code>即确定Reques Line部分，当读取到<code>\r\n\r\n</code>即确定Header部分，如果Header部分存在Content-Length则表示存在body部分，存在则继续读取Content-Length长度。如此下来单个HTTP报文读取完毕。可以构建这个过程，Requests Line读取完毕后—&gt;回调读取Header部分—&gt;回调读取Body部分—&gt;构建Request对象—&gt;回调handler函数，将Request对象传入。另外第一步可以省略,读取Header即包含Requests Line</p>
<p>可以看到对于一个socket对象,将它根据分隔符以及长度读取就能解析成单个http包，另外对于很多流协议也是如此。我们将socket封装一下。让它提供两个功能read_until、read_bytes。允许读取到分隔符后调用回调函数、读取到固定长度后调用回调函数。最简代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</div><div class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> EVENT_READ</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOStream</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, socket)</span>:</span></div><div class="line">        self.socket = socket</div><div class="line">        self.ioloop = ioloop.IOLoop.instance()</div><div class="line">        self.ioloop.add_handler(self.socket.fileno(), EVENT_READ, self._handler)</div><div class="line">        self._read_buffer = <span class="string">b""</span></div><div class="line">        self._read_delimiter = <span class="keyword">None</span></div><div class="line">        self._read_bytes = <span class="keyword">None</span></div><div class="line">        self._read_callback = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_handler</span><span class="params">(self)</span>:</span></div><div class="line">        data = self.socket.recv(<span class="number">1024</span>)</div><div class="line">        self._read_buffer += data</div><div class="line">        <span class="keyword">if</span> self._read_delimiter <span class="keyword">and</span> self._read_delimiter <span class="keyword">in</span> self._read_buffer:</div><div class="line">            result, self._read_buffer = self._read_buffer.split(self._read_delimiter)</div><div class="line">            self._read_callback(result)</div><div class="line">            self._read_delimiter = <span class="keyword">None</span></div><div class="line">            self._read_callback = <span class="keyword">None</span></div><div class="line">        <span class="keyword">elif</span> self._read_bytes <span class="keyword">and</span> len(self._read_buffer) &gt; self._read_bytes:</div><div class="line">            result = self._read_buffer[:self._read_bytes]</div><div class="line">            self._read_buffer = self._read_buffer[self._read_bytes:]</div><div class="line">            self._read_callback(result)</div><div class="line">            self._read_bytes = <span class="keyword">None</span></div><div class="line">            self._read_callback = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_until</span><span class="params">(self, delimiter, callback)</span>:</span></div><div class="line">        self._read_delimiter = delimiter</div><div class="line">        self._read_callback = callback</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_bytes</span><span class="params">(self, length, callback)</span>:</span></div><div class="line">        self._read_bytes = length</div><div class="line">        self._read_callback = callback</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.socket.send(data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></div><div class="line">        self.ioloop.ioloop.unregister(self.socket.fileno())</div><div class="line">        self.socket.close()</div></pre></td></tr></table></figure><br>对于创建的IOStream对象，它添加READ事件，将回调函数设置为self._handler。当使用read_until的时候将历史数据给callback函数调用。<br>再看一下HTTPConnect对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPConnection</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, io_stream, handler_callback)</span>:</span></div><div class="line">        self.io_loop = ioloop.IOLoop.instance()</div><div class="line">        self.stream = io_stream</div><div class="line">        self.handler_callback = handler_callback</div><div class="line">        self.stream.read_until(<span class="string">b'\r\n\r\n'</span>, self._parse_header)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parse_header</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="comment"># 忽略行首，全部当做header</span></div><div class="line">        request = Request(connect=self, header=data)</div><div class="line">        self.handler_callback(request)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.stream.write(data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></div><div class="line">        self.stream.close()</div></pre></td></tr></table></figure><br>显然，它传入的是IOStream对象，并且在初始化的时候就调用read_until读取HTTP Header部分内容。简单起见，这里只读取并没有解析。最后封装成Request对象。让handle_request函数调用。达到我们文章开头的目的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, connect, header)</span>:</span></div><div class="line">        self.connect = connect</div><div class="line">        self.header = header</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.connect.write(data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></div><div class="line">        self.connect.finish()</div></pre></td></tr></table></figure><br>将最开始的最简服务器部分稍微改动一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle</span><span class="params">(self)</span>:</span></div><div class="line">    client_sock, _ = self.s.accept()</div><div class="line">    stream = IOStream(client_sock)</div><div class="line">    HTTPConnection(stream, self.handler)</div></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>IOStream、HTTPConnection、Request、HTTPServer。其中暴漏给用户的几乎只有Request对象，从上面的分析中应该可以发现。将文件描述符加入事件，等待IOStream的全局_header进行回调，全局_header又针对各种情况(分隔符条件满足、长度条件满足)发起回调。同时<span style="color:red"><strong>如果不调用iostream.read_until等那么全局的_header就没有意义了</strong></span>。搞定IOStream后。立马在HTTPConnection里面调用<code>iostream.read_until</code>。被回调则表明HTTP头部接收完成。组装成Requests然后调用handle_request。</p>
<p>作用分工:<br>HTTPServer:     创建监听socket,传入http处理回调函数<br>IOStream:   提供通用TCP流解析，最重要的是提供了write、read_until、read_length，<span style="color:red"><strong>且可以传入回调</strong></span><br>Request:    将字符串解析成一个Request对象。便于简单的获取访问信息。如url、host、port、body等等<br>HTTPConnection:  将前三者联系起来,调用IOStream.read_until开启获取HTTP数据包的流程</p>
<p>另外本文简单起见，只注册了READ事件。对于send操作。同样是需要进行注册事件。等到WRITE事件触发才执行send操作，希望不要引起误解，另外本例中使用HTTP/1.0的逻辑，处理完成单个链接后直接关闭。对于HTTP/1.1来说要实现keep-alive只需要在finish的使用并不关闭链接，而是继续执行self.read_until(b’\r\n\r\n’,self._parse_header)继续等待处理下一个HTTP报文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tornado可以当做一个http客户端去发送请求，可以处理需要和客户端建立长连接的请求。可是Tornado最为知名的还是它作为一个HTTP web框架…,上一篇讲述了IOLoop的套路。本篇讲解一下如何将IOLoop和httpserver联系起来(本代码思路依据1.0.0版本)&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之IOLoop</title>
    <link href="https://www.zoulei.net/2018/03/14/tornado_ioloop/"/>
    <id>https://www.zoulei.net/2018/03/14/tornado_ioloop/</id>
    <published>2018-03-14T10:03:18.000Z</published>
    <updated>2018-03-15T03:21:18.382Z</updated>
    
    <content type="html"><![CDATA[<p>这是Tornado系列的开篇,Tornado作为异步web框架2010年发布1.0版本。可以说Python社区搞了这么多年，为了获得比多线程多进程更高的性能，经历了Twisted、Tornado、yield、gevent、yield from、asyncio。也不知道什么时候才是一个尽头~~。Tornado过了这么多年还算开发活跃(<a href="https://github.com/tornadoweb/tornado/graphs/contributors">一个大神扛起了一片天啊</a>)，不同于多线程模型的一潭死水，看它的代码你会发现它还是紧跟潮流的，而且有一点。它的内部虽然一直在变动，但是提供给用户的使用接口是很稳定的，后续就会发现这个坑有多大</p>
<a id="more"></a>
<p>截止目前最新版本的代码是4.5，排除测试总代码量大约为12000行。我个人喜欢看精简版本的代码，所以本文为1.0.0版本。总代码量为4200行，比较容易看懂。毕竟别人优化了八年，期待一个星期精读能搞明白各种工程优化是不现实的。</p>
<h3 id="IOLoop"><a href="#IOLoop" class="headerlink" title="IOLoop"></a>IOLoop</h3><p>说到异步非阻塞大多数人都知道是异步IO模型(select、poll、epoll、kqueue)。没错在阻塞模型中比如使用<code>socket.recv</code>它会主线程造成阻塞。这直接导致了在python中需要使用多线程或者多进程模型才能够同时处理多个请求。可是在异步模型中允许对文件描述符进行监听，操作系统提供功能，当文件的状态发生变化(可读、可写、异常)程序能够获得这一状态。对我们来说就是当明确知道某文件存在什么事件的时候去触发相应的处理函数。注意，这就是一个<span style="color:red"><strong>回调、回调、回调(重要的事情说三遍)</strong></span></p>
<p>可以把IOLoop当做一个停不下来的死循环，类似下面这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> bisect</div><div class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOLoop</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._callback = set()</div><div class="line">        self._timeout = []</div><div class="line">        self.ioloop = DefaultSelector()</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</div><div class="line">            cls._instance = cls()</div><div class="line">        <span class="keyword">return</span> cls._instance</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, fd, event, func)</span>:</span></div><div class="line">        self.ioloop.register(fd, event, func)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_handler</span><span class="params">(self, fd, event)</span>:</span></div><div class="line">        temp = ioloop.get_key(fd)</div><div class="line">        ioloop.unregister(fd)</div><div class="line">        ioloop.register(fd, event, temp.data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_callback</span><span class="params">(self, func)</span>:</span></div><div class="line">        self._callback.add(func)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_timeout</span><span class="params">(self, t, func)</span>:</span></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">_T</span>:</span></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, t, func)</span>:</span></div><div class="line">                self.t = t</div><div class="line">                self.callback = func</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></div><div class="line">                <span class="keyword">return</span> self.t &lt; other.t</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></div><div class="line">                <span class="keyword">return</span> self.t &gt; other.t</div><div class="line"></div><div class="line">        t = _T(t, func)</div><div class="line">        bisect.insort(self._timeout, t)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> self._callback.copy():</div><div class="line">                i()</div><div class="line">                self._callback.remove(i)</div><div class="line"></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> self._timeout.copy():</div><div class="line">                <span class="keyword">if</span> time.time() &gt; i.t:</div><div class="line">                    i.callback()</div><div class="line">                    self._timeout.remove(i)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">break</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> self.ioloop.select(timeout=<span class="number">0.2</span>):</div><div class="line">                k.data()</div></pre></td></tr></table></figure></p>
<p>你只需要记住以下几点</p>
<ol>
<li><span style="color:red"><strong>IOLoop是一个单例</strong></span></li>
<li>IOLoop提供了处理三种情况的方法，分别是回调形式(_callback)、定时器形式(_timeout)、网络IO(selectors)</li>
<li>最后是一个while 1的死循环</li>
</ol>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>正因为IOLoop是一个单例。所以所有的函数最终都通过add_callback、add_timeout、add_handler放置到了IOLoop下面，最终被执行start依次调用，再调用的过程中，这些函数又使用ioloop.IOLoop.instance().add_callback等不断的加入一些事件处理。导致形成了一个callback链条，让我们最终得到结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 代码为python3</span></div><div class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_WRITE, EVENT_READ</div><div class="line"><span class="keyword">import</span> socket</div><div class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</div><div class="line"></div><div class="line">done = <span class="keyword">False</span></div><div class="line">selector = DefaultSelector()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></div><div class="line">    parse = urlparse(url)</div><div class="line">    s = socket.socket()</div><div class="line">    s.setblocking(<span class="keyword">False</span>)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        s.connect((parse.hostname, <span class="number">80</span>))</div><div class="line">    <span class="keyword">except</span> BlockingIOError:</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    selector.register(s.fileno(), EVENT_WRITE, <span class="keyword">lambda</span>: connected(s, parse.path, parse.hostname))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(s, path, host)</span>:</span></div><div class="line">    selector.unregister(s.fileno())</div><div class="line">    s.send((<span class="string">'GET &#123;&#125; HTTP/1.0\r\nHost:&#123;&#125;\r\n\r\n'</span>.format(path, host)).encode())</div><div class="line">    buf = []</div><div class="line">    selector.register(s.fileno(), EVENT_READ, <span class="keyword">lambda</span>: readable(s, buf))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readable</span><span class="params">(s, buf)</span>:</span></div><div class="line">    <span class="keyword">global</span> done</div><div class="line">    chunk = s.recv(<span class="number">1024</span>)</div><div class="line">    <span class="keyword">if</span> chunk:</div><div class="line">        buf.append(chunk)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        done = <span class="keyword">True</span></div><div class="line">        selector.unregister(s.fileno())</div><div class="line">        print((<span class="string">b''</span>.join(buf)).decode())</div><div class="line">        s.close()</div><div class="line"></div><div class="line"></div><div class="line">get(<span class="string">"http://httpbin.org/ip"</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> done:</div><div class="line">    events = selector.select()</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> events:</div><div class="line">        k.data()</div></pre></td></tr></table></figure>    </p>
<p>如上例.当我们调用get()开始执行代码的时候它只是开启了第一步创建了一个socket链接并在selector中注册了一个事件，等待READ事件被触发，k.data()被调用，即connected函数被调用，发送数据之后再次注册READ事件。依然等待直到k.data()被调用，即readable被调用。最后直至数据读取完成。表示整个过程结束</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>观察IOLoop例子中的start死循环可以知道。它其实也是伴随着阻塞的，在<code>self.ioloop.select(timeout=0.2)</code>中如果持续0.2秒没有等待的IO事件发生，那么会阻塞0.2秒，看似0.2秒也不长，但其实非常大量的事件并不是IO事件，而是在self._callback集合中。因此从效率方面考虑添加_callback的时候触发IO事件，让select不再去阻塞那0.2秒，因此创建了一个管道对象来解决了这个问题，当添加的_callback的时候同时向管道写入一个字符。那么就不存在0.2秒的阻塞了</p>
<h3 id="应用一-PeriodicCallback"><a href="#应用一-PeriodicCallback" class="headerlink" title="应用一 PeriodicCallback"></a>应用一 PeriodicCallback</h3><p>ioloop.py下面有一个非常简单的PeriodicCallback类，它的作用是定期将callback加入到IOLoop的_timeout列表中。比如你需要每隔三十分钟去清理一次临时文件夹产生的垃圾文件等等。简易实现大概是这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicCallback</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval, func)</span>:</span></div><div class="line">        self.interval = interval</div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line">        timeout = time.time() + self.interval</div><div class="line">        IOLoop.instance().add_timeout(timeout, self.callback)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self)</span>:</span></div><div class="line">        self.func()</div><div class="line">        self.start()</div></pre></td></tr></table></figure><br>再执行start之后添加到了_timeout。待时间到达后执行一次然后再调用start，如此反复😳。最后达到了无限循环执行的效果</p>
<h3 id="应用二-自动重启"><a href="#应用二-自动重启" class="headerlink" title="应用二 自动重启"></a>应用二 自动重启</h3><p>对于web框架而言，在开发过程中当代码发生变更自动重启机制几乎是都必备的。在Flask中是主线程单独开了一个进程，在进程里面将主函数开一个线程运行。然后执行死循环进行代码变更检测。发现变更则进行进程退出操作。主线程捕获退出状态进行重启。示例代码可以<a href="/2016/07/25/werkzeug_note_requests_response_auto_realod/index.html#热重启实现原理">看这里</a></p>
<p>可以看到自动重启基本由三个部分组成。</p>
<ol>
<li>主代码正常执行</li>
<li>检测代码变更逻辑定期执行</li>
<li>检测到变更后重启程序</li>
</ol>
<p>对于第一个条件而言Tornado没什么，就是主线程正常操作，第二个条件就利用了上面说的PeriodicCallback，将检测函数定期执行就好。第三个条件使用os.execv重载整个进程。bingo,没有单独的开启线程，开启进程。单线程完成了自动重启的操作。最简代码应该是这样的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"><span class="keyword">import</span> ioloop</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> types</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(io_loop=None, check_time=<span class="number">500</span>)</span>:</span></div><div class="line">    io_loop = io_loop <span class="keyword">or</span> ioloop.IOLoop.instance()</div><div class="line">    modify_times = &#123;&#125;</div><div class="line">    callback = functools.partial(_reload_on_update, modify_times)</div><div class="line">    scheduler = ioloop.PeriodicCallback(callback, check_time, io_loop=io_loop)</div><div class="line">    scheduler.start()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_reload_on_update</span><span class="params">(modify_times)</span>:</span></div><div class="line">    <span class="keyword">for</span> module <span class="keyword">in</span> sys.modules.values():</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(module, types.ModuleType): <span class="keyword">continue</span></div><div class="line">        path = getattr(module, <span class="string">"__file__"</span>, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path: <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> path.endswith(<span class="string">".pyc"</span>) <span class="keyword">or</span> path.endswith(<span class="string">".pyo"</span>):</div><div class="line">            path = path[:<span class="number">-1</span>]</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            modified = os.stat(path).st_mtime</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> modify_times:</div><div class="line">            modify_times[path] = modified</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> modify_times[path] != modified:</div><div class="line">            os.execv(sys.executable, [sys.executable] + sys.argv)</div></pre></td></tr></table></figure><br>使用sys.modules查看所有已加载的模块。每500毫秒将文件改动时间和已有数据进行对比。如果不同则执行os.execv覆盖掉当前进程，后续该代码虽然为了跨平台逻辑上有变动。可是整体思路是没有改变的</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结而言IOLoop的逻辑还是很好理解的。它可以被认为是一个独立性非常强的模块。一个单例，整体是一个死循环提供三种情况的处理。在运行过程中不断的调用单例的成员函数，完成对一个事务(比如获得一个网页的内容)的处理。至于为什么没有被阻塞。每当要IO阻塞的时候(比如connect)就注册一个事件回调，然后继续运行不会阻塞的部分。等到事件完成再进行IO操作就不会阻塞了。从而达到整体非阻塞的效果</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Tornado系列的开篇,Tornado作为异步web框架2010年发布1.0版本。可以说Python社区搞了这么多年，为了获得比多线程多进程更高的性能，经历了Twisted、Tornado、yield、gevent、yield from、asyncio。也不知道什么时候才是一个尽头~~。Tornado过了这么多年还算开发活跃(&lt;a href=&quot;https://github.com/tornadoweb/tornado/graphs/contributors&quot;&gt;一个大神扛起了一片天啊&lt;/a&gt;)，不同于多线程模型的一潭死水，看它的代码你会发现它还是紧跟潮流的，而且有一点。它的内部虽然一直在变动，但是提供给用户的使用接口是很稳定的，后续就会发现这个坑有多大&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Python高级多线程并发</title>
    <link href="https://www.zoulei.net/2018/03/12/python_concurrent_futures_thread/"/>
    <id>https://www.zoulei.net/2018/03/12/python_concurrent_futures_thread/</id>
    <published>2018-03-12T10:49:33.000Z</published>
    <updated>2018-03-12T11:27:47.101Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程多进程当道的年代这个被称为高级并发的模块还是很令人惊艳的。concurrent.future模块的厉害之处在于封装了多线程、多进程、锁、队列到一起。这些细节使用者都不需要知道。四五行代码能实现以往二三十行实现的效果。而且多线程和多进程的使用方式完全一样，堪称完美杰作。可惜，现在已经是异步时代了，主要是因为tornado用到了它的Future模块。我就看看它大概是怎样实现的</p>
<a id="more"></a>
<p>来自官方文档的示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> concurrent.futures</div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"></div><div class="line">URLS = [<span class="string">'http://www.foxnews.com/'</span>,</div><div class="line">        <span class="string">'http://www.cnn.com/'</span>,</div><div class="line">        <span class="string">'http://europe.wsj.com/'</span>,</div><div class="line">        <span class="string">'http://www.bbc.co.uk/'</span>,</div><div class="line">        <span class="string">'http://some-made-up-domain.com/'</span>]</div><div class="line"></div><div class="line"><span class="comment"># Retrieve a single page and report the URL and contents</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url, timeout)</span>:</span></div><div class="line">    <span class="keyword">with</span> urllib.request.urlopen(url, timeout=timeout) <span class="keyword">as</span> conn:</div><div class="line">        <span class="keyword">return</span> conn.read()</div><div class="line"></div><div class="line"><span class="comment"># We can use a with statement to ensure threads are cleaned up promptly</span></div><div class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">    <span class="comment"># Start the load operations and mark each future with its URL</span></div><div class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">60</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</div><div class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</div><div class="line">        url = future_to_url[future]</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            data = future.result()</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</div><div class="line">            print(<span class="string">'%r generated an exception: %s'</span> % (url, exc))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'%r page is %d bytes'</span> % (url, len(data)))</div></pre></td></tr></table></figure>
<p>首先考虑一个问题。在多线程里面，一般我们直接<code>threading.Thread(target=)</code>,但是直接运行不会得到返回的结果的。这里就用到了<code>Future</code>对象。类似与装饰器，最终运行的函数被嵌套，结果被添加到<code>Future</code>对象上。你可以将<code>Future</code>当做一个及其简单的对象，就像下面这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.result = <span class="keyword">None</span></div><div class="line">        self._state = <span class="string">"PENDING"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._state = <span class="string">"FINISHED"</span></div><div class="line">        self.result = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.result</div></pre></td></tr></table></figure></p>
<p>因此最终最新的并非是原始的函数。此处被封装成了WorkItem对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerItem</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, future, fn, *args, **kwargs)</span>:</span></div><div class="line">        self.fn = fn</div><div class="line">        self.args = args</div><div class="line">        self.kwargs = kwargs</div><div class="line">        self.future = future</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            ret = self.fn(*self.args, **self.kwargs)</div><div class="line">            self.future.set_result(ret)</div><div class="line"></div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            self.future.set_result(e)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_worker</span><span class="params">(work_queue)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            work_item = work_queue.get(block=<span class="keyword">True</span>)</div><div class="line">            <span class="keyword">if</span> work_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                work_item.run()</div><div class="line">    <span class="keyword">except</span> BaseException:</div><div class="line">        traceback.print_exc()</div></pre></td></tr></table></figure></p>
<p>其次它能够允许对创建的线程数量进行控制max_client。这个也可以想到通过队列来控制，当submit创建任务的时候并不是直接调用threading.Thread创建一个全新的线程。而是仅仅把它加入到队列，判断当前线程数量是否小于最大数量。当然在线程中就是不断循环执行Work。<code>Future</code>、<code>WorkItem</code>、<code>_worker</code>都是影藏没有对用户暴露。真正对用户暴露的只有一个ThreadPoolExecutor,大概可以这样认为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_workers)</span>:</span></div><div class="line">        self.max_workers = max_workers</div><div class="line">        self._queue = Queue()</div><div class="line">        self._thread = set()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(self, fn, *args, **kwargs)</span>:</span></div><div class="line">        f = Future()</div><div class="line">        worker_item = WorkerItem(f, fn, *args, **kwargs)</div><div class="line">        self._queue.put(worker_item)</div><div class="line">        <span class="keyword">if</span> len(self._thread) &lt; self.max_workers:</div><div class="line">            t = Thread(target=_worker, args=(self._queue,))</div><div class="line">            t.daemon = <span class="keyword">True</span></div><div class="line">            t.start()</div><div class="line">        <span class="keyword">return</span> f</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._thread:</div><div class="line">            i.join()</div></pre></td></tr></table></figure>
<p>从上面可以看到每次submit后会得到一个<code>Future</code>对象。设想一下当线程执行得到结果后我们可以根据<code>Future</code>的状态轮询得到我们需要的结果。大概可以这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">1</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> future_to_url.copy().keys():</div><div class="line">            <span class="keyword">if</span> i._state == <span class="string">"FINISHED"</span>:</div><div class="line">                print(i.get_result())</div><div class="line">                future_to_url.pop(i)</div><div class="line">        <span class="keyword">if</span> len(future_to_url) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure></p>
<p><span style="color:red"><strong>但是可能作者觉得这种方式太low,效率太低。实现了一个as_completed函数，直接让理解难度提升一个数量级。。。。</strong></span></p>
<p>大概就是先生成了一个waiters对象(这个对象有threading.Event)，并将这些对象添加到所有的未完成的Futures中。任一对象完成则会触发事件的设置。这样阻塞被暂时取消，可以得到结果返回，代码注释如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_completed</span><span class="params">(fs, timeout=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        end_time = timeout + time.time()</div><div class="line"></div><div class="line">    fs = set(fs)</div><div class="line">    <span class="keyword">with</span> _AcquireFutures(fs):</div><div class="line">        <span class="comment"># 先挑选出所有已经有结果的Future</span></div><div class="line">        finished = set(</div><div class="line">                f <span class="keyword">for</span> f <span class="keyword">in</span> fs</div><div class="line">                <span class="keyword">if</span> f._state <span class="keyword">in</span> [CANCELLED_AND_NOTIFIED, FINISHED])</div><div class="line">        pending = fs - finished</div><div class="line">        <span class="comment"># 创建了一个waiter对象。该对象用于threading.Event。然后将自身添加到了所有的Futures上面</span></div><div class="line">        waiter = _create_and_install_waiters(fs, _AS_COMPLETED)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="comment"># 先依次返回已完成的Future</span></div><div class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> finished</div><div class="line"></div><div class="line">        <span class="keyword">while</span> pending:</div><div class="line">            <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                wait_timeout = <span class="keyword">None</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                wait_timeout = end_time - time.time()</div><div class="line">                <span class="keyword">if</span> wait_timeout &lt; <span class="number">0</span>:</div><div class="line">                    <span class="keyword">raise</span> TimeoutError(</div><div class="line">                            <span class="string">'%d (of %d) futures unfinished'</span> % (</div><div class="line">                            len(pending), len(fs)))</div><div class="line">            </div><div class="line">            <span class="comment"># 当Future被进行设置结果会触发threading.Event.set</span></div><div class="line">            <span class="comment"># 那么该处的阻塞就会被取消</span></div><div class="line">            waiter.event.wait(wait_timeout)</div><div class="line"></div><div class="line">            <span class="keyword">with</span> waiter.lock:</div><div class="line">                <span class="comment"># 又得到一批已完成的Futures</span></div><div class="line">                finished = waiter.finished_futures</div><div class="line">                waiter.finished_futures = []</div><div class="line">                <span class="comment"># 取消状态,等待下一次的set</span></div><div class="line">                waiter.event.clear()</div><div class="line">            </div><div class="line">            <span class="comment"># 依次返回并从pending队列中移出</span></div><div class="line">            <span class="keyword">for</span> future <span class="keyword">in</span> finished:</div><div class="line">                <span class="keyword">yield</span> future</div><div class="line">                pending.remove(future)</div><div class="line"></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> fs:</div><div class="line">            <span class="keyword">with</span> f._condition:</div><div class="line">                f._waiters.remove(waiter)</div></pre></td></tr></table></figure></p>
<p>多线程的方式相较多进程要简单很多。多进程的实现有机会再写续篇~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多线程多进程当道的年代这个被称为高级并发的模块还是很令人惊艳的。concurrent.future模块的厉害之处在于封装了多线程、多进程、锁、队列到一起。这些细节使用者都不需要知道。四五行代码能实现以往二三十行实现的效果。而且多线程和多进程的使用方式完全一样，堪称完美杰作。可惜，现在已经是异步时代了，主要是因为tornado用到了它的Future模块。我就看看它大概是怎样实现的&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的多线程锁</title>
    <link href="https://www.zoulei.net/2018/03/12/Python_Thread_Lock/"/>
    <id>https://www.zoulei.net/2018/03/12/Python_Thread_Lock/</id>
    <published>2018-03-12T06:16:13.000Z</published>
    <updated>2018-03-12T09:21:24.786Z</updated>
    
    <content type="html"><![CDATA[<p>多线程是个坑爹的课题，有多线程就有锁。Python中有低级线程模块_thread、再封装一下就是threading、再来一下就是<code>from concurrent.futures import ThreadPoolExecutor</code>。其中涉及到的锁大概有Lock、RLock、Condition、Semaphore、BoundedSeamphore、Event。这么多看起来怪吓人的，其实这么多的锁全部只是由Lock演化出来的</p>
<a id="more"></a>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p><code>Lock = _thread._allocate_lock</code> 这个是直接由最低级别的_thread直接引用过来的。创建锁的时候是处于未被锁定的状态。这应该是最容易被理解和使用的一种锁了。刚学习的时候铁定写过类似下面这种示例。本质原因是python中的原子操作是针对单条指令。而a+=1被翻译成了多条指令。执行过程中任何时刻可能被打断</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">global</span> a</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">        a += <span class="number">1</span></div><div class="line"></div><div class="line">t = [threading.Thread(target=change) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</div><div class="line">[i.start() <span class="keyword">for</span> i <span class="keyword">in</span> t]</div><div class="line">[i.join() <span class="keyword">for</span> i <span class="keyword">in</span> t]</div><div class="line">print(a)</div></pre></td></tr></table></figure>
<p>解决方法就是<span style="color:red"><strong>所有线程共享同一个锁，虽然锁有很多种，但是几乎都是这样暴露给用户使用的</strong></span>，这是大家都知道的。一个锁都好理解。如果有两个锁就不是那么好理解了，比如这个有点装逼的例子。交叉打印Hello和World</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">lock_a = Lock()</div><div class="line">lock_b = Lock()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        lock_a.acquire()</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line">        print(<span class="string">"Hello"</span>)</div><div class="line">        lock_b.release()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        lock_b.acquire()</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line">        print(<span class="string">"World"</span>)</div><div class="line">        lock_a.release()</div><div class="line"></div><div class="line">Thread(target=hello).start()</div><div class="line">Thread(target=world).start()</div></pre></td></tr></table></figure>
<h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><p>可重入锁允许线程获得锁之后该线程可以无数次的再次获得锁。看起来没什么用，大概也确实没啥用吧，不过考虑一下下面这种场景<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Change</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a = <span class="number">1</span></div><div class="line">        self.b = <span class="number">1</span></div><div class="line">        self.lock = RLock()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adda</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.lock:</div><div class="line">            self.a += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addb</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.lock:</div><div class="line">            self.b += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addab</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.lock:</div><div class="line">            self.adda()</div><div class="line">            self.addb()</div></pre></td></tr></table></figure><br>你有一个类。其中adda改变a,addb改变b.还提供方法addab同时调用前两者。如果没有可重入锁那么你将不得不把两个函数粘贴到addab下面。它的实现原理是获取锁的时候根据get_ident得到当前线程标识。如果和当前锁的标识一样则仅仅是给值加1，否则就尝试去获取锁。简要代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, get_ident</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RLock</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.lock = Lock()</div><div class="line">        self._owner = <span class="keyword">None</span></div><div class="line">        self._count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self)</span>:</span></div><div class="line">        me = get_ident()</div><div class="line">        <span class="keyword">if</span> self._owner == me:</div><div class="line">            self._count += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        rc = self.lock.acquire()</div><div class="line">        <span class="keyword">if</span> rc:</div><div class="line">            self._owner = me</div><div class="line">            self._count = <span class="number">1</span></div><div class="line"></div><div class="line">    __enter__ = acquire</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self._owner != get_ident():</div><div class="line">            <span class="keyword">raise</span> RuntimeError()</div><div class="line">        self._count -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> self._count == <span class="number">0</span>:</div><div class="line">            self._owner = <span class="keyword">None</span></div><div class="line">            self.lock.release()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></div><div class="line">        self.release()</div></pre></td></tr></table></figure>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>被称为条件变量，这个应该是很少被使用的。它允许传入一个锁，当满足条件的时候触发通知(可以看一下queue模块的实现，当get不到数据的时候就执行wait等待，新加入数据的时候执行notify通知唤醒)，这应该是它被称为条件变量的原因(感觉都有点牵强😕),和Lock以及RLock不同。这个东东主要是用来通知其他线程的。大概有两个方法wait(阻塞直到被通知)，notify(唤醒wait)。<br>实现的思路是所有的线程共享同一个锁A，同时有一个共用的锁列表。每当调用wait的时候生成一个新的锁放入锁列表，然后获得该锁，再释放锁A(因为wait必须在获得锁A才能调用，如果不释放则其他线程无法获得锁A)。最绝的来了，<span style="color:red"><strong>再次获得新生成的锁造成死锁</strong></span>。由此该线程被挂起。直到其他获得锁A的线程执行notify操作。将wait的锁释放。<br>实现代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._lock = RLock()</div><div class="line">        self._waiters = deque()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._lock.__enter__()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._lock.__exit__(*args)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">assert</span> get_ident() == self._lock._owner</div><div class="line">        waiter = Lock()</div><div class="line">        self._waiters.append(waiter)</div><div class="line"></div><div class="line">        waiter.acquire()</div><div class="line">        self._lock.release()</div><div class="line">        waiter.acquire()</div><div class="line">        self._lock.acquire()</div><div class="line">        <span class="keyword">del</span> waiter</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">assert</span> get_ident() == self._lock._owner</div><div class="line">        <span class="keyword">for</span> waiter <span class="keyword">in</span> self._waiters.copy():</div><div class="line">            waiter.release()</div><div class="line">            self._waiters.remove(waiter)</div></pre></td></tr></table></figure></p>
<p>这个东东吧其实不太适合被直接使用。但是网上还是有人硬生生凑了一个消费者生产者的例子出来做演示<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Producer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">            integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</div><div class="line">            <span class="keyword">with</span> self.condition:</div><div class="line">                self.integers.append(integer)</div><div class="line">                self.condition.notify()</div><div class="line">                time.sleep(<span class="number">0.5</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Consumer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.condition:</div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">                <span class="keyword">while</span> self.integers:</div><div class="line">                    integer = self.integers.pop()</div><div class="line">                    print(integer)</div><div class="line">                self.condition.wait()</div><div class="line"></div><div class="line">integers = []</div><div class="line">condition = Condition()</div><div class="line">Producer(integers, condition).start()</div><div class="line">Consumer(integers, condition).start()</div></pre></td></tr></table></figure><br>这个例子有个地方需要注意。notify和wait并不是一一对应的。不代表执行了notify，wait部分一定会被执行。所以如果消费者部分这样写会造成部分没有被处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Consumer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.condition:</div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">                self.condition.wait()</div><div class="line">                integer = self.integers.pop()</div><div class="line">                print(integer)</div></pre></td></tr></table></figure></p>
<h3 id="Semaphore-amp-BoundedSeamphore"><a href="#Semaphore-amp-BoundedSeamphore" class="headerlink" title="Semaphore &amp; BoundedSeamphore"></a>Semaphore &amp; BoundedSeamphore</h3><p>上面先介绍Condition是有原因的，因为多线程信号量和事件都是基于它生成的。信号量常用于限制对有限资源的访问。比如你有1000个线程，如果每一个线程都去创建数据库连接，那么数据库可能会崩。或者爬虫创建对网站的连接，太过凶残并不好，这个时候用信号量来处理就不错。</p>
<p>这里如果直接使用Lock来构建。那么一个锁同时只允许一个线程来获得显然是不达不到要求的。祭出刚才构建的Condition<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>:</span></div><div class="line">    <span class="comment"># value值用完了就被调用wait.只有notify能解除</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">1</span>)</span>:</span></div><div class="line">        self._lock = Condition()</div><div class="line">        self.value = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self._lock:</div><div class="line">            <span class="keyword">if</span> self.value == <span class="number">0</span>:</div><div class="line">                self._lock.wait()</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.value -= <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></div><div class="line">        self.value += <span class="number">1</span></div><div class="line">        self._lock.notify()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span><span class="params">(Semaphore)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">1</span>)</span>:</span></div><div class="line">        super(BoundedSemaphore, self).__init__(value=value)</div></pre></td></tr></table></figure></p>
<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>Event和Condition差不多。区别就是上面提到的，使用Condition，如果在单线程，那么当notify的时候是无法触发wait的，再调用wait线程会被阻塞。<span style="color:red"><strong>但是Event就支持在单线程使用。</strong></span>提供两个主要方法，set和wait。但是它并不需要先获得锁。使用好像更方便一点，实现如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._cond = Condition()</div><div class="line">        self._flag = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self._cond:</div><div class="line">            self._flag = <span class="keyword">True</span></div><div class="line">            self._cond.notify()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self._cond:</div><div class="line">            self._flag = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self._cond:</div><div class="line">            signaled = self._flag</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> signaled:</div><div class="line">                signaled = self._cond.wait()</div><div class="line">            <span class="keyword">return</span> signaled</div></pre></td></tr></table></figure></p>
<p>如果把刚才那个生产者消费者换到它上面来，大概是这个样子了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Producer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">            integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</div><div class="line">            self.integers.append(integer)</div><div class="line">            self.condition.set()</div><div class="line">            time.sleep(<span class="number">0.5</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Consumer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">while</span> self.integers:</div><div class="line">                integer = self.integers.pop()</div><div class="line">                print(integer)</div><div class="line">            self.condition.wait()</div><div class="line"></div><div class="line">integers = []</div><div class="line">condition = Event()</div><div class="line">Producer(integers, condition).start()</div><div class="line">Consumer(integers, condition).start()</div></pre></td></tr></table></figure><br>当然，没啥必要用这些比较低级的东东。能用通用高级数据结构就直接用，这样大家都比较好理解，总结就是只是给共享资源加锁用Lock、限制资源访问使用BoundedSeamphore，唤醒相关线程使用Event</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程是个坑爹的课题，有多线程就有锁。Python中有低级线程模块_thread、再封装一下就是threading、再来一下就是&lt;code&gt;from concurrent.futures import ThreadPoolExecutor&lt;/code&gt;。其中涉及到的锁大概有Lock、RLock、Condition、Semaphore、BoundedSeamphore、Event。这么多看起来怪吓人的，其实这么多的锁全部只是由Lock演化出来的&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 信号</title>
    <link href="https://www.zoulei.net/2018/03/06/linux_signal/"/>
    <id>https://www.zoulei.net/2018/03/06/linux_signal/</id>
    <published>2018-03-06T04:29:40.000Z</published>
    <updated>2018-03-06T04:35:15.156Z</updated>
    
    <content type="html"><![CDATA[<p>信号是进程间通信的一种方式,同时它是一种异步的形式。先注册信号处理函数，当接收到信号的时候回调该函数进程处理。信号在系统中以数字的形式标识。每个信号对应着一个处理函数</p>
<a id="more"></a>
<h3 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h3><p>来个python打印支持的信号<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> signal</div><div class="line"></div><div class="line">signals_to_names = &#123;</div><div class="line">    getattr(signal, n): n</div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> dir(signal)</div><div class="line">    <span class="keyword">if</span> n.startswith(<span class="string">'SIG'</span>) <span class="keyword">and</span> <span class="string">'_'</span> <span class="keyword">not</span> <span class="keyword">in</span> n</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> s, name <span class="keyword">in</span> sorted(signals_to_names.items()):</div><div class="line">    handler = signal.getsignal(s)</div><div class="line">    <span class="keyword">if</span> handler <span class="keyword">is</span> signal.SIG_DFL:</div><div class="line">        handler = <span class="string">'SIG_DFL'</span></div><div class="line">    <span class="keyword">elif</span> handler <span class="keyword">is</span> signal.SIG_IGN:</div><div class="line">        handler = <span class="string">'SIG_IGN'</span></div><div class="line">    print(<span class="string">'&#123;:&lt;10&#125; (&#123;:2d&#125;):'</span>.format(name, s), handler)</div></pre></td></tr></table></figure></p>
<p>因为平时用的少，而ubuntu上的<code>man 7 signal</code>的内容比较多，我只是在osx上看了一下singal的文档。它仅包含下列一些信号</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>默认动作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>终止进程</td>
<td>让程序挂起</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止进程</td>
<td>打断程序的执行</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>dump</td>
<td>程序</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>dump</td>
<td>非法指令</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>dump</td>
<td>陷阱</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>dump</td>
<td>打断程序</td>
</tr>
<tr>
<td>7</td>
<td>SIGEMT</td>
<td>dump</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>dump</td>
<td>浮点数异常</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止进程</td>
<td>杀死程序(不可修改)</td>
</tr>
<tr>
<td>10</td>
<td>SIGBUS</td>
<td>dump</td>
<td>总线错误</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>dump</td>
<td>段错误</td>
</tr>
<tr>
<td>12</td>
<td>SIGSYS</td>
<td>dump</td>
<td>调用不存在的系统调用</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>终止进程</td>
<td>给一个没有读的管道写数据</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>终止进程</td>
<td>实时计时器超时</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止进程</td>
<td>软中断信号</td>
</tr>
<tr>
<td>16</td>
<td>SIGURG</td>
<td>已废弃</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>SIGSTOP</td>
<td>停止进程</td>
<td>停止(不可修改)</td>
</tr>
<tr>
<td>18</td>
<td>SIGTSTP</td>
<td>停止进程</td>
<td>从键盘生成停止信号</td>
</tr>
<tr>
<td>19</td>
<td>SIGCONT</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>SIGCHLD</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>停止进程</td>
<td>后台进程尝试读取终端时触发</td>
</tr>
<tr>
<td>22</td>
<td>SIGTOU</td>
<td>停止进程</td>
<td>后台进程尝试写入终端时触发</td>
</tr>
<tr>
<td>23</td>
<td>SIGIO</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>终止进程</td>
<td>进程的cpu时间片到期(setrlimit)</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>终止进程</td>
<td>文件大小超过限制(setrlimit)</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTLRM</td>
<td>终止进程</td>
<td>虚拟时钟超时(setitimer)</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>终止进程</td>
<td>profil时钟超时(setitimer)</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>SIGINFO</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>SIGUSR1</td>
<td>终止进程</td>
<td>用户自定义信号1</td>
</tr>
<tr>
<td>31</td>
<td>SIGUSR2</td>
<td>终止进程</td>
<td>用户自定义信号2</td>
</tr>
</tbody>
</table>
<h3 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h3><p>信号可以产生自软件和硬件，硬件来说，我们最常用的<code>Ctrl+C</code>来终止一个程序的执行，软件层面就是经常使用<code>kill -9 pid</code>来强制终止一个程序。观察上表可以发现还有很多类似非法指令、陷入、段错误等等都是由操作系统触发反馈给应用程序。还有就是我们自己编写程序进行系统调用触发。比如python中常用的<code>signal.alarm</code></p>
<h3 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h3><p>观察信号表可以发现虽然有31个信号。但是默认动作只有终止进程、dump、停止进程三种。这算成了多对一的关系，多个信号对应一个处理结果。想想这其实是一种人为的约定。操作系统遇到一些异常的时候本可以直接卡擦掉进程。但是还是先知会你一声，万一程序作者觉得遇到这种情况还能再抢救一下那就不异常了。所以规定这么多信号id。还是为了方便编程的时候对信号进行分类处理。而且不仅仅约定俗成。后面还有两个自定义信号让你自己进行定义</p>
<p>信号处理基本有三种套路，默认、忽略、自定义。如果你觉得遇到异常你还可以再抢救一下那就自定义或者忽略。但是假如忽略掉所有的信号。管理人员可能就无法退出你的程序了。<span style="color:red"><strong>因此SIGKILL和SIGSTOP强制不允许被忽略或者自定义</strong></span>。所以<code>kill -9</code>就是一个大杀器</p>
<p>但是很多人并不被推荐用<code>kill -9</code>，而更多的人推荐用<code>kill -15</code>。原因是强制虽然强。但是这样编程人员别无选择。有的程序在意外退出前需要做一些清理工作，比如删掉临时文件啥的。当然，渣水平的作者怎么可能会去自定义处理SIGTERM信号┑(￣Д ￣)┍</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>比如tornado中可以使用信号机制记录响应时间超过阈值的栈帧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado.httpserver</div><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">import</span> tornado.web</div><div class="line"><span class="keyword">import</span> traceback</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_block</span><span class="params">(_, frame)</span>:</span></div><div class="line">    a = traceback.format_stack(frame)</div><div class="line">    print(<span class="string">""</span>.join(a))</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        time.sleep(<span class="number">10</span>)</div><div class="line">        self.write(<span class="string">"Hello, world"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    application = tornado.web.Application([</div><div class="line">        (<span class="string">r"/"</span>, MainHandler),</div><div class="line">    ])</div><div class="line">    http_server = tornado.httpserver.HTTPServer(application)</div><div class="line">    http_server.listen(<span class="number">8888</span>)</div><div class="line">    ioloop = tornado.ioloop.IOLoop.current()</div><div class="line">    ioloop.set_blocking_signal_threshold(<span class="number">1</span>, record_block)</div><div class="line">    ioloop.start()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>关于它的实现就比较简单了。先使用<code>signal.signal(signal.SIGALRM,callback)</code>注册信号回调函数。在ioloop主循环中每次事件完成后将实时计时器归零<code>signal.setitimer(signal.ITIMER_REAL, 0, 0)</code>后再重新开始计时。此处为什么不是用alarm而使用setitimer。因为前者只支持整数秒，后者支持浮点数</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pymotw.com/3/signal/index.html">signal — Asynchronous System Events</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号是进程间通信的一种方式,同时它是一种异步的形式。先注册信号处理函数，当接收到信号的时候回调该函数进程处理。信号在系统中以数字的形式标识。每个信号对应着一个处理函数&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.zoulei.net/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用BK树优化汉明距离查询</title>
    <link href="https://www.zoulei.net/2018/03/04/Postgresql_use_bktree_hamming/"/>
    <id>https://www.zoulei.net/2018/03/04/Postgresql_use_bktree_hamming/</id>
    <published>2018-03-04T02:45:47.000Z</published>
    <updated>2018-03-04T03:22:06.071Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2018/03/03/BKTree_VPTree/">上一篇</a> 介绍了BK树和VP树，并说明用它可以优化汉明距离的查询。用来处理重复图片的问题。本篇我们做出示例演示如何使用，最终的结果是100万条数据。相对于全表遍历的31秒下降到54毫秒。使用了正确的索引速度提升了五百多倍</p>
<a id="more"></a>
<h3 id="获得图片的simhash"><a href="#获得图片的simhash" class="headerlink" title="获得图片的simhash"></a>获得图片的simhash</h3><p>我们直接使用python的第三方库<a href="https://github.com/JohannesBuchner/imagehash">imagehash</a>。代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">import</span> imagehash</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_phash</span><span class="params">(file_path)</span>:</span></div><div class="line">    img = Image.open(file_path)</div><div class="line">    phash = imagehash.phash(img).hash.flatten()</div><div class="line">    phash_list = list(map(bool, phash))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum((<span class="number">2</span> ** k) * v <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(phash_list[<span class="number">1</span>:][::<span class="number">-1</span>]))</div></pre></td></tr></table></figure></p>
<p>需要注意的是。默认得到的phash是一个经过hex编码的字符串。这样会很长，而<span style="color:red"><strong>我们需要保存到数据库的数据是一个bigint类型。因此我们直接获得64位的np.array，</strong></span>将它转换成数字。因为int64中第一位是符号位。后63位是补码。如果直接将64位都转成正整数，很有可能会保存出错。从最方便的角度来说我们可以去掉第一位(实际上我测试了好多个。发现第一位基本都是1)。这样转换得到的数字就能直接存储到数据库了。</p>
<p>如果真的要模拟转换成bigint的效果。可以看我写的<a href="https://gist.github.com/ficapy/e7012d193c5ea85110a404c006ed7273">这个</a></p>
<h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><ul>
<li>来个示例</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--  创建表</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> int8tmp_2</div><div class="line">(</div><div class="line">	a <span class="built_in">bigint</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">-- 写入一百万条数据</span></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> int8tmp_2 <span class="keyword">SELECT</span> val</div><div class="line">                      <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">sqrt</span>(random()) :: <span class="built_in">NUMERIC</span> * <span class="number">9223372036854775807</span> * <span class="number">2</span> -</div><div class="line">                                   <span class="number">9223372036854775807</span> :: <span class="built_in">NUMERIC</span> <span class="keyword">AS</span> val</div><div class="line">                            <span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="number">1000000</span>)) t;</div><div class="line"><span class="comment">-- 创建一个查询函数</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> <span class="keyword">bit_count</span>(<span class="keyword">value</span> <span class="built_in">BIGINT</span>)</div><div class="line">  <span class="keyword">RETURNS</span> <span class="built_in">NUMERIC</span></div><div class="line"><span class="keyword">AS</span> $$ <span class="keyword">SELECT</span> <span class="keyword">SUM</span>((<span class="keyword">value</span> &gt;&gt; <span class="built_in">bit</span>) &amp; <span class="number">1</span>)</div><div class="line">      <span class="keyword">FROM</span> generate_series(<span class="number">0</span>, <span class="number">63</span>) <span class="built_in">bit</span> $$</div><div class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span> IMMUTABLE <span class="keyword">STRICT</span>;</div><div class="line"></div><div class="line"><span class="comment">-- 查询</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  a,</div><div class="line">  <span class="keyword">bit_count</span>(a # <span class="number">8192711222023195111</span>) <span class="keyword">AS</span> hd</div><div class="line"><span class="keyword">FROM</span> int8tmp_2</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">bit_count</span>(a # <span class="number">8192711222023195111</span>) &lt; <span class="number">4</span></div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hd;    </div><div class="line"></div><div class="line"><span class="comment">-- 结果大概这样</span></div><div class="line"><span class="comment">-- [2018-03-04 11:06:56] 1 row retrieved starting from 1 in 25s 403ms (execution: 25s 383ms, fetching: 20ms)</span></div></pre></td></tr></table></figure>
<ul>
<li>使用BK树创建索引</li>
</ul>
<p>我选择了这个扩展<a href="https://github.com/fake-name/pg-spgist_hamming">fake-name/pg-spgist_hamming</a>. 安装的套路是这样的(只支持PG9.6以上版本)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone .......</div><div class="line">cd bktree</div><div class="line">USE_PGXS=1 make</div><div class="line">USE_PGXS=1 make install</div></pre></td></tr></table></figure>
<p><span style="color:red"><strong>注意这个库同时提供了bktree和vptree,但是我没搞懂vptree,vptree的表现很奇怪,另外不能同时使用bktree和vptree。因为它们有一些重载的操作符重复了</strong></span></p>
<ul>
<li>使用流程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 启用扩展</span></div><div class="line"><span class="keyword">CREATE</span> EXTENSION bktree;</div><div class="line"><span class="comment">-- 创建</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> int8idx_2 <span class="keyword">ON</span> int8tmp_2 <span class="keyword">USING</span> spgist ( a bktree_ops );</div><div class="line"><span class="comment">-- 查询( &lt;-&gt; 运算符表示计算汉明距离, &lt;@()表示符合汉明距离小于N)</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  a,</div><div class="line">  a &lt;-&gt; <span class="number">8192711222023195111</span> <span class="keyword">AS</span> hd</div><div class="line"><span class="keyword">FROM</span> int8tmp_2</div><div class="line"><span class="keyword">WHERE</span> a &lt;@ (<span class="number">8192711222023195111</span>, <span class="number">4</span>)</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hd;</div><div class="line"><span class="comment">-- 结果大概是这样的</span></div><div class="line">[2018-03-04 11:18:25] 1 row retrieved starting from 1 in 44ms (execution: 31ms, fetching: 13ms)</div></pre></td></tr></table></figure>
<p>世界真美妙┑(￣Д ￣)┍</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/digoal/blog/blob/master/201708/20170804_01.md">海量数据,海明(simhash)距离高效检索(smlar) - 阿里云RDS PosgreSQL最佳实践</a><br><a href="https://stackoverflow.com/questions/46280722/bit-count-function-in-postgresql">bit_count function in PostgreSQL</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2018/03/03/BKTree_VPTree/&quot;&gt;上一篇&lt;/a&gt; 介绍了BK树和VP树，并说明用它可以优化汉明距离的查询。用来处理重复图片的问题。本篇我们做出示例演示如何使用，最终的结果是100万条数据。相对于全表遍历的31秒下降到54毫秒。使用了正确的索引速度提升了五百多倍&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>BK树和VP树</title>
    <link href="https://www.zoulei.net/2018/03/03/BKTree_VPTree/"/>
    <id>https://www.zoulei.net/2018/03/03/BKTree_VPTree/</id>
    <published>2018-03-03T09:17:02.000Z</published>
    <updated>2018-03-04T02:18:38.874Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一个项目需要用到simhash.获取图片的hash值并保存到数据库。在生成新的hash的时候和数据库进行比对。达到去重的效果。假如图片达到了一定数量级，那么每次查询会进行全表扫描，效率是比较低下的，而数据库默认的一些索引又无法达到这个需求，后来看到了BK树。记录一下</p>
<a id="more"></a>
<p>使用Python的库<a href="https://github.com/JohannesBuchner/imagehash">imageHash</a> 运算后会得到64bit长度的结果(最后使用了hex编码导致结果看起来很长)。如果两张图片的bit进行异或后不同的地方越小。说明两张图片越相似。度量这2个bit不相似程度被称之为汉明距离</p>
<p>这个距离它又满足以下性质(被称为Levenshtein)</p>
<ol>
<li>d(x, y) = 0 当且仅当 x=y  （Levenshtein距离为0 &lt;==&gt; 字符串相等）</li>
<li>d(x, y) = d(y, x)     （从x变到y的最少步数就是从y变到x的最少步数）</li>
<li>d(x, y) + d(y, z) &gt;= d(x, z)  （从x变到z所需的步数不会超过x先变成y再变成z的步数）</li>
</ol>
<h3 id="BK树"><a href="#BK树" class="headerlink" title="BK树"></a>BK树</h3><p>为了加速查找, 构建了这样一种树结构。</p>
<ol>
<li>任选一个节点当做根节点</li>
<li>插入节点的时候和根节点对比得到距离。如果该距离不存在则新建一个节点作为根节点的子节点。如果节点存在则获得节点作为根节点进行递归操作</li>
</ol>
<p>第二步的意义在于<strong>任何一个节点下面的元素对于该节点的距离都是相等的</strong>。构建就达到了这个效果。别的啥事没做。</p>
<p>查找过程。查找的原理主要依靠第三条性质<code>d(x, y) + d(y, z) &gt;= d(x, z)</code>.<br>假设我们有这样一个查询要求。需要查找字符串target距离不大于n的所有结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">设root为x, target为y</div><div class="line">d(root, target) + d(target, element) &gt;= d(root, element)</div><div class="line">d(target, element)的取值范围是[0, n]</div><div class="line">得到d(root, element) 的最大值是 n + d(root, target)</div></pre></td></tr></table></figure></p>
<p><strong>因此我们根据这个不等式实现了剪枝的效果</strong>。对于满足条件的元素。将其设置为根元素。递归得到所有满足条件的元素</p>
<h3 id="VP树"><a href="#VP树" class="headerlink" title="VP树"></a>VP树</h3><p>VP树和BK树原理差不多。优点是当需要查询的距离N更大的时候效率更高(具体原理我还不太了解。写的时候发现很多时候它的效率甚至是不及BK树的)。</p>
<p>BK树可以看出是一个多叉树。每个节点下面可以有多个节点。VP树不同，它是一个二叉树。根据我的需求。简单起见。每一个节点我设置了相同的阈值。距离小于阈值则放在左边，大于则放在右边。</p>
<p>查找的时候还挺尴尬的。根据上面说的<code>d(root, element) &lt;= n + d(root, target)</code>。当节点的阈值小于这个值的时候左右子节点都需要遍历。当节点阈值大于的时候就只需要遍历左边(达到剪枝的效果)</p>
<p>注意:  以上我都只考虑了添加，没有考虑修改和删除的事情。</p>
<p>Python版本代码实现如下</p>
<script src="//gist.github.com/ficapy/ed909648b184bc2fc1486ce90175d356.js?file=bk_tree.py"></script>
<script src="//gist.github.com/ficapy/ed909648b184bc2fc1486ce90175d356.js?file=vp_tree.py"></script>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.matrix67.com/blog/archives/333">编辑距离、拼写检查与度量空间：一个有趣的数据结构</a><br><a href="https://fribbels.github.io/vptree/writeup">VP Tree</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一个项目需要用到simhash.获取图片的hash值并保存到数据库。在生成新的hash的时候和数据库进行比对。达到去重的效果。假如图片达到了一定数量级，那么每次查询会进行全表扫描，效率是比较低下的，而数据库默认的一些索引又无法达到这个需求，后来看到了BK树。记录一下&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>开始GitLab CI/CD</title>
    <link href="https://www.zoulei.net/2017/12/25/GitLabCICD_quickstart/"/>
    <id>https://www.zoulei.net/2017/12/25/GitLabCICD_quickstart/</id>
    <published>2017-12-25T12:38:35.000Z</published>
    <updated>2017-12-26T01:34:46.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitLabCI-CD流程"><a href="#GitLabCI-CD流程" class="headerlink" title="GitLabCI/CD流程"></a>GitLabCI/CD流程</h3><p>gitlab如果没有和Docker很好的结合。那么它会是一个很平凡的产品。但是有了CI对比其他产品Gogs、github等它还算可堪一用。上一篇文章写了gitlab_ci.yml配置文件的一些参数的含义。本篇文章记录一下如何从零在Gitlab上完成简单的CI/CD流程。基础流程如下Build流程构建我们需要的镜像上传到镜像仓库。部署的时候从镜像仓库直接拉取重启容器<br><img src="https://ficapy.b0.upaiyun.com/blogimg/GitlabCI.jpg" alt="GitlabCI"><br><a id="more"></a></p>
<h3 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h3><p>这个没什么好说的。无脑apt就好了。安装完毕后需要将本地用户加入到Docker用户组。方便命令的执行。在生产环境下需要注意的是最好修改它的默认配置，/etc/docker/daemon.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;data-root&quot;: &quot;/data/docker&quot;,</div><div class="line">    &quot;registry-mirrors&quot;: [&quot;https://xxx.mirror.aliyuncs.com&quot;],</div><div class="line">    &quot;log-opts&quot;: &#123;</div><div class="line">        &quot;max-size&quot;: &quot;50m&quot;,</div><div class="line">        &quot;max-file&quot;: &quot;3&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>现在云主机都是低容量系统盘外加高容量挂载盘组成。修改一下默认的根目录会比较好</li>
<li>没个镜像源下载dockerhub镜像不明智啊</li>
<li>限定一下最大日志量总没错。否则时间太长日志多了也很烦人</li>
</ol>
<h2 id="2-搭建Docker镜像仓库"><a href="#2-搭建Docker镜像仓库" class="headerlink" title="2. 搭建Docker镜像仓库"></a>2. 搭建Docker镜像仓库</h2><p>我使用的是Vmware出品的<a href="https://github.com/vmware/harbor">Harbor</a>。安装中遇到了以下几个坑</p>
<ol>
<li>按照文档从源码安装失败。直接下载八百多兆的离线安装包安装好歹算是成功了</li>
<li>我将HTTPS放到负载均衡上面。实际请求到后端的是http协议。所以我将配置修改为http。但是登陆失败。查了下将common/config/registry/config.yml的token由http改成https可以登陆了。解决了这个然后还不能push…没办法。我将负载均衡改成TCP端口转发。直接将证书放在harbor上。可算是没毛病了</li>
<li>以前配置过一次Harbor。导致了历史遗留文件。再次安装结果并不会覆盖掉以前的配置也不会做任何提示。</li>
<li>配置文件里面我改了一下secretkey_path地址。结果无法使用，无奈又改回来了</li>
</ol>
<p>总结。在Harbor作为宣称的企业级Docker镜像工具。杀手级功能是异地复制，镜像验证。安全扫描啥的。如果只是要搞个基础的镜像仓库。最后想了想还不如折腾Gitlab的Docker仓库。说不定在权限上和Gitlab结合的更好</p>
<h2 id="3-注册Gitlab-runner"><a href="#3-注册Gitlab-runner" class="headerlink" title="3. 注册Gitlab-runner"></a>3. 注册Gitlab-runner</h2><p>这应该算是CI强大的地方了。它和Gitlab本身松耦合。客户端建立长连接和Gitlab服务器保持通信。当满足条件的时候由Gitlab对Runner进行调度。Gitlab-runner是使用Go编写的，便于部署。当Runner接收到请求的时候它会执行shell脚本。想象一下python界的fabric。依次执行Bash命令。Runner也是差不多的套路。多条Bash命令间是没有相关性的。比如你上一条执行<code>cd demo</code>下一条<code>pwd</code>得到的还是本地用户目录，并不是demo。</p>
<ol>
<li>启动gitlab-runner Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d --name gitlab-runner --restart always \</div><div class="line">  -v /var/gitlab-runner/config:/etc/gitlab-runner \</div><div class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</div><div class="line">  gitlab/gitlab-runner:latest</div></pre></td></tr></table></figure>
<p>顺便说一下。要是执行gitlab-runner看它的命令行参数还挺多。其实是自身设计的不太好。显得好像很复杂，很多命令需要被<a href="https://docs.gitlab.com/runner/commands/README.html#service-related-commands">废弃了</a>.它的使用其实还是很简单的。如果你需要看帮助。那么执行<code>gitlab-runner register -h</code>还有点用</p>
<ol>
<li>添加Runner</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker exec -it gitlab-runner gitlab-runner register -n --tag-list &quot;name&quot; \</div><div class="line">    -r &quot;token&quot; --name &quot;BigBrother&quot; -u https://gitlab.company.com \</div><div class="line">    --executor &quot;docker&quot; --docker-image &quot;default_image&quot; \</div><div class="line">    --docker-volumes /var/run/docker.sock:/var/run/docker.sock</div></pre></td></tr></table></figure>
<ul>
<li>n 表示非交互模式</li>
<li>tag-list表示该Runner的标签(单独的项目用单独的tag也挺好。互不干扰)</li>
<li>r 该项目的token</li>
<li>name 名称标识</li>
<li>u Gitlab地址</li>
<li>executor 和上面说的执行bash命令。有多种方式。无脑用docker挺好</li>
<li>docker-image executor选择了docker之后,需要选择默认的镜像</li>
<li>docker-volumes 这个是为了在docker里面<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html">使用Docker构建镜像</a></li>
</ul>
<p>以上两步完成后就能够在Gitlab后台看到正常状态的Runner了</p>
<h3 id="4-编写-gitlab-ci-yml文件"><a href="#4-编写-gitlab-ci-yml文件" class="headerlink" title="4. 编写.gitlab-ci.yml文件"></a>4. 编写.gitlab-ci.yml文件</h3><p>如果你有丰富的Docker使用经验，这一步实际上没有太大的问题。本例中我只是通过docker build构建了镜像。然后上传到仓库。需要部署的时候使用SSH连接到远程机器上使用<code>docker-compose up --build -d</code>更新程序<br>Demo项目目录如下。正常本地启动执行python main.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── README.md</div><div class="line">├── conf.py</div><div class="line">├── deploy</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── prod_env</div><div class="line">│   ├── docker-compose.yml</div><div class="line">│   └── stage_env</div><div class="line">├── main.py</div><div class="line">├── .gitlab-ci.yml</div><div class="line">└── requirements.txt</div></pre></td></tr></table></figure>
<p>Dockerfile如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">FROM ficapy/python35_alpine</div><div class="line"></div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">ENV PYTHONPATH=/app</div><div class="line"></div><div class="line">COPY ./requirements.txt /app/requirements.txt</div><div class="line">RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</div><div class="line"></div><div class="line">COPY . /app</div><div class="line"></div><div class="line">CMD [&quot;python&quot;, &quot;main.py&quot;]</div></pre></td></tr></table></figure>
<p>docker-compose.yml如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line"></div><div class="line">services:</div><div class="line">  Name:</div><div class="line">    image: registry.company.com/repos/projectname:$&#123;TAG&#125;</div><div class="line">    restart: always</div><div class="line">    env_file:</div><div class="line">      - $&#123;ENV&#125;_env</div></pre></td></tr></table></figure>
<p>.gitlab-ci.yml如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">image: ficapy/docker:latest</div><div class="line"></div><div class="line">variables:</div><div class="line">  SSH: &quot;Host xxxxx&quot;</div><div class="line"></div><div class="line">stages:</div><div class="line">  - build</div><div class="line">  - deploy</div><div class="line"></div><div class="line">build:</div><div class="line">  stage: build</div><div class="line">  only:</div><div class="line">    - master</div><div class="line">  tags:</div><div class="line">    - tag</div><div class="line">  script:</div><div class="line">      - export DOCKER_TAG=$(env TZ=&apos;Asia/Shanghai&apos; date -d @$(git log -n1 $CI_COMMIT_SHA --format=&quot;%at&quot;) +%Y_%m_%d_%H%M%S)</div><div class="line">      - echo $DOCKER_TAG</div><div class="line">      - docker login -u deploy -p $DOCKER_PWD registry.company.com</div><div class="line">      - docker build -t registry.company.com/repos/must_lower_case:$DOCKER_TAG -f deploy/Dockerfile .</div><div class="line">      - docker push registry.company.com/repos/must_lower_case:$DOCKER_TAG</div><div class="line"></div><div class="line">prod_deploy:</div><div class="line">  stage: deploy</div><div class="line">  only:</div><div class="line">    - master</div><div class="line">  tags:</div><div class="line">    - tag</div><div class="line">  when: manual</div><div class="line">  variables:</div><div class="line">    SERVER: ssh_name</div><div class="line">  before_script:</div><div class="line">    - export DOCKER_TAG=$(env TZ=&apos;Asia/Shanghai&apos; date -d @$(git log -n1 $CI_COMMIT_SHA --format=&quot;%at&quot;) +%Y_%m_%d_%H%M%S)</div><div class="line">    - echo $DOCKER_TAG</div><div class="line">    - eval $(ssh-agent -s)</div><div class="line">    - bash -c &quot;ssh-add &lt;(echo &apos;$SSH_PRIVATE_KEY&apos;)&quot;</div><div class="line">    - mkdir -p ~/.ssh</div><div class="line">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;$SSH&quot; &gt; ~/.ssh/config&apos;</div><div class="line">  script:</div><div class="line">    - ssh $SERVER &quot;mkdir -p ~/$CI_PROJECT_NAME || true&quot;</div><div class="line">    - rsync -r deploy $SERVER:~/$CI_PROJECT_NAME</div><div class="line">    - ssh $SERVER &quot;docker login -u deploy -p $DOCKER_PWD registry.company.com&quot;</div><div class="line">    - ssh $SERVER &quot;cd $CI_PROJECT_NAME/deploy &amp;&amp; TAG=$DOCKER_TAG ENV=prod docker-compose up --build -d&quot;</div><div class="line">  environment:</div><div class="line">    name: PROD</div></pre></td></tr></table></figure>
<p>整个过程看配置文件应该还是比较容易理解的。如果有些参数不太明白请查看前一篇gitlabci yml笔记。因为它只是个Demo。所以我让他在每次master分支提交的时候都进行触发。整个部署流程实际上就是使用了SSH远程连接之后操作docker-compose进行更新。过程中感觉让我比较难以决断的是如何搞一个好的TAG方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完成上述过程之后我做一个自我总结。所谓CI/CD不过是将我们懒得输入的命令组合形成文件。让它依次执行Test-&gt;Build-&gt;Deploy。该方案几乎使用了全套Docker.从gitlab-runner、build到镜像仓库到生产环境的部署。在项目比较多的时候它是有好处的。比如有十个项目需要更新。每个项目需要更新到多个环境下。那么使用这种自动化还是有优势的。如果就一两个项目，而且只需要更新到测试和生产环境。个人觉得fabric就够了。而且该方案有一个缺点就是部署速度较慢。Gitlab每次执行任务速度并不是想象的那么快。最后生成镜像，上传，再拉取到正式环境。如果镜像过大就更慢了。而如果不使用Docker镜像的方式。直接git pull拉取源码。再supervisorctl更新程序。时间基本是秒级的。在频繁更新的测试环境它可能更高效。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GitLabCI-CD流程&quot;&gt;&lt;a href=&quot;#GitLabCI-CD流程&quot; class=&quot;headerlink&quot; title=&quot;GitLabCI/CD流程&quot;&gt;&lt;/a&gt;GitLabCI/CD流程&lt;/h3&gt;&lt;p&gt;gitlab如果没有和Docker很好的结合。那么它会是一个很平凡的产品。但是有了CI对比其他产品Gogs、github等它还算可堪一用。上一篇文章写了gitlab_ci.yml配置文件的一些参数的含义。本篇文章记录一下如何从零在Gitlab上完成简单的CI/CD流程。基础流程如下Build流程构建我们需要的镜像上传到镜像仓库。部署的时候从镜像仓库直接拉取重启容器&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/blogimg/GitlabCI.jpg&quot; alt=&quot;GitlabCI&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>gitlabci yml 笔记</title>
    <link href="https://www.zoulei.net/2017/12/25/gitlabciyml_note/"/>
    <id>https://www.zoulei.net/2017/12/25/gitlabciyml_note/</id>
    <published>2017-12-25T04:17:56.000Z</published>
    <updated>2017-12-25T06:10:56.899Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容来自GitlabCI官方文档</p>
<h2 id="最基础的"><a href="#最基础的" class="headerlink" title="最基础的"></a>最基础的</h2><ul>
<li><p>jobs作为最顶级的元素。每个job至少包含一个script</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">job1:</div><div class="line">    script1: pwd</div></pre></td></tr></table></figure>
<p>  每个job的执行都是完全独立于其他的job</p>
</li>
</ul>
<a id="more"></a>
<h2 id="关于Docker-Image和Service的使用"><a href="#关于Docker-Image和Service的使用" class="headerlink" title="关于Docker Image和Service的使用"></a>关于Docker Image和Service的使用</h2><ul>
<li><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html">Using Docker Build</a>。主要讲述怎么在Docker里面使用Docker构建镜像。(最简单的是在注册Runner的时候共享/var/run/docker.sock)</li>
<li><p><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html">Using Docker images</a>。</p>
</li>
<li><p>注册的时候可以同时运行Services。这样在任务执行期间可以访问services</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo gitlab-runner register \</div><div class="line">    --url &quot;https://gitlab.example.com/&quot; \</div><div class="line">    --registration-token &quot;PROJECT_REGISTRATION_TOKEN&quot; \</div><div class="line">    --description &quot;docker-ruby-2.1&quot; \</div><div class="line">    --executor &quot;docker&quot; \</div><div class="line">    --docker-image ruby:2.1 \</div><div class="line">    --docker-postgres latest \</div><div class="line">    --docker-mysql latest</div></pre></td></tr></table></figure>
</li>
<li><p>service就是任务执行的时候能够访问到别的容器。比如Mysql、Postgresql、Redis、Rabbitmq啥的</p>
</li>
<li>访问service就和我们使用docker-compose差不多</li>
</ul>
<h2 id="其他的一些Top-Level设置"><a href="#其他的一些Top-Level设置" class="headerlink" title="其他的一些Top-Level设置"></a>其他的一些Top-Level设置</h2><ul>
<li>before_script: 在每个任务执行前执行.比如配置好ssh config</li>
<li>after_script: 在每个任务执行完成后执行.好像用处不大</li>
<li>stages: <span style="color:red"><strong> 每个任务都可以属于一个stage.同一个stage的job是并行的.但是只有一个stage所有都执行完毕才会执行下一个stage</strong></span></li>
<li>variables: 每个job都可以使用的环境变量。此处只能进行很简单的设置。比如我希望将当前日期用一个固定的格式表达(需要用date命令进行转换),在这里是行不通的</li>
<li>cache: </li>
</ul>
<h2 id="可选项最多的Jobs配置来了"><a href="#可选项最多的Jobs配置来了" class="headerlink" title="可选项最多的Jobs配置来了"></a>可选项最多的Jobs配置来了</h2><ul>
<li>jobs: 必须要有独立的名称</li>
</ul>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>script</td>
<td>定义shell脚本</td>
</tr>
<tr>
<td>image</td>
<td>使用的image.可以覆盖掉全局的</td>
</tr>
<tr>
<td>services</td>
<td>使用docker services,覆盖掉全局</td>
</tr>
<tr>
<td>stage</td>
<td>属于哪个阶段</td>
</tr>
<tr>
<td>variables</td>
<td>定义job的环境变量</td>
</tr>
<tr>
<td>only</td>
<td>只有满足某条件的时候才会被执行</td>
</tr>
<tr>
<td>except</td>
<td>满足某条件的时候不执行</td>
</tr>
<tr>
<td>tags</td>
<td>哪些Runners能够执行该任务</td>
</tr>
<tr>
<td>allow_failure</td>
<td>允许任务失败。正常情况下失败则会不进行后续步骤</td>
</tr>
<tr>
<td>when</td>
<td>定义任务什么时候执行。manual手动还挺有用┑(￣Д ￣)┍</td>
</tr>
<tr>
<td>artifacts</td>
<td>将构建生成的文件上传到gitlab。允许从gitlab后台进行下载</td>
</tr>
<tr>
<td>dependencies</td>
<td>配合artifacts使用。将生成的artifacts文件跨job使用    </td>
</tr>
<tr>
<td>cache</td>
<td>缓存文件给后续job使用</td>
</tr>
<tr>
<td>before_script</td>
<td>覆盖全局</td>
</tr>
<tr>
<td>after_script</td>
<td>覆盖全局</td>
</tr>
<tr>
<td>environment</td>
<td><a href="https://docs.gitlab.com/ee/ci/environments.html">文档</a></td>
</tr>
<tr>
<td>coverage</td>
<td>代码覆盖率设置</td>
</tr>
<tr>
<td>retry</td>
<td>如果失败则重试几次</td>
</tr>
</tbody>
</table>
<p>额外说明:</p>
<ol>
<li>environment配合deploy使用.部署的时候人为标记是部署到了哪个环境。方便在gitlab后台查看历史记录。同时方便错误的时候可以直接在gitlab后台回滚部署。其实这个参数不要也是可以的。添加上去只是更方便一点</li>
<li>artifacts和cache的区别.<ul>
<li>cache可以在全局使用也可以在job内部使用.但是artifacts只能在job内部使用</li>
<li><span style="color:red"><strong>特别注意</strong></span> cache跨越该项目的整个生命周期。跨越不同的pipeline.job开始之前会先解压已有的cache.而artifacts只会再单个pipeline周期。且某个stage创建之后。在后续的stage中才能够使用。artifacts会同时上传文件到gitlab(上传步骤还是必须的)。</li>
</ul>
</li>
</ol>
<h2 id="YAML特殊语法"><a href="#YAML特殊语法" class="headerlink" title="YAML特殊语法"></a>YAML特殊语法</h2><ul>
<li><p>用anchors(&amp;)、aliases(*)、merging(&lt;&lt;) 来简化编写(大多数情况下应该没啥用)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.job_template: &amp;job_definition  # Hidden key that defines an anchor named &apos;job_definition&apos;</div><div class="line">image: ruby:2.1</div><div class="line">services:</div><div class="line">    - postgres</div><div class="line">    - redis</div><div class="line"></div><div class="line">test1:</div><div class="line">&lt;&lt;: *job_definition           # Merge the contents of the &apos;job_definition&apos; alias</div><div class="line">script:</div><div class="line">    - test1 project</div><div class="line"></div><div class="line">test2:</div><div class="line">&lt;&lt;: *job_definition           # Merge the contents of the &apos;job_definition&apos; alias</div><div class="line">script:</div><div class="line">    - test2 project</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://docs.gitlab.com/ee/ci/yaml/README.html">Configuration of your jobs with .gitlab-ci.yml </a><br><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html">Using Docker images</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容来自GitlabCI官方文档&lt;/p&gt;
&lt;h2 id=&quot;最基础的&quot;&gt;&lt;a href=&quot;#最基础的&quot; class=&quot;headerlink&quot; title=&quot;最基础的&quot;&gt;&lt;/a&gt;最基础的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;jobs作为最顶级的元素。每个job至少包含一个script&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;job1:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    script1: pwd&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  每个job的执行都是完全独立于其他的job&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
</feed>
