<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邹雷</title>
  <subtitle>刨过的坑,自己慢慢来填</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zoulei.net/"/>
  <updated>2016-09-05T09:18:48.000Z</updated>
  <id>https://www.zoulei.net/</id>
  
  <author>
    <name>ficapy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask插件原理</title>
    <link href="https://www.zoulei.net/2016/09/05/2016-09-05/"/>
    <id>https://www.zoulei.net/2016/09/05/2016-09-05/</id>
    <published>2016-09-04T23:38:32.000Z</published>
    <updated>2016-09-05T09:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask的插件还挺多,用过的都知道比如flask-sqlalchemy,安装的时候是使用pip install flask-sqlalchemy，使用的时候就成了from flask.ext.sqlalchemy import SQLAlchemy。使用的是flask.ext而不是flask_sqlalchemy。感觉还有点牛掰啊-_-，不过仅仅是看起来高大上，并没有什么卵用。<a href="https://github.com/pallets/flask/issues/1135">在2016年4月13号正式被移出支持了</a>，已经直接发出不建议使用的警告。本文还是来炒一下现饭，看看它背后的逻辑</p>
<a id="more"></a>
<p>比如flask-sqlalchemy原本是使用from flask_sqlalchemy import [anything]使用的，被变成了from flask.ext.sqlalchemy import [anything]。这是一种对于import的hook。我们知道要导入一个模块，不使用import声明也是可以的，可以使用__import__函数，返回得到的也是一个模块对象</p>
<h2 id="import-hook"><a href="#import-hook" class="headerlink" title="import hook"></a>import hook</h2><p>下文简述，如果需要了解比较详细的资料可以查看后文给出的参考链接(python2和3的import机制是略有区别的)<br>import声明主要做了2件事情，查找模块，加载模块。我们说的hook发生在第一步查找模块。查找模块的步骤是</p>
<ol>
<li>查找sys.modules缓存</li>
<li>在sys.meta_path中依次执行finder对象,找到就返回自身,所有的都没有找到则会报错<br>注意:sys.path_hooks中的finder会被sys.meta_path调用执行(sys.meta_path和sys.path_hook都可以参与import hooks步骤)</li>
</ol>
<h2 id="精简版本实现"><a href="#精简版本实现" class="headerlink" title="精简版本实现"></a>精简版本实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtensionImporter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install</span><span class="params">(self)</span>:</span></span><br><span class="line">        sys.meta_path[:] = [x <span class="keyword">for</span> x <span class="keyword">in</span> sys.meta_path <span class="keyword">if</span> self != x] + [self]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_module</span><span class="params">(self, fullname, path=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fullname.startswith(<span class="string">'flask.ext.'</span>):</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_module</span><span class="params">(self, fullname)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> fullname <span class="keyword">in</span> sys.modules:</span><br><span class="line">            <span class="keyword">return</span> sys.modules[fullname]</span><br><span class="line"></span><br><span class="line">        modname = fullname.split(<span class="string">'.'</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        realname = <span class="string">'flask_'</span> +  modname</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            __import__(realname)</span><br><span class="line">        <span class="keyword">except</span> ImportError:</span><br><span class="line">            <span class="keyword">raise</span> ImportError(<span class="string">'No module named %s'</span> % fullname)</span><br><span class="line"></span><br><span class="line">        module = sys.modules[fullname] = sys.modules[realname]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">not</span> <span class="keyword">in</span> modname:</span><br><span class="line">            setattr(sys.modules[<span class="string">'flask.ext'</span>], modname, module)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> module</span><br></pre></td></tr></table></figure>
<p>ExtensionImporter是一个finder对象,当执行import flask.ext时会把它加入到sys.meta_path列表，后续的import都会先执行它，判断满足要求后就会使用__import__导入然后加入到sys.modules，这样就实现了flask.ext.sqlalchemy导入</p>
<p>为什么会被废除呢。下面是我猜测的。首先本来这个东西没有实质的作用，就是看着炫酷而已。我们可以认为所有的扩展导入都会使用flask.ext.xxx，但是这对第三方扩展库是有要求的，那就是包名必须为flask_xxx才行，我猜测有的第三方库未必遵守这个规则(否则exthook.py中也不会出现['flask_%s', 'flaskext.%s'flaskext.另外一种形式)，这就说明了有的作者使用了flaskextxxx这种包名。出现了第二种难免就会出现另外的。当使用者发现并非所有的第三方扩展都使用flask.ext导入的时候。社区也觉得没必要维持了，毕竟第一个写这个代码的人是不是因为刚刚了解了import机制，觉得很炫酷写上去的呢-_-,so，最后还是回到了原来的位置，直接使用import flask_sqlalchemy导入吧</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.python.org/3/reference/import.html#import-hooks">官方import hook文档</a><br><a href="https://github.com/Liuchang0812/slides/tree/master/pycon2015cn">pycon2015 import演讲</a><br><a href="https://github.com/mitsuhiko/flask-sqlalchemy">flask-sqlalchemy</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask的插件还挺多,用过的都知道比如flask-sqlalchemy,安装的时候是使用pip install flask-sqlalchemy，使用的时候就成了from flask.ext.sqlalchemy import SQLAlchemy。使用的是flask.ext而不是flask_sqlalchemy。感觉还有点牛掰啊-_-，不过仅仅是看起来高大上，并没有什么卵用。&lt;a href=&quot;https://github.com/pallets/flask/issues/1135&quot;&gt;在2016年4月13号正式被移出支持了&lt;/a&gt;，已经直接发出不建议使用的警告。本文还是来炒一下现饭，看看它背后的逻辑&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>tmux</title>
    <link href="https://www.zoulei.net/2016/09/02/tmux_note/"/>
    <id>https://www.zoulei.net/2016/09/02/tmux_note/</id>
    <published>2016-09-02T07:43:22.000Z</published>
    <updated>2016-09-04T07:33:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>自screen之后tmux早已身名远扬，然而这个东西对于一般人来说好像并没有什么卵用，好像还比较麻烦。这也是我以前的看法。主要原因就是iterm2已经非常完美了。iterm2的好用一定程度上掩盖了tmux的光辉。因为iterm2是开箱即用,tmux不配置不一定用的舒服。直到某一天我在youtube上看到了2个视频，我知道我该改改了:)<br><img src="https://ficapy.b0.upaiyun.com/blogimg/gotbletu_tmux.png" alt="gotbletu_tmux"><br>我个人也是刚入门,下面介绍一些基本知识，希望对读者有所帮助.</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>tmux分客户端和服务端，这个docker这种是很相似的，我们操作的只是针对客户端，服务端以守护进程运行，这样实现了我们退出后下次再进入依旧保持了运行状态</li>
<li>session:比如你在公司有个工作环境，在家里又是另外一个工作环境。这2个环境差别非常大。那么就使用2个不同的session</li>
<li>window:你在工作环境中要打开多个软件，聊天的、BT下载的、听歌的etc</li>
<li>pane:一个软件要分成多个区域输出</li>
<li>当然一般来说越少是越方便切换的。就个人来说一个session就够了,主要切换来自于window和pane</li>
<li>tmux主要来说最重要的就是对各个窗口的切换排列管理，各种键位绑定也是用于对窗口的切换</li>
</ul>
<h2 id="windows-pane基本设置"><a href="#windows-pane基本设置" class="headerlink" title="windows,pane基本设置"></a>windows,pane基本设置</h2><p>和vim一样tmux也是使用一个主要的prefix key，先输入prefix key之后再输入绑定的字母执行操作.下面就将我从多个地方copy来的配置解释一番-_-</p>
<p>设置成C-a,同时解绑原来的C-b,最后的bind a的作用就是:C-a本来是回到行首的快捷键，被tmux使用之后使用此设定变成了C-a-a到行首</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set -g prefix ^a&#10;unbind ^b&#10;bind a send-prefix</span><br></pre></td></tr></table></figure>
<p>之后就是对window和pane的快捷键设定，本人使用vim相似的快捷键设定。这个好像没啥好说的，比如hjkl在pane中移动,s、v分屏，使用&lt;、&gt;、+、_对pane进行大小的改变，使用C-u、C-d进行交换，使用q、C-q进行关闭pane和window，举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind k selectp -U&#10;bind -r &#60; resize-pane -L 10&#10;bind ^u swapp -U&#10;bind q killp</span><br></pre></td></tr></table></figure>
<p>使用-r(recursion)就能够输入一次&lt;之后马上多次输入&lt;、&gt;有效,这对于调整大小时是非常有用的。。。,没有被重写的配置基本都是非常好记的单词,c、n、w、d记这些都是毫不费力的</p>
<h2 id="鼠标、复制及清屏设置"><a href="#鼠标、复制及清屏设置" class="headerlink" title="鼠标、复制及清屏设置"></a>鼠标、复制及清屏设置</h2><p>如果你不进行其他设置可能用几下动一下鼠标上下翻一下，就会高呼WTF。毕竟完全不动鼠标的大神不多，我还是打开鼠标设置吧,这样也能同时使用鼠标进行上下滑动了，其次复制也和以前不一样了，特别是如果你分了2个竖向的pane,这样和以前一样用鼠标复制就出问题了，当然你可以用z(zoom)全屏当前的pane，然后用鼠标复制。然而一个vim党是不会这样做的T_T。下面是设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setw -g mouse on&#10;#set vi mode for copy mode&#10;setw -g mode-keys vi&#10;&#10;# more settings to make copy-mode more vim-like&#10;unbind [&#10;bind Escape copy-mode&#10;unbind p&#10;bind p paste-buffer&#10;bind -t vi-copy &#39;v&#39; begin-selection&#10;bind -t vi-copy &#39;y&#39; copy-selection&#10;&#10;# Buffers to/from Mac clipboard, yay tmux book from pragprog&#10;bind C-c run &#34;tmux save-buffer - | reattach-to-user-namespace pbcopy&#34;&#10;bind C-v run &#34;tmux set-buffer $(reattach-to-user-namespace pbpaste); tmux paste-buffer&#34;</span><br></pre></td></tr></table></figure>
<p>这样复制好像变得复杂了。。。需要先进入选择模式C-a-ESC-v选择需要复制的内容后再执行y复制到tmux的缓冲区，另外像tmux和vim这种的粘贴板是独立的,和osx系统的粘贴板不共通,如果要再复制到系统粘贴板，此时再使用C-a-C-c,好像是比较复杂啊。。你可以按住option再用鼠标选择也是直接复制到系统粘贴板，要让vim和tmux和系统粘贴板通用，你需要<code>brew install reattach-to-user-namespace</code>安装。另外iterm2其实是可以让他们共用的，下图选中Applications in terminal may access clipboard也能达到同样的效果，不过下面的参考文章有说有缺点-_-我就听了他的了<br><img src="https://ficapy.b0.upaiyun.com/blogimg/iterm_access_clipboard.png" alt="iterm_access_clipboard"></p>
<p>再就是配置重载和清屏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#bind -n C-l send-keys &#39;C-l&#39;&#10;bind -n C-k send-keys -R \; send-keys C-l \; clear-history&#10;# reload config (prefix r)&#10;bind r source ~/.tmux.conf \; display &#34;Configuration reloaded!&#34;</span><br></pre></td></tr></table></figure>
<p>就好像command+k完全清屏，tmux也可以，不过需要配置(这个完美清屏命令找了很久),-n表示不需要先按prefix key直接使用C-k就调用了，另外不要将C-l设置为清屏,会让TAB补全失效</p>
<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>配置一个好看的状态栏好像还是比较困难的,我比较偷懒就直接使用了<a href="https://github.com/erikw/tmux-powerline">tmux-powerline</a>和<a href="https://github.com/seebi/tmux-colors-solarized/blob/master/tmuxcolors-256.conf">tmux-colors-solarized</a>,下面是效果<br><img src="https://ficapy.b0.upaiyun.com/blogimg/tmux_statusbar.png" alt="tmux_statusbar"><br>注意配置powerline的时候可能需要在~/.zshrc中加入<code>PS1=&quot;$PS1&quot;&#39;$([ -n &quot;$TMUX&quot; ] &amp;&amp; tmux setenv TMUXPWD_$(tmux display -p &quot;#D&quot; | tr -d %) &quot;$PWD&quot;)&#39;</code>有的时候修改配置可能需要tmux kill-server后重新进入才能看到效果</p>
<p>在状体栏的配置会看到这种<code>set-option -g status-bg colour235</code>,colour235是什么鬼颜色。真是不好猜啊，可以单独开一个pane打印输出所有256种颜色，自己对比修改成喜欢的颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;0..255&#125; ; do&#10;    printf &#34;\x1b[38;5;$&#123;i&#125;mcolour$&#123;i&#125;\n&#34;&#10;done</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>我们设置好了之后可能需要在打开iterm之后就直接进入tmux,否则岂不是白忙活~(≧▽≦)/~啦啦啦，很简单,在iterm的设置页profiles→General→Send text at start中填入<code>tmux attach -t init || tmux new -s init</code>,更有用的是在我们远程到vps上的时候直接进入到tmux,设置一个别名如下<code>alias hg=&quot;ssh -t hg \&quot;bash -c &#39;tmux a -t init || tmux new -s init&#39;\&quot;&quot;</code>这样我们执行hg的时候就新建一个session或者连接到已有的session</p>
<p>如果我们本地开一个tmux，然后远程连接vps，vps再运行tmux，这会造成嵌套使用。特别是当你的prefix key还是一样的时候。。。悲催了，你所输入的快捷键只会被本地的tmux处理而不会被远程的tmux响应，要处理这个问题可以将2者的prefix key设置成不一样,比如一个为a另外一个为s。或者使用iterm单独开一个窗口，我更推荐后者,因为设置成不同的prefix key输入快了可能就输入混淆啦。</p>
<p>另外,使用了tmux显著增加了iterm2的耗电量,估计是我设置的那个状态栏显示上传下载流量导致的，每几秒刷新执行一次shell或许挺耗电.</p>
<p><a href="https://github.com/ficapy/dotfiles/blob/master/.tmux.conf">我的tmux配置</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://danielmiessler.com/study/tmux/">A tmux Primer</a><br><a href="https://www.youtube.com/playlist?list=PL5BE1545D8486D66D">gotbletu youtube playlist</a><br><a href="https://evertpot.com/osx-tmux-vim-copy-paste-clipboard/">Making the clipboard work between iTerm2, tmux, vim and OS X.</a><br><a href="http://superuser.com/questions/285381/how-does-the-tmux-color-palette-work">How does the tmux color palette work?</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自screen之后tmux早已身名远扬，然而这个东西对于一般人来说好像并没有什么卵用，好像还比较麻烦。这也是我以前的看法。主要原因就是iterm2已经非常完美了。iterm2的好用一定程度上掩盖了tmux的光辉。因为iterm2是开箱即用,tmux不配置不一定用的舒服。直到某一天我在youtube上看到了2个视频，我知道我该改改了:)&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/blogimg/gotbletu_tmux.png&quot; alt=&quot;gotbletu_tmux&quot;&gt;&lt;br&gt;我个人也是刚入门,下面介绍一些基本知识，希望对读者有所帮助.&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.zoulei.net/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>fasd和fzf</title>
    <link href="https://www.zoulei.net/2016/08/29/fasd&amp;fzf/"/>
    <id>https://www.zoulei.net/2016/08/29/fasd&amp;fzf/</id>
    <published>2016-08-29T13:55:24.000Z</published>
    <updated>2016-08-30T07:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>来2个日常使用命令行工具玩一玩，前一个是目录快速跳转，后一个是使用curses模糊查找</p>
<a id="more"></a>
<h2 id="fasd"><a href="#fasd" class="headerlink" title="fasd"></a><a href="https://github.com/clvv/fasd">fasd</a></h2><p>目录快速跳转工具挺多的autojump,z.我最开始用的是z，用长了感觉好像有bug,然后就换fasd.<code>好像</code>感觉好用那么一点点。这种工具原理都差不多。对你的历史输入进行统计，放入数据库。然后根据你输入的结果从数据库匹配达到快速cd的结果。安装好后直接输入fasd,就可以看到得分以及目录/文件。从它的原理也能可以看出来。它只能对有记录的快速切换(从你安装这个软件开始记录)。对于一个新的目录首次访问还是需要用cd。这个软件个常用的命令也就2个<br>z和v，分别代表切换目录和使用$EDITOR打开文件.所以:</p>
<ul>
<li>当你需要快速cd到以前打开过的目录用z,当你首次打开一个目录用cd(或者打开当前目录)；</li>
<li>当你需要用vim打开以前打开的文件用v,首次打开或确定目录vim</li>
<li>它真的很方便了,我看到有些人把它和fzf合起来一起用。我想了很久，除了装逼降低效率。我没想到有什么用</li>
</ul>
<h2 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a><a href="https://github.com/junegunn/fzf">fzf</a></h2><p>这款软件对于提高命令行效率也是很牛逼,而且看github上面的提交记录，依旧非常活跃(对于一个小白没什么比项目的活跃更重要了，因为它意味着你可能遇到的坑前人都可能已经趟过).而且这个项目的作者好像非常自信,项目说明里面居然只列举了优点，丝毫没有缺点.</p>
<p>这是一款安装上去就能让你眼前一亮的软件。比如Ctrl+R，完美替换了shell默认的历史记录功能,当输入指令的时候使用ctrl+T就能列出当前目录下所有的文件。当然这只是列举的2个最常用的功能,实际上，它的潜力远不止这么点，如果你用过osx上被人吹成神的alfred,那么fzf的概念可能和它有一定的相似性(取得一些结果,然后使用列表排除出来),举个例子,IDE中我们经常使用全局替换,用以下命令也能搞定<br><code>grep -rn &#39;python&#39;| fzf -m | awk -F &#39;:&#39; &#39;{print $1}&#39; | xargs -L 1 sed -i -e &#39;s/python/hello/g&#39;</code><br>效果如下<img src="https://ficapy.b0.upaiyun.com/blogimg/fzf_grep_sed.gif" alt="fzf_grep_sed"><br>解释一下，</p>
<ol>
<li>使用grep递归匹配当前目录含有python的文件,-r为递归，-n为显示行号。</li>
<li>使用fzf显示出来,-m为多行模式,使用tab为选择或者取消选择。</li>
<li>使用awk对选择的的结果进行处理,-F为选择分隔符，结果为多个目录</li>
<li>使用xargs对结果执行sed替换,-L为对每一个非空行执行后续命令(Call utility for every number non-empty lines read.  A line ending with a space continues to the next non-empty line)</li>
<li>另外grep的效率是非常高的,如果你直接用sed进行全局替换-_-文件一多还是很花费时间滴,比如这种<code>sed -i -- &#39;s/foo/bar/g&#39; **/*(D.)</code></li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然作者没有列举出来,我还是就我的个人感觉说一下</p>
<ol>
<li>蠢到家的匹配效果,你很难理解它是根据什么给你匹配的,放一张图<img src="http://ficapy.b0.upaiyun.com/blogimg/fzf_match.png" alt="fzf_match">，就这匪夷所思的匹配，你不得不使用^$!等额外的规则或者多输入一些字符然后上下键选择</li>
<li>看着炫酷,有时候没必要那么炫酷，比如使用z的时候tab如果有多个选择，这个时候如果你用fzf替代，他会使用curses全屏让你选择,其实整个过程已经多输入了好多字符.</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>fasd和fzf的很好用，而且它们都不需要任何配置都能让你感到高效!对于fzf如果你花时间配置是有特别多玩法的，可以参照官网<a href="https://github.com/junegunn/fzf/wiki/examples">fzf_examples</a>和<a href="https://www.youtube.com/playlist?list=PLqv94xWU9zZ2fMsMMDF4PjtNHCeBFbggD">gotbletu的视频教程</a>体验它的强大。另外，如果你喜欢这2个软件，那么你一定会喜欢<a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a>试一试吧~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来2个日常使用命令行工具玩一玩，前一个是目录快速跳转，后一个是使用curses模糊查找&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.zoulei.net/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>使用shell修改osx的CapsLock映射</title>
    <link href="https://www.zoulei.net/2016/08/29/use_shell_modifier_capslock_map_on_osx/"/>
    <id>https://www.zoulei.net/2016/08/29/use_shell_modifier_capslock_map_on_osx/</id>
    <published>2016-08-29T03:24:33.000Z</published>
    <updated>2016-08-29T03:49:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于命令行爱好者,很多人会选择将黄金键盘位置CapsLock替换成Ctrl,有些人选择仅仅是和默认的Ctrl进行替换，有些人更极端，相当于去掉CapsLock键增加一个Ctrl位置。我选择后者。有时候会想。假如需要输入大段文字的时候一直按住Shift岂不是蛋疼。搜索了下，网上真有这个问题。而且有人还给出了答案。我就转发一下好了-_-</p>
<ul>
<li>首先你要知道在你的<code>system preferences→keyboard→modifiers keys</code>是可以修改CapsLock映射<br>到Ctrl的</li>
<li>其次使用applescript可以编辑脚本对GUI界面进行操作(系统还自带一个Script Editor,不得不吐槽一下,脚本真不美观)</li>
<li>脚本编写后执行需要到安全设置里面添加许可权限(<code>system preferences→security&amp;privacy→accessibility</code>,由于我使用的是iTerm,将它加入就好了)</li>
</ul>
<p>最后奉上脚本(添加至~/.zshrc,!!!!仅对英文系统有效,中文估计改一下也能用)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caps () &#123;&#10;&#9;osascript &#62; /dev/null &#60;&#60;EOF&#10;    tell application &#34;System Preferences&#34;&#10;        reveal anchor &#34;keyboardTab&#34; of pane &#34;com.apple.preference.keyboard&#34;&#10;    end tell&#10;    tell application &#34;System Events&#34; to tell window 1 of process &#34;System Preferences&#34;&#10;        click button 1 of tab group 1&#10;        tell sheet 1&#10;            tell pop up button 4&#10;                click&#10;                delay 0.1&#10;                if value is &#34;&#8682; Caps Lock&#34; then&#10;                    click menu item 2 of menu 1&#10;                    log &#34;Change Caps Lock&#34;&#10;                else&#10;                    click menu item 1 of menu 1&#10;                    log &#34;Restore Caps Lock&#34;&#10;                end if&#10;            end tell&#10;            click button &#34;OK&#34;&#10;        end tell&#10;    end tell&#10;    quit application &#34;System Preferences&#34;&#10;EOF&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://superuser.com/questions/495956/controlling-modifier-key-behavior-via-the-terminal-on-mac">Controlling modifier key behavior via the terminal on mac</a><br><a href="http://apple.stackexchange.com/questions/103621/run-applescript-from-bash-script">Run AppleScript from bash script</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于命令行爱好者,很多人会选择将黄金键盘位置CapsLock替换成Ctrl,有些人选择仅仅是和默认的Ctrl进行替换，有些人更极端，相当于去掉CapsLock键增加一个Ctrl位置。我选择后者。有时候会想。假如需要输入大段文字的时候一直按住Shift岂不是蛋疼。搜索了下，网
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Docker配置静态博客</title>
    <link href="https://www.zoulei.net/2016/08/21/docker_static_blog/"/>
    <id>https://www.zoulei.net/2016/08/21/docker_static_blog/</id>
    <published>2016-08-21T01:29:29.000Z</published>
    <updated>2016-08-29T13:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先这是篇水文:),仅记录下这2天使用docker的情况。实际上和docker没什么关系,静态博客嘛,生成之后上传到vps然后上面放个nginx就好了，没什么需要操心的</p>
<a id="more"></a>
<p>步骤如下(服务端)：</p>
<ol>
<li>参照docker官方文档安装上docker,最耗时的就是这一步了，因为docker虽然发展几年了，可是还是处于不断完善中。连安装方式都不是简单的<code>apt-get install xx</code>搞定(另外现在docker支持的最低版本号是3.1,意味着openvz是无法使用的，因为openvz的内核版本号是2.6.32，且无法升级)</li>
<li>在你存放静态文件的目录下执行 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always -p 80:80 -v `pwd`:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>解释一下:</p>
<ul>
<li>d参数表示以detach,以后台进程形式一直运行</li>
<li><code>--restart=always</code>当容器因为异常退出甚至被reboot重启操作后无限自动重启</li>
<li>p参数，用过vagrant的比较好理解，虚拟机都有这么个玩意儿。端口映射</li>
<li>v参数。vagrant也有这个概念。文件夹共享</li>
<li>至于共享的目录,那是因为容器内nginx默认的配置既如此。默认文件位置为/usr/share/nginx/html。这个地方前后的地址必须都是绝对地址。感觉要是能用相对就好了</li>
<li>如果你要去容器内看看它nginx的配置啥的执行(exit退出)<code>docker run -it --restart=always -p 80:80 -v `pwd`:/usr/share/nginx/html nginx /bin/bash</code></li>
</ul>
<p>至于客户端,用rsync同步就好了。我用的是hexo静态博客生成器。使用<a href="https://github.com/hexojs/hexo-deployer-rsync">https://github.com/hexojs/hexo-deployer-rsync</a>这个配合ssh config配置一下就好了。很简单O_o</p>
<p>另外目前本人将这个静态博客放在了3个地方:</p>
<ol>
<li>hostker使用git部署<a href="https://www.zoulei.net">https://www.zoulei.net</a></li>
<li>github pages使用git部署<a href="https://ficapy.github.io">https://ficapy.github.io</a></li>
<li>128M vps rsync同步<a href="https://www.ficapy.com">https://www.ficapy.com</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先这是篇水文:),仅记录下这2天使用docker的情况。实际上和docker没什么关系,静态博客嘛,生成之后上传到vps然后上面放个nginx就好了，没什么需要操心的&lt;/p&gt;
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://www.zoulei.net/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>werkzeug源码分析(Debug模块)</title>
    <link href="https://www.zoulei.net/2016/08/07/werkzeug_debug_note/"/>
    <id>https://www.zoulei.net/2016/08/07/werkzeug_debug_note/</id>
    <published>2016-08-07T00:43:31.000Z</published>
    <updated>2016-09-04T07:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>flask的debug看起来还是很神奇的，可以在异常页面查看当前调用栈，且能够在当前栈内进行交互式会话用以调试。本文将会从python的REPL进行说明并延伸到flask。看看它的具体实现</p>
<a id="more"></a>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>python的运行是讲源码进行编译，之后虚拟机执行。这2个步骤python都提供了接口,compile和exec。exec的执行会调用compile,我们一般不会主动去调用compile。compile这个函数有三个模式<a href="https://docs.python.org/3/library/functions.html#compile">官方文档</a> <a href="http://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile-in-python">stackoverflow</a></p>
<ul>
<li>exec:一系列声明</li>
<li>eval:单条表达式</li>
<li>single:单条声明,和exec不同的是当返回不为None的时候执行的时候会打印。这一想都知道专门是为交互式环境准备的</li>
</ul>
<p>编译之后不用说。使用内建函数exec执行就好啦。它带有2个可选参数,全局空间变量及局部空间变量。看一个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">local = &#123;&#125;</span><br><span class="line">code = compile(<span class="string">'a=1'</span>, filename=<span class="string">'&lt;string&gt;'</span>, mode=<span class="string">'single'</span>)</span><br><span class="line">print(code)</span><br><span class="line">exec(code,local)</span><br><span class="line">code = compile(<span class="string">'a+=1'</span>, filename=<span class="string">'&lt;string&gt;'</span>, mode=<span class="string">'single'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    exec(code)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Error'</span>)</span><br><span class="line">exec(code,local)</span><br><span class="line">print(local.get(<span class="string">'a'</span>))</span><br><span class="line">code = compile(<span class="string">'x+=1'</span>,filename=<span class="string">'&lt;string&gt;'</span>,mode=<span class="string">'single'</span>)</span><br><span class="line">print(code)</span><br><span class="line"><span class="comment"># &lt;code object &lt;module&gt; at 0x10fd9dc90, file "&lt;string&gt;", line 1&gt;</span></span><br><span class="line"><span class="comment"># Error</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># &lt;code object &lt;module&gt; at 0x105c25c90, file "&lt;string&gt;", line 1&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>编译的时候只要语法没有问题就可以通过，看x+=1,即使全局变量不存在x也能够编译通过</li>
<li>使用exec的时候，可以引入一个字典，否则会自动使用默认的global,有了这个字典我们就可以连接上下文，想一想。要是我们执行a=1，如果没有记录。那么后面执行a+=1就会报错了，这肯定不是我们所希望的</li>
</ol>
<h3 id="自带REPL"><a href="#自带REPL" class="headerlink" title="自带REPL"></a>自带REPL</h3><p>要实现一个类似的IDLE环境2条语句就够了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> code</span><br><span class="line">code.interact()</span><br></pre></td></tr></table></figure><br>看调用图<br><img src="http://ficapy.b0.upaiyun.com/blogimg/code_interactiveconsole.png" alt="code_interactiveconsole"><br>会涉及到2个模块，code和codeop，这2个模块可以都说是为生成交互式解释器服务的。code模块作用是接收请求然后解析再执行(exec)。解析部分就是由codeop提供的。设想一下为什么有了compile还需要一个单独的codeop模块。<br>我们使用交互式解释器的时候并不是所有的命令都是一行输入完成的。比如输入一个函数，那就需要多行。将我们输入的多行编译一次。这是我们的需求。codeop就是为这个而存在的。比如你执行codeop.compile_command(‘math(‘)会返回None。这就代表你下一行继续输入，直到你连续输入了2个空行。好了，它知道你输入完成了。核心代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runsource</span><span class="params">(self, source, filename=<span class="string">"&lt;input&gt;"</span>, symbol=<span class="string">"single"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        code = self.compile(source, filename, symbol)</span><br><span class="line">    <span class="keyword">except</span> (OverflowError, SyntaxError, ValueError):</span><br><span class="line">        <span class="comment"># Case 1</span></span><br><span class="line">        self.showsyntaxerror(filename)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> code <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># Case 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Case 3</span></span><br><span class="line">    self.runcode(code)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><br>逻辑还是比较好理解的。</p>
<h3 id="Exception-traceback-frame联系"><a href="#Exception-traceback-frame联系" class="headerlink" title="Exception,traceback,frame联系"></a>Exception,traceback,frame联系</h3><p>上个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomeExcept</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, desc)</span>:</span></span><br><span class="line">        super(CustomeExcept, self).__init__()</span><br><span class="line">        self.desc = desc</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.desc</span><br><span class="line"></span><br><span class="line">    __str__ = __repr__</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> CustomeExcept(<span class="string">'l'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    t()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    app()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># traceback.print_exc(file=sys.stdout)</span></span><br><span class="line">    exc_type, exc_value, exc_tb = sys.exc_info()</span><br><span class="line">    print(exc_tb.tb_frame.f_lineno)</span><br><span class="line">    print(exc_type)</span><br><span class="line">    print(exc_value <span class="keyword">is</span> e)</span><br><span class="line">    print(exc_value)</span><br><span class="line">    print([i <span class="keyword">for</span> i <span class="keyword">in</span> dir(exc_tb) <span class="keyword">if</span> <span class="keyword">not</span> i.startswith(<span class="string">'_'</span>)])</span><br><span class="line">    print(exc_tb.tb_frame, exc_tb.tb_lineno, exc_tb.tb_next.tb_lineno, exc_tb.tb_next.tb_next.tb_lineno,</span><br><span class="line">          exc_tb.tb_next.tb_next.tb_next, sys._getframe(<span class="number">0</span>), exc_tb.tb_frame.f_back)</span><br><span class="line">    print(exc_tb.tb_next.tb_frame.f_locals)</span><br><span class="line"><span class="comment"># 23</span></span><br><span class="line"><span class="comment"># &lt;class '__main__.CustomeExcept'&gt;</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># l</span></span><br><span class="line"><span class="comment"># ['tb_frame', 'tb_lasti', 'tb_lineno', 'tb_next']</span></span><br><span class="line"><span class="comment"># &lt;frame object at 0x7f90b5813958&gt; 19 17 13 None &lt;frame object at 0x7f90b5813958&gt; None</span></span><br><span class="line"><span class="comment"># &#123;'a': 1&#125;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Exception配合raise使用,使用except捕获异常的时候返回它的实例</li>
<li>返回的实例是和帧栈Frame是没有关系的</li>
<li>sys.exc_info返回了异常类，异常实例,traceback实例</li>
<li>traceback对象记录的帧不是当前帧,而是从发起异常的那个函数开始记录帧栈,因此比当前帧栈更长,traceback的中文意思是回溯,它的tb_next可以想象一下,实际上更可以说是读取上一个帧(因为引发异常的那个帧实际上在最上面)</li>
<li>tb_next返回的还是一个traceback对象</li>
<li>traceback模块提供了一些接口(比如traceback.print_exc)从帧中提取出信息然后格式化打印<br>偷一张图(引用自<a href="http://busuncle.github.io/python-vm-and-bytecode.html">http://busuncle.github.io/python-vm-and-bytecode.html</a>)<br><img src="https://ficapy.b0.upaiyun.com/blogimg/pyframeobject_busuncle.github.io.jpg" alt="pyframeobject"></li>
</ul>
<h3 id="werkzeug实现"><a href="#werkzeug实现" class="headerlink" title="werkzeug实现"></a>werkzeug实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__debugger__:yes&#10;cmd:a = 1+1&#10;frm:0&#10;s:3WcibzVj8YXQDR0Na4bv</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://busuncle.github.io/python-vm-and-bytecode.html">Python虚拟机与字节码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flask的debug看起来还是很神奇的，可以在异常页面查看当前调用栈，且能够在当前栈内进行交互式会话用以调试。本文将会从python的REPL进行说明并延伸到flask。看看它的具体实现&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>redis-py源码分析</title>
    <link href="https://www.zoulei.net/2016/08/06/redis_py_note/"/>
    <id>https://www.zoulei.net/2016/08/06/redis_py_note/</id>
    <published>2016-08-06T11:39:07.000Z</published>
    <updated>2016-08-06T23:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文会简述该库的代码组织架构，会着重介绍它实现的连接池ConnectPool以及如何实现的线程、进程安全。</p>
<a id="more"></a>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; __init__.py&#10;&#9500;&#9472;&#9472; _compat.py          &#20860;&#23481;&#24615;&#10;&#9500;&#9472;&#9472; client.py           &#23454;&#29616;&#23458;&#25143;&#31471;,&#35843;&#29992;connectionpool&#10;&#9500;&#9472;&#9472; connection.py       &#23454;&#29616;&#36830;&#25509;&#27744;&#65292;&#36830;&#25509;&#65292;&#35299;&#26512;&#22120;&#10;&#9500;&#9472;&#9472; exceptions.py       &#24322;&#24120;&#31867;&#10;&#9500;&#9472;&#9472; lock.py             &#23454;&#29616;&#20998;&#24067;&#24335;&#38145;&#10;&#9500;&#9472;&#9472; sentinel.py         &#37197;&#21512;redis sentinel&#26426;&#21046;&#23454;&#29616;&#39640;&#21487;&#29992;&#23458;&#25143;&#31471;&#10;&#9492;&#9472;&#9472; utils.py            &#36741;&#21161;&#31867;</span><br></pre></td></tr></table></figure>
<h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">r = redis.Redis()</span><br><span class="line">r.set(<span class="string">'foob'</span>, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>
<p>看架构图<br><img src="https://ficapy.b0.upaiyun.com/blogimg/redis_py_arch.png" alt="redis_client_arch"><br>看调用图(以下为5年前的<a href="https://github.com/andymccurdy/redis-py/tree/2.4">2.4版本</a>)<br><img src="https://ficapy.b0.upaiyun.com/blogimg/redis_old_version.png" alt="redis_old_version"><br>第一步执行<code>r=redis.Redis()</code>没进行什么操作，同时隐式的初始化了ConnectionPool。<br>等到执行set操作的时候。就是执行了execute_command，此时分为了几个步骤。看第5个函数调用，从连接池里面get_connection。如果没有可用的，那么则新建(redis.connection.Connection.<strong>init</strong>),此时并没有创建socket连接。第8个函数调用send_command,命令打包然后创建连接发送。该版本使用connection._sock.makefile(‘r’)便于读取。<br>再到了第21个函数调用Connection.read_response.使用解析器从socket读取数据并转换成便于python使用的数据结构<br>最后finally将该连接释放到线程池</p>
<p>现在可以看到有这样一条关系，每一个redis.Redis()实例都有一个ConnectionPool对象,一个连接池至少含有一条连接。所以绝大多数情况没有必要写出连接池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool = redis.ConnectionPool()&#10;r = redis.Redis(connection_pool=pool)&#10;&#31561;&#20215;&#20110;&#10;r = redis.Redis()</span><br></pre></td></tr></table></figure></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>如果你的程序是单线程的。那么没什么好说的，一个Redis实例，一个连接池，一个socket连接。<br>多线程那我们主要考虑的是线程安全问题。对于redis客户端就是socket连接绝对要线程间隔离，否则一个线程解析了另外一个socket的返回内容，那么多线程也就没意义了。测试一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">r = redis.Redis()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    r.setex(threading.get_ident(), threading.get_ident(), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">assert</span> r.get(threading.get_ident()) <span class="keyword">in</span> [str(threading.get_ident()).encode(), <span class="keyword">None</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    threading.Thread(target=main).start()</span><br><span class="line"><span class="comment"># watch -n 1 "redis-cli INFO clients"    </span></span><br><span class="line"><span class="comment"># Every 1.0s: redis-cli INFO clients                                           Sat Aug  6 21:34:31 2016</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># #Clients</span></span><br><span class="line"><span class="comment"># connected_clients:26</span></span><br><span class="line"><span class="comment"># client_longest_output_list:0</span></span><br><span class="line"><span class="comment"># client_biggest_input_buf:0</span></span><br><span class="line"><span class="comment"># blocked_clients:0</span></span><br></pre></td></tr></table></figure><br>可以看到结果并没有错误，而且创建的连接数和创建的线程数并不是一致的</p>
<p>试想一下，每次执行一次类似set的指令。都会从连接池(List结构)取出(pop)一个连接。而list.pop是线程安全的。执行完毕命令后又会使用append加入到连接池，list.append也是线程安全的。所以针对socket的操作是线程隔离的。这一切好像和_in_use_connections并没有什么关系。对于一个简单的连接池。从连接池取出，用完加入到连接池。而_in_use_connections记录的是使用中的线程。啥子用呢。它用于一个接口(关闭连接池中的所有连接)。注意关闭连接并不会将_available_connections和_in_use_connections清空。它只会将connection对象中的_sock设置为None，而每次执行命令的时候connection都是会检查_sock是否为空，如果为空则会重新建立连接,如下示例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis()</span><br><span class="line">r.setex(<span class="string">'key'</span>, <span class="string">'value'</span>, <span class="number">20</span>)</span><br><span class="line">print(r.connection_pool._available_connections[<span class="number">0</span>]._sock)</span><br><span class="line">r.connection_pool.disconnect()</span><br><span class="line">print(r.connection_pool._available_connections[<span class="number">0</span>]._sock)</span><br><span class="line">r.setex(<span class="string">'key'</span>,<span class="string">'value'</span>,<span class="number">20</span>)</span><br><span class="line">print(r.connection_pool._available_connections[<span class="number">0</span>]._sock)</span><br><span class="line"><span class="comment"># &lt;socket.socket fd=5, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6, laddr=('::1', 62900, 0, 0), raddr=('::1', 6379, 0, 0)&gt;</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># &lt;socket.socket fd=5, family=AddressFamily.AF_INET6, type=SocketKind.SOCK_STREAM, proto=6, laddr=('::1', 62901, 0, 0), raddr=('::1', 6379, 0, 0)&gt;</span></span><br></pre></td></tr></table></figure><br>因为它关闭连接的时候并没有将对应的connection对象从连接池中删除。那么会造成一个问题。如果你创建过100个连接，那么连接池将会一直复用这些对象。如果你高峰期创建过多的连接，而后又只需要几个连接就够了(虽然这样的问题估计极少会遇到)。你可以显式的pop出_available_connections并关闭。<br>其实有一个地方是非线程安全的。在创建连接的时候有self._created_connections += 1,如果你访问这个值得到创建的连接数是不可靠的。不过这都无关紧要，因为你不可能在极短的时间内创建许多连接。即使这里不准。统计误差也不会有2个。</p>
<p>为了避免无端创建出N多连接。该客户端后期加入了BlockingConnectionPool类。使用LifoQueue创建出连接队列，如果该队列被使用完，那么后续请求将会阻塞一段时间，过长则引发异常。</p>
<h3 id="多进程安全"><a href="#多进程安全" class="headerlink" title="多进程安全"></a>多进程安全</h3><p>redis-py在2.4.12加入了多线程安全<a href="https://github.com/andymccurdy/redis-py/issues/234">见issues</a>。<br>可以看到实现原理也是很简单的。fork进程的时候socket一样使用的。为了分开，使用了os.getpid()区分。如果进程号变了，则关闭所有的连接，重新连接后自然就分开了。同时为了防止一个进程有多个线程这种情况。一个线程关闭后，另外一个线程也可能执行关闭操作。所以此处使用了锁<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_checkpid</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.pid != os.getpid():</span><br><span class="line">        <span class="keyword">with</span> self._check_lock:</span><br><span class="line">            <span class="keyword">if</span> self.pid == os.getpid():</span><br><span class="line">                <span class="comment"># another thread already did the work while we waited</span></span><br><span class="line">                <span class="comment"># on the lock.</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.disconnect()</span><br><span class="line">            self.reset()</span><br></pre></td></tr></table></figure></p>
<p>插播一下当前2.10.5版本的调用图<br><img src="http://ficapy.b0.upaiyun.com/blogimg/redis_pool.png" alt="new_redis_pool"><br>可以看到和最上面的调用图出入很小，仅仅加入了进程安全,将socket.makefile变成了SocketBuffer.</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>线程锁就是多线程间有线程间共享变量。进程锁就是多进程间有进程间共享变量。此处的共享变量就是将变量存储到redis数据库。实现也比较简单。截取一段acquire看看<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_acquire</span><span class="params">(self, token)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.redis.setnx(self.name, token):</span><br><span class="line">        <span class="keyword">if</span> self.timeout:</span><br><span class="line">            <span class="comment"># convert to milliseconds</span></span><br><span class="line">            timeout = int(self.timeout * <span class="number">1000</span>)</span><br><span class="line">            self.redis.pexpire(self.name, timeout)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><br>另外它实现的只是最简单的锁。比如可重入锁啥的都是没有实现的。如果你想配合sentinel进行高可用。往下看…..</p>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p><img src="https://ficapy.b0.upaiyun.com/blogimg/redis_sentinel.png" alt="redis_sentinel"><br>得益于redis-py的松耦合，连接池、连接、解析器基本都很独立。<br>客户端和监视器组创建一个上面说的Redis正常连接。它主要提供接口返回master的地址和返回salve的地址。<br>然后我们使用master_for返回的也是一个Redis连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return redis_class(connection_pool=connection_pool_class(&#10;            service_name, self, **connection_kwargs))</span><br></pre></td></tr></table></figure></p>
<p>不过它进行对连接池和连接对象都进行了一些修改。可以看到它将self传递给了底层连接池。而连接池也使用<code>self.connection_kwargs[&#39;connection_pool&#39;] = weakref.proxy(self)</code>将自己传递给了底层Connection，就这样它实现了高可用客户端，在底层连接的时候使用高层提供的函数提供正确的地址~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会简述该库的代码组织架构，会着重介绍它实现的连接池ConnectPool以及如何实现的线程、进程安全。&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析" scheme="https://www.zoulei.net/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>werkzeug源码分析(local.py)</title>
    <link href="https://www.zoulei.net/2016/08/03/werkzeug_local_note/"/>
    <id>https://www.zoulei.net/2016/08/03/werkzeug_local_note/</id>
    <published>2016-08-03T00:58:00.000Z</published>
    <updated>2016-09-04T08:14:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>有人说flask的上下文机制是整个框架的精华部分，有人说它神奇的g让人费解。werkzeug的local.py就是它的具体实现。这个看似神奇的机制背后加上应用代码也不过两三百行。不过好像坑还是<code>比较深</code>的。另外flask的0.1版本才200多行代码。值得瞅一下</p>
<a id="more"></a>
<h3 id="直观感受上下文"><a href="#直观感受上下文" class="headerlink" title="直观感受上下文"></a>直观感受上下文</h3><p>使用wrk进行压测<code>wrk -t300 -c300 -d10s http://127.0.0.1:5000</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask.globals <span class="keyword">import</span> _request_ctx_stack,_app_ctx_stack</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="decorator">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    pprint(_request_ctx_stack._local.__storage__)</span><br><span class="line">    pprint(_app_ctx_stack._local.__storage__)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">app.run(threaded=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某一时刻状态</span></span><br><span class="line"><span class="comment"># &#123;123145360109568: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145391640576: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145407406080: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145417916416: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145428426752: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145459957760: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145480978432: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145496743936: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145512509440: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145538785280: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145549295616: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145601847296: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145638633472: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145680674816: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145743736832: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145764757504: &#123;'stack': [&lt;RequestContext 'http://127.0.0.1:5000/' [GET] of temp&gt;]&#125;&#125;</span></span><br><span class="line"><span class="comment"># &#123;123145360109568: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x103f90f60&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145391640576: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x103fcdc50&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145407406080: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x10402c080&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145417916416: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x103fa0668&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145428426752: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x104058828&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145459957760: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x103fd8470&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145480978432: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x1040859e8&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145496743936: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x104078cf8&gt;]&#125;,</span></span><br><span class="line"><span class="comment">#  123145512509440: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x104036c88&gt;]&#125;,</span></span><br></pre></td></tr></table></figure></p>
<h3 id="为什么会有Local"><a href="#为什么会有Local" class="headerlink" title="为什么会有Local"></a>为什么会有Local</h3><p>比较抽象的解释叫它<code>线程内共享变量</code>，下面来个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">l = threading.local()</span><br><span class="line">l.a = <span class="number">1</span></span><br><span class="line">threading.Thread(target=<span class="keyword">lambda</span>: setattr(l, <span class="string">'a'</span>, <span class="number">2</span>) <span class="keyword">or</span> print(l.a, threading.current_thread())).start()</span><br><span class="line">print(l.a)</span><br><span class="line"><span class="comment"># 2 &lt;Thread(Thread-1, started 123145307557888)&gt;</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><br>可以看出就是一全局对象对它设置的属性在线程间是隔离的。可是这又有什么用。我们作为框架使用者逻辑一般都是写在一起的，没有人会故意去像这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = threading.local()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    l.a = <span class="number">1</span></span><br><span class="line">    l.a  <span class="comment">##进行引用</span></span><br></pre></td></tr></table></figure><br>可是我们使用的是框架！线程的调起不是我们主动去操作的。框架会有一些第三方扩展。它们依靠此机制给我们提供接口，比如来个<a href="http://flask.pocoo.org/docs/0.11/appcontext/#context-usage">官方示例</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> g</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db</span><span class="params">()</span>:</span></span><br><span class="line">    db = getattr(g, <span class="string">'_database'</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> db <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        db = g._database = connect_to_database()</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"><span class="comment">#=========================</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalProxy</span><br><span class="line">db = LocalProxy(get_db)</span><br></pre></td></tr></table></figure></p>
<p>Local的实现原理很简单，这里不详述了。就是前一篇博文说的字典的<code>dict[key] = value</code>是线程安全的。其实threading.local也是一样的作用，那么为什么不用它。</p>
<ul>
<li>支持了greenlet(本博文只会涉及到多线程情况)</li>
<li>自带的写法太特么恶心了，那个源码我都快看吐了，不如自己写一个(我都没看透自带的为什么要那么写,如果你能轻松看明白，那么你肯定是看魔术方法的大神)<br>简述下自带的逻辑，主要是这几句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python2.7.11&#20195;&#30721;&#10;dict = object.__getattribute__(self, &#39;__dict__&#39;)&#10;current_thread().__dict__[key] = dict&#10;&#10;key = object.__getattribute__(self, &#39;_local__key&#39;)&#10;d = current_thread().__dict__.get(key)&#10;# import threading&#10;# l = threading.current_thread()&#10;# print(l is threading.current_thread())&#10;# threading.Thread(target=lambda :print(threading.current_thread() is l)).start()&#10;# True&#10;# False</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在同一线程内threading.current_thread()是同一对象，有一个_patch函数，该函数在local属性被调用前提前调用，将current_thread().__dict__相关的内容绑定在local.__dict__上。</p>
<h3 id="为什么会有LocalStack"><a href="#为什么会有LocalStack" class="headerlink" title="为什么会有LocalStack"></a>为什么会有LocalStack</h3><p>它主要将上面的Local由<code>l.key = value</code>变成了<code>l.push(value)</code>。变成了栈结构。可是从上面的直观感受上下文部分可以看到在多线程环境下任一时刻栈里面都仅有一个内容。那么还为什么要使用栈呢，往下看。</p>
<h3 id="为什么会有LocalProxy"><a href="#为什么会有LocalProxy" class="headerlink" title="为什么会有LocalProxy"></a>为什么会有LocalProxy</h3><p>从名字就可以看出来是代理模式。可以看看github上的<a href="https://github.com/faif/python-patterns/blob/master/proxy.py">设计模式</a>，同样是讲的代理模式，flask的实际应用就比这个例子要高明的多</p>
<p>我们使用代理是为了绕过防火墙访问外面的世界，那么LocalProxy这个代理是干啥子的呢。设想一下。我们使用了l = Local()并且在上面给一个属性赋值了l.key = value。那么当你要调用的时候就使用l.key就好啦。现在我们没有直接用Local用的是l = LocalStack(),l.push(RequestContext()),request这个属性又在<br>RequestContext()这个对象上。那么我们要访问request怎么办！此时你就要执行l.top.request进行访问。可是优雅呢！优雅呢！优雅呢！优雅哪里去了。我们很懒，我们想执行一个request就能代替l.top.request(有人会问为什么不直接写死reques = l.top.request，那是因为它是死！！！的,而l.top.request是随着线程进入退出一直出入栈动态变化的，我们只能在每次使用的时候执行l.top.request得到正确的结果)。→_→这就是这个代理能为我们做的<br>执行repr(current_app)的调用图，请无视pycall那一块<br><img src="http://ficapy.b0.upaiyun.com/blogimg/werkzeug_localproxy.png" alt="werkzeug_localproxy"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_app</span><span class="params">()</span>:</span></span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> top.app</span><br><span class="line"></span><br><span class="line">_app_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(_find_app)</span><br></pre></td></tr></table></figure><br>在LocalProxy里面我们写了一个回调函数，当对LocalProxy属性进行访问的时候，它永远都是先执行_get_current_object,该函数就是执行我们写入的回调函数得到访问对象,比如current_app就是得到_app_ctx_stack.top.app对象。最后再对得到的对象进行属性访问</p>
<p>对LocalProxy讲3个小细节</p>
<ol>
<li><p>__init__中有<code>object.__setattr__(self, &#39;_LocalProxy__local&#39;, local)</code>。如果你要确保对一个对象的<code>__dict__</code>中加入内容，需要使用object.__setattr__，使用self.x、setattr(self,’x’)、self.__dict__[x]都是不确定的，因为它self这个对象可能会重写自身的__setattr__,其次对于私有变量。执行__setattr__的时候需要变换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Foo():&#10;    def __init__(self):&#10;        self.__a = 1&#10;print(Foo().__dict__)&#10;# &#123;&#39;_Foo__a&#39;: 1&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最下面同时也对所有可列举的魔术方法进行了代理<code>__str__ = lambda x:    str(x._get_current_object())</code></p>
</li>
<li>由于代理的存在原始对象的访问需要通过_get_current_object(其实对于看过代码的这应该是废话O_o)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask,current_app&#10;from flask.globals import _app_ctx_stack&#10;with Flask(__name__).app_context():&#10;    print(current_app is _app_ctx_stack.top.app)&#10;    print(current_app._get_current_object() is _app_ctx_stack.top.app)&#10;# False&#10;# True</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="request、session和g"><a href="#request、session和g" class="headerlink" title="request、session和g"></a>request、session和g</h3><p>这几个和上下文息息相关,比如离开了对应的上下文它们完全无法使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, session, g</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [request, session, g]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> RuntimeError:</span><br><span class="line">        print(<span class="string">'boom! '</span>, end=<span class="string">''</span>)</span><br><span class="line"><span class="comment"># boom! boom! boom!</span></span><br></pre></td></tr></table></figure><br>flask的0.1版本是只有RequestContext请求上下文，没有应用上下文的。<a href="https://github.com/pallets/flask/commit/47288231fe8f9c6b2c413d50160c32c3884d5785">直到0.9版本才用二三十行代码加上AppContext应用上下文</a><br>为什么要加上应用上下文呢。官方文档我没有找到很详尽的解释，<a href="http://flask.pocoo.org/docs/0.11/appcontext/#purpose-of-the-application-context">只有一段简要的描述</a>，同时参考了下别人的博客。我个人理解是为了处理单独使用应用上下文不使用请求上下文的情况。另外文档有<code>creating such a request context is an unnecessarily expensive operation</code>在某些情况使用请求上下文是昂贵的没有必要的操作。参考下面的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,current_app</span><br><span class="line"><span class="keyword">from</span> flask.globals <span class="keyword">import</span> _app_ctx_stack, _request_ctx_stack</span><br><span class="line"></span><br><span class="line">app1 = Flask(<span class="string">'a'</span>)</span><br><span class="line">app2 = Flask(<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app1.app_context():</span><br><span class="line">    <span class="keyword">with</span> app2.app_context():</span><br><span class="line">        print(_request_ctx_stack._local.__storage__)</span><br><span class="line">        print(_app_ctx_stack._local.__storage__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"><span class="comment"># &#123;140735191154688: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x1096c1f60&gt;, &lt;flask.ctx.AppContext object at 0x1096cd048&gt;]&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app1.test_client() <span class="keyword">as</span> client1:</span><br><span class="line">    <span class="keyword">with</span> app2.test_client() <span class="keyword">as</span> client2:</span><br><span class="line">        print(_request_ctx_stack._local.__storage__)</span><br><span class="line">        print(_app_ctx_stack._local.__storage__)</span><br><span class="line">        client2.get(<span class="string">'/b'</span>)</span><br><span class="line">        print(current_app)</span><br><span class="line">        print(_request_ctx_stack._local.__storage__)</span><br><span class="line">        client1.get(<span class="string">'/a'</span>)</span><br><span class="line">        print(current_app)</span><br><span class="line">        print(_request_ctx_stack._local.__storage__)</span><br><span class="line">    resp = client1.get(<span class="string">'/a'</span>)</span><br><span class="line">    print(_request_ctx_stack._local.__storage__)</span><br><span class="line">    print(current_app)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line"><span class="comment"># &lt;Flask 'b'&gt;</span></span><br><span class="line"><span class="comment"># &#123;140735191154688: &#123;'stack': [&lt;RequestContext 'http://localhost/b' [GET] of b&gt;]&#125;&#125;</span></span><br><span class="line"><span class="comment"># &lt;Flask 'a'&gt;</span></span><br><span class="line"><span class="comment"># &#123;140735191154688: &#123;'stack': [&lt;RequestContext 'http://localhost/a' [GET] of a&gt;]&#125;&#125;</span></span><br><span class="line"><span class="comment"># &#123;140735191154688: &#123;'stack': [&lt;RequestContext 'http://localhost/a' [GET] of a&gt;]&#125;&#125;</span></span><br></pre></td></tr></table></figure><br>首先可以看到执行app_context()的时候有了应用上下文，和请求上下文一毛钱关系都没有。看下代码就是return AppContext(self),它自己有个<strong>enter</strong>函数执行了push。这有什么用呢。比如你要在命令行调用下你写的数据库函数。很明显它需要数据库的配置app.config。如果没有应用上下文，那么你需要先创建请求上下文。现在你只需要创建应用上下文了(比请求上下文更轻量)。再者当我们一次性进入了多个应用上下文的时候此时栈里面就不止一个元素了。所以。。。。这也是上面问的为什么要用栈</p>
<p>第二个例子只有当请求发送后应用上下文和请求上下文才会同时入栈。且同时出栈，所以网上有博客写一个应用上下文会包含多个请求上下文这是不对的。并且绝对不能理解为应用上下文的生存周期是一个app从启动到关闭这个过程</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.tonyseek.com/post/the-context-mechanism-of-flask/">Flask 的 Context 机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有人说flask的上下文机制是整个框架的精华部分，有人说它神奇的g让人费解。werkzeug的local.py就是它的具体实现。这个看似神奇的机制背后加上应用代码也不过两三百行。不过好像坑还是&lt;code&gt;比较深&lt;/code&gt;的。另外flask的0.1版本才200多行代码。值得瞅一下&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>list和dict的线程安全</title>
    <link href="https://www.zoulei.net/2016/07/31/list_dict_threading_safe/"/>
    <id>https://www.zoulei.net/2016/07/31/list_dict_threading_safe/</id>
    <published>2016-07-30T23:47:09.000Z</published>
    <updated>2016-08-02T03:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚转行第一次IT面试的时候面试官问我，list和dict是不是线程安全的。当时我就想，擦嘞,作为一个初学者list和dict不是线程安全的都看了N遍啦。这还有疑问么~~~，现在想想并没有抓住重点，线程安全应该针对于具体的操作，而不是具体的对象，我们说Queue是线程安全的是因为针对它的所有操作都是线程安全的。</p>
<a id="more"></a>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><a href="https://docs.python.org/2/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe">官方文档</a></h3><p>可以看到大概有这么个概念<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L,L1,L2-&#62;list&#10;D,D1,D2-&#62;dict&#10;x,y-&#62;object&#10;i,j-&#62;int&#10;&#10;&#32447;&#31243;&#23433;&#20840;&#10;L.append(x)&#10;L1.append(L2)&#10;x=L[i]&#10;y=L.pop()&#10;L1[i,j]=L2&#10;L.sort()&#10;x=y&#10;x.field=y&#10;D[x]=y&#10;D1.update(D2)&#10;D.keys()&#10;&#10;&#10;&#20197;&#19979;&#26159;&#38750;&#32447;&#31243;&#23433;&#20840;&#10;i=i+1&#10;L.append(L[-1])&#10;L[i]=L[j]&#10;D[x]=D[x]+1</span><br></pre></td></tr></table></figure><br>可以看到list的append啥的其实是线程安全的。我们看到的举非线程安全的例子基本都是i+=1这种，最后得到的结果小于相加次数。然后最后说一句多线程对同一资源进行操作的时候要加锁哇。。。。。这话直接说的好像比较不负责任。让我这样的初学者风声鹤唳草木皆兵</p>
<h3 id="一点小解释"><a href="#一点小解释" class="headerlink" title="一点小解释"></a>一点小解释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3000000</span>):</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">th = [threading.Thread(target=main), threading.Thread(target=main)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> th:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> th:</span><br><span class="line">    t.join()</span><br><span class="line">print(i)</span><br><span class="line"></span><br><span class="line">dis.dis(main)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4372439</span></span><br><span class="line"><span class="comment">#   8           0 SETUP_LOOP              30 (to 33)</span></span><br><span class="line"><span class="comment">#               3 LOAD_GLOBAL              0 (range)</span></span><br><span class="line"><span class="comment">#               6 LOAD_CONST               1 (3000000)</span></span><br><span class="line"><span class="comment">#               9 CALL_FUNCTION            1</span></span><br><span class="line"><span class="comment">#              12 GET_ITER            </span></span><br><span class="line"><span class="comment">#         &gt;&gt;   13 FOR_ITER                16 (to 32)</span></span><br><span class="line"><span class="comment">#              16 STORE_FAST               0 (_)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#   9          19 LOAD_GLOBAL              1 (i)</span></span><br><span class="line"><span class="comment">#              22 LOAD_CONST               2 (1)</span></span><br><span class="line"><span class="comment">#              25 INPLACE_ADD         </span></span><br><span class="line"><span class="comment">#              26 STORE_GLOBAL             1 (i)</span></span><br><span class="line"><span class="comment">#              29 JUMP_ABSOLUTE           13</span></span><br><span class="line"><span class="comment">#         &gt;&gt;   32 POP_BLOCK           </span></span><br><span class="line"><span class="comment">#         &gt;&gt;   33 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="comment">#              36 RETURN_VALUE</span></span><br></pre></td></tr></table></figure>
<p>我们知道python代码经过编译成字节码指令，然后python虚拟机按照指令进行执行，这里每一条指令都是原子操作不会被中断，可以看到<code>i+=1</code>这条语句被划分为4条指令被执行。取出i变量的值入栈→→将被加数1入栈→→取出2个数相加结果再入栈→→结果出栈。因为是要累加。我们当然需要累加的第一步加入的值是上一个累加的结果。可是在多线程不加锁的情况下每一条指令被执行完毕后都有可能去执行另外一个线程的指令。这就会造成第一步加入的值有可能和另外一个线程是一样的，于是悲剧发生了O_o</p>
<p>再想一想append<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8          19 LOAD_GLOBAL              1 (i)&#10;           22 LOAD_ATTR                2 (append)&#10;           25 LOAD_CONST               2 (1)&#10;           28 CALL_FUNCTION            1&#10;           31 POP_TOP</span><br></pre></td></tr></table></figure><br> <a href="http://jakevdp.github.io/images/array_vs_list.png">图片引用自</a><br> <img src="https://ficapy.b0.upaiyun.com/blogimg/array_vs_list.png" alt="array_vs_list"><br>可以看出list就是一个容器.append就相当与在最后面加了一个引用。虽然它也是由几条指定组成。也会发生交错执行的情况。这种交错造成的结果无非就是我本来是先执行的却在了一个的后面执行了插入，造成的结果就是<code>顺序错乱了</code>。😄可是特喵本来就是多线程程序，谁特喵会去关心顺序呢。所以就说线程安全了。<br>可以看出，append和<code>i+=1</code>最大的区别就是是否对自身进行了修改。dict同理~~</p>
<p>另外加锁的时间开销其实还是挺大的。上例，我用3个线程(结果是9000000)，不加锁1.38秒，加锁执行39.16秒(python2.7.11)。不加锁1.06秒，加锁3.94秒(python3.5.1)。→_→当然你可以把i+=1改成i.apped(1)这样不用锁结果也能对了，只不过内存消耗感人</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://qingyunha.github.io/taotao/">A Python Interpreter Written in Python</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚转行第一次IT面试的时候面试官问我，list和dict是不是线程安全的。当时我就想，擦嘞,作为一个初学者list和dict不是线程安全的都看了N遍啦。这还有疑问么~~~，现在想想并没有抓住重点，线程安全应该针对于具体的操作，而不是具体的对象，我们说Queue是线程安全的是因为针对它的所有操作都是线程安全的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>werkzeug源码分析(Request/Response和热重启)</title>
    <link href="https://www.zoulei.net/2016/07/25/werkzeug_note_requests_response_auto_realod/"/>
    <id>https://www.zoulei.net/2016/07/25/werkzeug_note_requests_response_auto_realod/</id>
    <published>2016-07-25T13:48:17.000Z</published>
    <updated>2016-09-04T08:46:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask这个人人称赞的微框架就是构建在werkzeug之上，werkzeug给自己的定位就是工具集合。它实现了wsgi server、Requests/Response封装、DEBUG、热重启、路由控制以及其他的一些辅助功能。接下来的几篇文章会从一些大的方面去分析它。本篇如标题:D</p>
<a id="more"></a>
<h3 id="WSGI-Server"><a href="#WSGI-Server" class="headerlink" title="WSGI Server"></a>WSGI Server</h3><p>这个初略说一下。和它相关的代码不多。和wsgiref一样它构建在python自带模块SocketServer和BaseHTTPRequestHandler之上。甚至比自带的wsgiref代码要少。它主要增加了SSL和socket.fromfd支持。并且将debug、静态文件分发、热重启组合再了一起</p>
<h3 id="Request、Response封装"><a href="#Request、Response封装" class="headerlink" title="Request、Response封装"></a>Request、Response封装</h3><p>这个可能算是重点了。有个库webob就是专门做这个的。占得代码量也很大。可惜我并不想详细写每一个的过程，太麻烦了，了解了大概就好啦。以后会主要分析下datastructures.py这个文件。下面是超简洁的原理代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, env)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="decorator">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(cls, f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(env, start_response)</span>:</span></span><br><span class="line">            request = cls(env)</span><br><span class="line">            <span class="keyword">return</span> f(request)(env, start_response)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        self.body = str</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, env, start_response)</span>:</span></span><br><span class="line">        start_response(<span class="string">'200 OK'</span>, [])</span><br><span class="line">        <span class="keyword">return</span> [self.body]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="decorator">@Request.application</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span><span class="params">(req)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">b'Hello'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line">make_server(<span class="string">''</span>, <span class="number">8000</span>, app).serve_forever()</span><br></pre></td></tr></table></figure><br>可以大概了解是这么回事:</p>
<ul>
<li>Request它主要封装的是headers，然后嘞，各种属性都用property就好了，剩下的body和其他的也差不多啦。</li>
<li>Request.application这个装饰器的作用就是将原来的env,start_response参数变成req给我们使用</li>
<li><code>Response它就是一个wsgiapp对象</code><br>看下它们2个的继承图<br><img src="https://ficapy.b0.upaiyun.com/blogimg/werkzerg_wrappers_inherit.png" alt="werkzeug.wrappers.inherit"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainRequest</span><span class="params">(StreamOnlyMixin, Request)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span><span class="params">(BaseResponse, ETagResponseMixin, ResponseStreamMixin,</span><br><span class="line">               CommonResponseDescriptorsMixin,</span><br><span class="line">               WWWAuthenticateMixin)</span>:</span></span><br></pre></td></tr></table></figure>
翻源码可以看到它们的继承大部分都是对headers的操作</li>
</ul>
<h3 id="热重启实现原理"><a href="#热重启实现原理" class="headerlink" title="热重启实现原理"></a>热重启实现原理</h3><p>上简图：<br><img src="https://ficapy.b0.upaiyun.com/blogimg/werkzeug_autoreload.png" alt="werkzeug_autoreload"><br>上原理代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_change</span><span class="params">()</span>:</span></span><br><span class="line">    mtimes = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        filename = __file__</span><br><span class="line">        mtime = os.stat(filename).st_mtime</span><br><span class="line">        old_time = mtimes.get(filename)</span><br><span class="line">        <span class="keyword">if</span> old_time <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            mtimes[filename] = mtime</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> mtime &gt; old_time:</span><br><span class="line">            print(<span class="string">' * Detected change in &#123;&#125;, reloading'</span>.format(filename))</span><br><span class="line">            sys.exit(<span class="number">3</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.environ.get(<span class="string">'secord_process'</span>):</span><br><span class="line">    threading.Thread(target=main, args=()).start()</span><br><span class="line">    file_change()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        env = os.environ.copy()</span><br><span class="line">        env[<span class="string">'secord_process'</span>] = <span class="string">'true'</span></span><br><span class="line">        exit_code = subprocess.call([sys.executable] + sys.argv, env=env)</span><br><span class="line">        <span class="keyword">if</span> exit_code != <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>做法就是主线程啥事没做，跑一个死循环，生成子进程(就相当运行自身,区别就是os.environ)。这个进程内使用单独的线程跑需要运行的函数，另外就是检查相关文件是否被改变。改变就执行sys.exit。然后就又被主线程的死循环生成了新的子进程</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask这个人人称赞的微框架就是构建在werkzeug之上，werkzeug给自己的定位就是工具集合。它实现了wsgi server、Requests/Response封装、DEBUG、热重启、路由控制以及其他的一些辅助功能。接下来的几篇文章会从一些大的方面去分析它。本篇如标题:D&lt;/p&gt;
    
    </summary>
    
      <category term="Flask" scheme="https://www.zoulei.net/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://www.zoulei.net/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>osx airdrop无法使用修复</title>
    <link href="https://www.zoulei.net/2016/07/23/fix_osx_airdrop_not_working/"/>
    <id>https://www.zoulei.net/2016/07/23/fix_osx_airdrop_not_working/</id>
    <published>2016-07-23T02:53:25.000Z</published>
    <updated>2016-07-24T08:27:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>前些天用的好好的airdrop居然无法使用了。具体情况是：我有iphone、ipad、mac。iphone和ipad能够互相发现。mac对它们2个发现不了。妈蛋正要传资料可急死我了。网上一搜这种情况还不在少数。</p>
<p>遇到这种情况。可以打开about this mac→→system report查看Network(wifi)可以看到Country Code:是不是CN(我电脑有问题的时候是X3)。如果不是，那么无法使用airdrop就和它有关。至于如何修复这个问题我没有找到确切的办法.有一个原因可能是由于路由器造成的。这个可以打开系统自带的无线检测工具Wireless Diagnostics(Windows→→scan)查看是不是由于国家码冲突造成的(详情看第一个参考资料)。如果这里没有问题(我的不是这个问题)。。。。。那么请尝试执行以下操作</p>
<ol>
<li>将操作系统的语言改成中文</li>
<li>在系统设置页退出icloud账号</li>
<li>重启系统<br>：<br>：<br>尼玛，有可能就暂时能正常使用了ヾ(｡｀Д´｡)</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.howtogeek.com/211993/how-to-fix-conflicting-country-codes-and-improve-your-macs-wi-fi/">how-to-fix-conflicting-country-codes-and-improve-your-macs-wi-fi</a><br><a href="http://km.nicetypo.com/doc/7090786787135be8d32fa6624b892309">解決無法從 iPhone AirDrop 到 Mac 的方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天用的好好的airdrop居然无法使用了。具体情况是：我有iphone、ipad、mac。iphone和ipad能够互相发现。mac对它们2个发现不了。妈蛋正要传资料可急死我了。网上一搜这种情况还不在少数。&lt;/p&gt;
&lt;p&gt;遇到这种情况。可以打开about this ma
    
    </summary>
    
    
      <category term="随笔" scheme="https://www.zoulei.net/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>pycallgraph源码分析</title>
    <link href="https://www.zoulei.net/2016/07/22/pycallgraph_note/"/>
    <id>https://www.zoulei.net/2016/07/22/pycallgraph_note/</id>
    <published>2016-07-22T07:13:05.000Z</published>
    <updated>2016-08-18T10:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>用来生成函数调用图，这个工具可能名气比较大。因为看介绍就能看到好像可以生成比较帅气的图像。从源码层面看。其实这个工具是相当简单的，就是使用了sys.settrace接口,该接口常用于debug、profile(本文环境python3.5.1)。</p>
<a id="more"></a>
<h3 id="pycallgraph文件结构"><a href="#pycallgraph文件结构" class="headerlink" title="pycallgraph文件结构"></a>pycallgraph文件结构</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#10;&#9500;&#9472;&#9472; __init__.py&#10;&#9500;&#9472;&#9472; color.py                &#26174;&#31034;&#39068;&#33394;&#10;&#9500;&#9472;&#9472; config.py               &#20027;&#35201;&#29992;&#26469;&#30830;&#23450;&#20351;&#29992;&#21738;&#20123;&#36807;&#28388;&#26041;&#27861;&#10;&#9500;&#9472;&#9472; exceptions.py           &#27809;&#21861;&#29992;&#10;&#9500;&#9472;&#9472; globbing_filter.py      &#23601;&#19968;&#20010;fnmatch&#10;&#9500;&#9472;&#9472; memory_profiler.py      &#10;&#9500;&#9472;&#9472; metadata.py&#10;&#9500;&#9472;&#9472; output                  output.py&#26159;&#22522;&#31867;&#65292;&#20854;&#20182;&#20960;&#20010;&#26159;&#20855;&#20307;&#36755;&#20986;&#26041;&#24335;&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; __init__.py&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; gephi.py&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; graphviz.py&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; output.py&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; pickle.py&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; ubigraph.py&#10;&#9500;&#9472;&#9472; pycallgraph.py          &#25972;&#21512;config&#21644;output&#10;&#9500;&#9472;&#9472; tracer.py               &#26680;&#24515;&#25991;&#20214;(&#35843;&#29992;sys.settrace&#30340;&#22320;&#26041;)&#10;&#9492;&#9472;&#9472; util.py</span><br></pre></td></tr></table></figure>
<h3 id="获取函数被哪些函数调用"><a href="#获取函数被哪些函数调用" class="headerlink" title="获取函数被哪些函数调用"></a>获取函数被哪些函数调用</h3><p>查看下面的相关资料。有这样一段代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    g()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> traceback.format_stack():</span><br><span class="line">        print(line.strip())</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prints:</span></span><br><span class="line"><span class="comment"># File "so-stack.py", line 10, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     f()</span></span><br><span class="line"><span class="comment"># File "so-stack.py", line 4, in f</span></span><br><span class="line"><span class="comment">#     g()</span></span><br><span class="line"><span class="comment"># File "so-stack.py", line 7, in g</span></span><br><span class="line"><span class="comment">#     for line in traceback.format_stack():</span></span><br></pre></td></tr></table></figure><br>当f调用g的时候。在g里面有调用了traceback.format_stack，它显示了当调用函数g的时候的调用路径。实现其实是比较简单的嘛。当调用g的时候，它在栈顶。那么只需要不断的调用frame.f_back就能得到上一个栈，就可以得到以上信息。可以看出它得到的是函数被调用的信息。假如函数g调用了很多底层函数，此时我需要进行一些patch hook，那么要得到是函数g调用了哪些底层函数！这种方法就没用了。好在python提供了sys.settrace</p>
<h3 id="sys-settrace基本介绍"><a href="#sys-settrace基本介绍" class="headerlink" title="sys.settrace基本介绍"></a>sys.settrace基本介绍</h3><p>首先得对python运行的基本概念有个了解，函数的调用是一种栈结构。当函数被调用(触发call事件)的时候当前帧入栈，当函数执行完毕返回(触发return事件)的时候栈顶的帧出栈。sys.settrace就是对这些事件的hook。看下面这段代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(frame, event, args,record=[])</span>:</span></span><br><span class="line">    print(frame.f_lineno, frame.f_code.co_filename, event)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        record.append(frame)</span><br><span class="line">    <span class="keyword">elif</span> event == <span class="string">'return'</span>:</span><br><span class="line">        pre_frame = record.pop()</span><br><span class="line">        print(pre_frame <span class="keyword">is</span> frame)</span><br><span class="line">    <span class="keyword">return</span> trace</span><br><span class="line">sys.settrace(trace)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="number">1</span> / i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11 /Users/ficapy/Dropbox/source_read/py3/settrace.py call</span></span><br><span class="line"><span class="comment"># 12 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 13 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 14 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 14 /Users/ficapy/Dropbox/source_read/py3/settrace.py exception</span></span><br><span class="line"><span class="comment"># 15 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 16 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 12 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 13 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 14 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 12 /Users/ficapy/Dropbox/source_read/py3/settrace.py line</span></span><br><span class="line"><span class="comment"># 12 /Users/ficapy/Dropbox/source_read/py3/settrace.py return</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><br>有几点需要注意的:</p>
<ol>
<li>trace函数最后记得返回自身</li>
<li>不需要考虑多线程问题，因为sys.settrace只对主线程有效(多线程是threading.settrace，多进程没试过)</li>
<li>还是要废话一句，发生return的时候frame一定是最后一个call的frame。这也是pycallgraph的运行的基本条件。</li>
<li>虽然trace有7个事件。可是对于我们绘制调用图call、return就够了.</li>
</ol>
<h3 id="pycallgraph原理版本"><a href="#pycallgraph原理版本" class="headerlink" title="pycallgraph原理版本"></a>pycallgraph原理版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">call_dict = defaultdict(<span class="keyword">lambda</span>: defaultdict(int))</span><br><span class="line">frame_stack = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(frame, event, args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        frame_stack.append(frame)</span><br><span class="line">        call_dict[frame.f_back][frame] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'return'</span>:</span><br><span class="line">        <span class="keyword">if</span> frame <span class="keyword">is</span> frame_stack[-<span class="number">1</span>]:</span><br><span class="line">            frame_stack.pop()</span><br><span class="line">    <span class="keyword">return</span> trace</span><br><span class="line"></span><br><span class="line">sys.settrace(trace)</span><br><span class="line">requests.get(<span class="string">'http://www.z.cn'</span>)</span><br><span class="line">sys.settrace(<span class="keyword">None</span>)</span><br><span class="line">pprint(call_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># defaultdict(&lt;function &lt;lambda&gt; at 0x10f282950&gt;,</span></span><br><span class="line"><span class="comment">#             &#123;&lt;frame object at 0x10f199448&gt;: defaultdict(&lt;class 'int'&gt;,</span></span><br><span class="line"><span class="comment">#                                                         &#123;&lt;frame object at 0x10f303848&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                          &lt;frame object at 0x10f4f93d8&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                          &lt;frame object at 0x10f985980&gt;: 1&#125;),</span></span><br><span class="line"><span class="comment">#                                                         :</span></span><br><span class="line"><span class="comment">#                                                         :</span></span><br><span class="line"><span class="comment">#                                                         :</span></span><br><span class="line"><span class="comment">#              &lt;frame object at 0x7fa6630a2018&gt;: defaultdict(&lt;class 'int'&gt;,</span></span><br><span class="line"><span class="comment">#                                                            &#123;&lt;frame object at 0x10fd1b8b8&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x10fd2a9d0&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x10fd2f908&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x10fd32570&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x10fd3fac8&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x7fa662093cc8&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x7fa6621ddc98&gt;: 1,</span></span><br><span class="line"><span class="comment">#                                                             &lt;frame object at 0x7fa6621e0468&gt;: 1&#125;)&#125;)</span></span><br></pre></td></tr></table></figure>
<p>在每个函数调用的时候，将当前栈和上一个栈关联起来。所有的数据汇总就得到了requests.get的调用关系图。然后就可以兴奋的去用graphviz生成图片~(≧▽≦)/~啦啦啦，直接这样大概就生成了类似下面的图片<br><img src="https://ws2.sinaimg.cn/large/a25f7e36gw1f62u6liqvqj21kw0awdjr.jpg" alt="confusion_requests"><br>看起来很炫酷，其实嘛用没有，几百个元素线条一大堆，根本突出不了重点。<strong><code>所以收集数据是很容易的，最重要的是过滤数据，重点突出自己需要的数据</code></strong>这部分应该也是pycallgraph的重点要处理的部分(处理的并不好)。</p>
<h3 id="过滤不需要关注的函数"><a href="#过滤不需要关注的函数" class="headerlink" title="过滤不需要关注的函数"></a>过滤不需要关注的函数</h3><p>比如一个函数我们不需要关注。那么当call事件的时候我们只需要不把它加入到call_dict中。同时将当前栈长度设置为最大长度。那么该函数和被该函数调用的函数都不会被我们记录。pycallgraph的做法是:不加入到call_dict，只是对frame_stack列表加入一个空值。return事件也只是简单的pop移出(这样造成的结果就是该函数不被记录，可是该被该函数调用的其他函数只要不被规则过滤就会被记录)<br>通常过滤的条件会有:</p>
<ol>
<li>内置模块</li>
<li>私有函数</li>
<li>比如一些库有compat.py、datastructers.py、exceptions.py、utils.py这些模块常会被引用。可是对了解整个过程并没有什么帮助。反而会导致生成的图很混乱</li>
<li>某些库虽然被引用太多次也该被删除<br>总之就是根据需要关注的地方写过滤规则，生成合适的图~~<br>比如这样。。。。requests.get的<br><img src="https://ficapy.b0.upaiyun.com/blogimg/requests_get.png" alt="requests_get"><br>注意到这里有组(根据单个模块分)，实现的方式也很简单。可以查看我写的精简版的pycallgraph.<a href="https://gist.github.com/ficapy/a2601d44b1492c228732178e1bb3eb5e">https://gist.github.com/ficapy/a2601d44b1492c228732178e1bb3eb5e</a></li>
</ol>
<h3 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h3><p>因为目前没有用来分析多线程程序，所以只是大概了解了一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(frame, event, args,record=[])</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        record.append(frame)</span><br><span class="line">    <span class="keyword">elif</span> event == <span class="string">'return'</span>:</span><br><span class="line">        pre_frame = record.pop()</span><br><span class="line">        print(pre_frame <span class="keyword">is</span> frame)</span><br><span class="line">    <span class="keyword">return</span> trace</span><br><span class="line">threading.settrace(trace)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    threading.Thread(target=main).start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><br>可以看到稍有区别，因为它有多个栈，所以无法像单个那样用一个列表就添加、取出就能搞定。可能以后有需要我会添加上线程支持</p>
<h3 id="pycallgraph缺陷"><a href="#pycallgraph缺陷" class="headerlink" title="pycallgraph缺陷"></a>pycallgraph缺陷</h3><ol>
<li>更新缓慢，master版本是3年前的！文档也是</li>
<li>设置项有threaded.搞的是线程安全！sys.settrace在主线程是没有线程问题。我都没有想明白写线程这段是干啥子用的</li>
<li>没有突出过滤的重要性</li>
</ol>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://docs.python.org/3/library/sys.html#sys.settrace">官网sys.settrace</a><br><a href="http://tech.uc.cn/?p=1932">python程序的执行原理</a><br><a href="https://www.youtube.com/watch?v=YIhGbFW985c">PYCON-Dmitry Trofimov - Python Debugger Uncovered</a><br><a href="http://stackoverflow.com/questions/1156023/print-current-call-stack-from-a-method-in-python-code">Print current call stack from a method in Python code</a><br><a href="https://segmentfault.com/a/1190000000356018">常用的python调试工具</a><br><a href="http://www.jianshu.com/p/e44885a777f0">graphviz dot语言学习笔记</a><br><a href="https://github.com/ionelmc/python-hunter">Github_python-hunter</a><br><a href="https://github.com/alonho/pytrace">Github_pytrace</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用来生成函数调用图，这个工具可能名气比较大。因为看介绍就能看到好像可以生成比较帅气的图像。从源码层面看。其实这个工具是相当简单的，就是使用了sys.settrace接口,该接口常用于debug、profile(本文环境python3.5.1)。&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析" scheme="https://www.zoulei.net/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pyenv使用镜像加速</title>
    <link href="https://www.zoulei.net/2016/07/15/pyenv_use_mirror/"/>
    <id>https://www.zoulei.net/2016/07/15/pyenv_use_mirror/</id>
    <published>2016-07-15T00:57:02.000Z</published>
    <updated>2016-07-15T01:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>pyenv install 3.5.0</code>的时候直接去python.org官网下载源码进行编译。速度几kb每秒慢到无法自理。无奈用代理速度也不怎么样。再其次该项目的作者是自己写了一个<a href="https://github.com/yyuu/yyuu.github.com">pyenv镜像项目</a>的，只可惜更新频率远不如pyenv。导致安装一些新的版本无法使用公共代理</p>
<p>如果安装2.7.6你可以选择使用国内七牛的镜像。项目地址<a href="http://pyenv.qiniudn.com/pythons/">http://pyenv.qiniudn.com/pythons/</a>。执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PYTHON_BUILD_MIRROR_URL=&#34;http://pyenv.qiniudn.com/pythons/&#34;&#10;pyenv install 2.7.6</span><br></pre></td></tr></table></figure></p>
<p>就会使用七牛镜像进行下载速度非常快。<br>缺点就是除了网页上的一些版本。其他的都不支持了。七牛没有对这个项目进行更新</p>
<p>我们可以用迅雷或者其他可用的快速的方法把python源码下载到本地。自己开启一个镜像给自己用。这样就好了。比如执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ficapy@L ~&#62; pyenv install 3.5.0                                                                                                                                                                           &#10;Downloading Python-3.5.0.tgz...&#10;-&#62; https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tgz</span><br></pre></td></tr></table></figure></p>
<p>然后把<code>https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tgz</code>下载到本地。<br>再设置镜像地址<code>export PYTHON_BUILD_MIRROR_URL=&quot;http://127.0.0.1:8000/&quot;</code><br>到下载地址执行<code>python3 -m http.server</code><br>再次执行<code>pyenv install 3.5.0</code>发现还是从官网下载。不过此时查看http.server上有一条HEAD请求日志。-_-发现不是直接请问的文件名，而是一个64位的字符。将下载的文件名修改成那64位字符。在执行就ok了~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;pyenv install 3.5.0&lt;/code&gt;的时候直接去python.org官网下载源码进行编译。速度几kb每秒慢到无法自理。无奈用代理速度也不怎么样。再其次该项目的作者是自己写了一个&lt;a href=&quot;https://github.com/yyuu/
    
    </summary>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python描述符应用</title>
    <link href="https://www.zoulei.net/2016/07/10/python_descriptor/"/>
    <id>https://www.zoulei.net/2016/07/10/python_descriptor/</id>
    <published>2016-07-10T09:13:43.000Z</published>
    <updated>2016-08-02T03:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人认为python中描述符协议是一个比较神奇的存在，是因为如果你不去了解property的内部实现，没有深究别人写的__set__、__get__方法。或许写python很多年都对这个东西没什么了解。然而这玩意儿有时候真的挺好用的。本文不会详述描述符协议。会着重讲一个小例子。如果以前没有接触过描述符，请依次查看文末相关资料的两篇文章</p>
<a id="more"></a>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>描述符协议都是针对对象属性的访问。先要明白我们不会去针对一个全局的def使用property进行装饰。我们一般都是在类里面使用。可以对类的访问使用描述符(比较少用)，更常用的是针对类实例的访问使用描述符协议</p>
<h3 id="资料描述符和非资料描述符的区别"><a href="#资料描述符和非资料描述符的区别" class="headerlink" title="资料描述符和非资料描述符的区别"></a>资料描述符和非资料描述符的区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RevealAccess</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.val</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'error'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def __set__(self, obj, val):</span></span><br><span class="line">    <span class="comment">#     self.val = val</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    x = RevealAccess()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = MyClass()</span><br><span class="line">print(m.x)</span><br><span class="line">m.x = <span class="number">20</span></span><br><span class="line">print(m.__dict__)</span><br><span class="line">m.__dict__[<span class="string">'x'</span>] = <span class="number">1</span></span><br><span class="line">print(m.__dict__)</span><br><span class="line">print(m.x)</span><br><span class="line">print(m.__class__ <span class="keyword">is</span> type(m))</span><br></pre></td></tr></table></figure>
<p>首先，当对属性x进行访问的时候不是直接返回描述符对象，而是按照描述符规则执行了描述符对象的__get__等方法！资料描述符就是同时实现了__get__和__set__，区别就是是资料描述符的时候就按照资料描述符的__get__、__set__来。非资料描述符的时候那就先访问<code>instance.__dict__[&#39;x&#39;]</code>，没有就在按照非资料描述符的__get__来。上面的例子先注释掉__set__就是非资料描述符，对实例属性进行访问的时候先访问了instance.__dict__没有就使用了描述符对象的__get__方法。当为资料描述符的时候纵然对instance.__dict__设置了。依然会调用描述符对象。</p>
<h3 id="示例应用-property加强版，增加缓存-最简代码"><a href="#示例应用-property加强版，增加缓存-最简代码" class="headerlink" title="示例应用:property加强版，增加缓存(最简代码)"></a>示例应用:property加强版，增加缓存(最简代码)</h3><p>首先来一个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="decorator">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jammy</span><span class="params">(self,_cache=&#123;&#125;)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'result'</span> <span class="keyword">in</span> _cache:</span><br><span class="line">            <span class="keyword">return</span> _cache[<span class="string">'result'</span>]</span><br><span class="line">        print(<span class="string">'jammy called'</span>)</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">        _cache.update(&#123;<span class="string">'result'</span>:result&#125;)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.jammy)</span><br><span class="line">print(f.jammy)</span><br></pre></td></tr></table></figure><br>该方法使用python函数的默认参数只初始化一次对结果进行缓存。缺点比较明显。1.无法复用。2.对原函数进行了修改</p>
<p>下面看pyramid的实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reify</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, cls)</span>:</span></span><br><span class="line">        value = obj.__dict__[self.func.__name__] = self.func(obj)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="decorator">    @reify</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jammy</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'jammy called'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.jammy)</span><br><span class="line">print(f.jammy)</span><br></pre></td></tr></table></figure><br>使用的是非资料描述符，第一次对属性进行访问的时候，因为f.__dict__是没有jammy的。故而访问了描述符，在描述符__get__里面将结果加入到了f.__dict__里面。后面访问就没__get__什么事儿了。实现了对结果的缓存</p>
<p>再看werkzeug的实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cached_property</span><span class="params">(property)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, name=None, doc=None)</span>:</span></span><br><span class="line">        self.__name__ = func.__name__</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></span><br><span class="line">        obj.__dict__[self.__name__] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, type=None)</span>:</span></span><br><span class="line">        value = obj.__dict__.get(self.__name__)</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            value = self.func(obj)</span><br><span class="line">            obj.__dict__[self.__name__] = value</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="decorator">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jammy</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'jammy called'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.jammy)</span><br><span class="line">print(f.jammy)</span><br></pre></td></tr></table></figure><br>可以看到和资料描述符的基本一样。可以看到__set__基本没什么用，仅仅只是表面了这是一个资料描述符。而且同样的，为了方便也一样把结果存储到了f.__dict__里面</p>
<h3 id="getattr-、-getattribute"><a href="#getattr-、-getattribute" class="headerlink" title="__getattr__、__getattribute__"></a>__getattr__、__getattribute__</h3><p>虽然都有get，可是区别是很大的。<br>描述符是<code>控制对象某个属性的访问</code>(所以看到描述符对象一般主要用<code>__get__</code>，<code>__get__</code>)。<br><code>__getattr__</code>它<code>控制属性不存在的时候该咋办</code><br><code>__getattribute__</code>和上面相反，默认行为，从__dict__中找到属性值返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"looking up"</span>, attr</span><br><span class="line">        value = <span class="number">42</span></span><br><span class="line">        self.__dict__[attr] = value</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="keyword">print</span> f.x </span><br><span class="line"><span class="keyword">print</span> f.x</span><br><span class="line"><span class="comment">#output &gt;&gt;&gt; looking up x 42</span></span><br><span class="line"><span class="comment">#output &gt;&gt;&gt; 42</span></span><br><span class="line"></span><br><span class="line">f.x = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> f.x </span><br><span class="line"><span class="comment">#output &gt;&gt;&gt; 3</span></span><br></pre></td></tr></table></figure></p>
<p>再加一个类似的例子吧O_o(<a href="https://github.com/faif/python-patterns/blob/master/lazy_evaluation.py">https://github.com/faif/python-patterns/blob/master/lazy_evaluation.py</a>)</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://harveyqing.gitbooks.io/python-read-and-write/content/python_advance/python_descriptor.html">python官方文档描述符指南(译)</a><br><a href="http://www.geekfan.net/7862/">python描述符解密</a><br><a href="http://stackoverflow.com/questions/3278077/difference-between-getattr-vs-getattribute">Difference between __getattr__ vs __getattribute__</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人认为python中描述符协议是一个比较神奇的存在，是因为如果你不去了解property的内部实现，没有深究别人写的__set__、__get__方法。或许写python很多年都对这个东西没什么了解。然而这玩意儿有时候真的挺好用的。本文不会详述描述符协议。会着重讲一个小例子。如果以前没有接触过描述符，请依次查看文末相关资料的两篇文章&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://www.zoulei.net/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>wsgiref源码阅读</title>
    <link href="https://www.zoulei.net/2016/07/04/2016-07-04/"/>
    <id>https://www.zoulei.net/2016/07/04/2016-07-04/</id>
    <published>2016-07-04T09:32:07.000Z</published>
    <updated>2016-07-04T09:38:55.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code> _ _ _ ____ ____ _ ____ ____ ____    _ _  _ _  _ ____ ____ _ ___
 | | | [__  | __ | |__/ |___ |___    | |\ | |__| |___ |__/ |  |
 |_|_| ___] |__] | |  \ |___ |       | | \| |  | |___ |  \ |  |
+--------------------------+     +---------------------------------+
|    wsgiref.WSGIServer    |     |   wsgiref.WSGIRequestHandler    |
+--------------------------+     +---------------------------------+
              |
+-------------v------------+    +------------------------------------+
|  http.server.HTTPServer  |    | http.server.BaseHTTPRequestHandler |
+--------------------------+    +------------------------------------+

+--------------------------+    +------------------------------------+
|  socketserver.TCPServer  |    | socketserver.StreamRequestHandler  |
+--------------------------+    +------------------------------------+
                                        overload handle logic

Created with Monodraw
</code></pre><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt; _ _ _ ____ ____ _ ____ ____ ____    _ _  _ _  _ ____ ____ _ ___
 | | | [__  | __ | |__/ |___ |___    | |\ | |__| |___ |__/ |  |

    
    </summary>
    
      <category term="源码解析" scheme="https://www.zoulei.net/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>http.server源码阅读</title>
    <link href="https://www.zoulei.net/2016/07/02/http_server_note/"/>
    <id>https://www.zoulei.net/2016/07/02/http_server_note/</id>
    <published>2016-07-02T09:07:20.000Z</published>
    <updated>2016-07-02T10:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一章讲SocketServer模块，它将服务端根据监听套接字和连接套接字分为了2个部分(BaseServer/BaseRequestHandler)，而连接套接字类的处理方法相当简单，最终是一个handle函数就搞定了。http.server这个模块主要类BaseHTTPRequestHandle继承自BaseRequestHandle,对handle进行了一点点的加强，主要就是对http协议进行了简单的解析工作(源码版本Python3.5)</p>
<a id="more"></a>
<p>先上图为敬:D<br><img src="https://ficapy.b0.upaiyun.com/blogimg/httpserver_note.png" alt=""><br>这个模块只需要关心BaseHTTPRequestHandler类，其实里面还有个CGI处理类，不过这玩意儿估计也是上古神兽了。没关注的必要。</p>
<h3 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h3><ol>
<li>支持http版本0.9、1.0、1.1，区别就是0.9版本只有body。1.1版本显式支持keep-alive。为了支持keep-alive，代码中有多处处理逻辑</li>
<li>对于内容的解析主要是使用parse_request方法。该方法逻辑主要解析第一行request line。如果出错就直接调用send_error返回错误内容。header部分主要引入了email.parser.Parser进行解析</li>
<li>parser_request对<code>Except:100-continue</code>进行了特殊处理，见附录</li>
<li>返回status line和header是先使用send_response_only创建一个列表，然后调用send_header依次在列表中添加数据，最后调用end_headers发送数据</li>
<li><code>send_error函数就是一个回复的典范</code></li>
<li>剩下就是日志函数和几个辅助函数了</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> ThreadingTCPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handle</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    protocol_version = <span class="string">"HTTP/1.1"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.send_error(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span><span class="params">(self)</span>:</span></span><br><span class="line">        len = self.headers.get(<span class="string">'Content-Length'</span>)</span><br><span class="line">        data = self.rfile.read(int(len))</span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.send_header(<span class="string">'Content-Length'</span>, len)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(data)</span><br><span class="line"></span><br><span class="line">ThreadingTCPServer((<span class="string">''</span>, <span class="number">9999</span>), Handle).serve_forever()</span><br></pre></td></tr></table></figure>
<p>这是一个最简的http server。do_GET函数表面send_error就能够响应一个请求。do_POST函数参照send_error的逻辑只不过读取了客户端发送的body字段</p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><h6 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h6><p>这2个非常相近，具体区别我就不概述了。在写代码的时候很多人无脑self.xxx = xxx就搞了一个实例变量。大多数时候用实例变量都能够替代类变量的功能。这很容易让人忽略类变量的优点。①含义明确：这是这个类的所有实例共用的。②不需要重载<strong>init</strong>，这在继承的时候是很有用哒~~~，so，不要有事没事无脑在<strong>init</strong>里面self.xxx = xxx啦</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="http://www.laruence.com/2011/01/20/1840.html">Expect:100-continue</a><br><a href="https://docs.python.org/3.6/library/http.server.html?highlight=http.server#http.server.BaseHTTPRequestHandler">官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章讲SocketServer模块，它将服务端根据监听套接字和连接套接字分为了2个部分(BaseServer/BaseRequestHandler)，而连接套接字类的处理方法相当简单，最终是一个handle函数就搞定了。http.server这个模块主要类BaseHTTPRequestHandle继承自BaseRequestHandle,对handle进行了一点点的加强，主要就是对http协议进行了简单的解析工作(源码版本Python3.5)&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析" scheme="https://www.zoulei.net/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>SocketServer源码阅读</title>
    <link href="https://www.zoulei.net/2016/06/29/socketserver_note/"/>
    <id>https://www.zoulei.net/2016/06/29/socketserver_note/</id>
    <published>2016-06-29T03:53:14.000Z</published>
    <updated>2016-07-02T10:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>SocketServer.py这个文件700来行，除去注释大概300来行左右，据网友称该模块实乃学习类继承之典范。<br>要理解这个模块真的非常的简单，也让人体会到同步编程的简单性。另外我现在比较关注web编程，所以会比较关注tcp部分忽略掉udp(源码版本Python2.7.11)</p>
<a id="more"></a>
<h3 id="类继承关系"><a href="#类继承关系" class="headerlink" title="类继承关系"></a>类继承关系</h3><p>不说别的，单单看到这张图就能唬住好多人，感觉很高大上有没有<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">| BaseServer |</span><br><span class="line">+------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">| TCPServer |-------&gt;| UnixStreamServer |</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +--------------------+</span><br><span class="line">| UDPServer |-------&gt;| UnixDatagramServer |</span><br><span class="line">+-----------+        +--------------------+</span><br></pre></td></tr></table></figure></p>
<h3 id="同步处理类比"><a href="#同步处理类比" class="headerlink" title="同步处理类比"></a>同步处理类比</h3><p>服务端嘛，请允许我污一下，就像古装剧里面的怡红院，都有个门口接客的老鸨，有客户来就引进去然后交给失足少女。老鸨就是服务端的监听socket，失足少女就是具体处理的业务逻辑。可以写成如下伪代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket()</span><br><span class="line">s.bind((<span class="string">'localhost'</span>,<span class="number">9999</span>))</span><br><span class="line">s.listen(<span class="number">2048</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    client,addr = s.accept()</span><br><span class="line">    handle(client,addr,s)</span><br></pre></td></tr></table></figure>    </p>
<p>可以说socketserver就是由上面最基本的步骤，为了扩展性而写的代码。上面的伪代码handle(client,addr,s)是一部分，上面的分为另外一部分。</p>
<p>socketserver因为是同步的，所以理解起来比asyncore要简单许多。而且注释写的非常详尽，我就不详述BaseServer/BaseRequestHandler的类方法了，说一下几个有点意思的地方。</p>
<ol>
<li>BaseServer部分基本就代表了监听套接字，然而还是提供了2个对连接套接字的方法，就是处理完成之后关闭啦~~shutdown_request/close_request</li>
<li>handle_request方法和server_forever是非常相似的，区别就是handler_request只相应一个请求。大概是用来调试吧。该函数还调起了一个特别垃圾的handle<em>timeout函数。看名字是不是以为是对连接套接字的超时处理函数-</em>-，实际上是等多久还没来一个新连接会触发，可是这个需求基本没有。所以我非常认为这个handle_request仅仅用来调试一次而已</li>
<li>上面的伪代码并没有用到select，为什么socketserver就用到了，其实如果只是为了处理tcp那么此处是没有必要用select的，因为tcp需要accept而udp是直接recvfrom就好了。用select只是为了通知有数据来了。都是为了适应多种情况才用的select。另外需要注意的是它不是用的文件描述符，是直接用的self，这里只要self实现了file_no方法就可以了(参照官方文档)。还有select另外套了一个_eintr_retry函数。这里是因为某些情况下select会被操作系统中断而引发异常(比如使用single)</li>
<li>可以很明显的看到实现的ThreadingTCPServer是通过继承的方式实现的，实质就是处理连接套接字的时候使用多线程或者多进程,可以想到要实现相同的效果用装饰器同样是可以的</li>
<li>StreamRequestHandler中使用了socket.makefile将连接套接字分成了读和写2个类文件对象(只能是阻塞socket)。可以感受到的优势就是read(num)返回的长度是准确的，recv就没有这个优势</li>
<li>用到了threading.Event,这个地方我是没多搞明白。调用shutdown方法会中断循环从而关闭服务。一般会在处理线程调用这个。如果不是在处理线程调用那么会发生死锁。。。我能想到的只有这里</li>
</ol>
<h3 id="socks5-DEMO-引用自http-xiaoxia-org-2011-03-29-written-by-python-socks5-server"><a href="#socks5-DEMO-引用自http-xiaoxia-org-2011-03-29-written-by-python-socks5-server" class="headerlink" title="socks5 DEMO(引用自http://xiaoxia.org/2011/03/29/written-by-python-socks5-server/)"></a>socks5 DEMO(引用自<a href="http://xiaoxia.org/2011/03/29/written-by-python-socks5-server/">http://xiaoxia.org/2011/03/29/written-by-python-socks5-server/</a>)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, select, SocketServer, struct</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Socks5Handle</span><span class="params">(SocketServer.StreamRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tcprelay</span><span class="params">(self, sock, remote)</span>:</span></span><br><span class="line">        fdset = [sock, remote]</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            r, w, e = select.select(fdset, [], [])</span><br><span class="line">            <span class="keyword">if</span> sock <span class="keyword">in</span> r:</span><br><span class="line">                <span class="keyword">if</span> remote.send(sock.recv(<span class="number">4096</span>)) &lt;= <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> remote <span class="keyword">in</span> r:</span><br><span class="line">                <span class="keyword">if</span> sock.send(remote.recv(<span class="number">4096</span>)) &lt;= <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">'socks connection from '</span>, self.client_address)</span><br><span class="line">            sock = self.connection</span><br><span class="line">            <span class="comment"># 1. Version</span></span><br><span class="line">            sock.recv(<span class="number">262</span>)</span><br><span class="line">            sock.send(<span class="string">b"\x05\x00"</span>)</span><br><span class="line">            <span class="comment"># 2. Request</span></span><br><span class="line">            data = self.rfile.read(<span class="number">4</span>)</span><br><span class="line">            mode = ord(data[<span class="number">1</span>])</span><br><span class="line">            addrtype = ord(data[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">if</span> addrtype == <span class="number">1</span>:  <span class="comment"># IPv4</span></span><br><span class="line">                addr = socket.inet_ntoa(self.rfile.read(<span class="number">4</span>))</span><br><span class="line">            <span class="keyword">elif</span> addrtype == <span class="number">3</span>:  <span class="comment"># Domain name</span></span><br><span class="line">                addr = self.rfile.read(ord(sock.recv(<span class="number">1</span>)[<span class="number">0</span>]))</span><br><span class="line">            port = struct.unpack(<span class="string">'&gt;H'</span>, self.rfile.read(<span class="number">2</span>))</span><br><span class="line">            reply = <span class="string">b"\x05\x00\x00\x01"</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> mode == <span class="number">1</span>:  <span class="comment"># 1. Tcp connect</span></span><br><span class="line">                    remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                    remote.connect((addr, port[<span class="number">0</span>]))</span><br><span class="line">                    print(<span class="string">'Tcp connect to'</span>, addr, port[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    reply = <span class="string">b"\x05\x07\x00\x01"</span>  <span class="comment"># Command not supported</span></span><br><span class="line">                local = remote.getsockname()</span><br><span class="line">                reply += socket.inet_aton(local[<span class="number">0</span>]) + struct.pack(<span class="string">"&gt;H"</span>, local[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">except</span> socket.error:</span><br><span class="line">                <span class="comment"># Connection refused</span></span><br><span class="line">                reply = <span class="string">'\x05\x05\x00\x01\x00\x00\x00\x00\x00\x00'</span></span><br><span class="line">            sock.send(reply)</span><br><span class="line">            <span class="comment"># 3. Transfering</span></span><br><span class="line">            <span class="keyword">if</span> reply[<span class="number">1</span>] == <span class="string">'\x00'</span>:  <span class="comment"># Success</span></span><br><span class="line">                self.tcprelay(sock, remote)</span><br><span class="line">        <span class="keyword">except</span> socket.error:</span><br><span class="line">            print(<span class="string">'socket error'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    server = SocketServer.ThreadingTCPServer((<span class="string">''</span>, <span class="number">1081</span>), Socks5Handle)</span><br><span class="line">    server.serve_forever()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="和asyncore对比"><a href="#和asyncore对比" class="headerlink" title="和asyncore对比"></a>和asyncore对比</h3><p>asyncore和socketserver同样实现了并发。对比一下<br>1.从名字都可以看出来server。socketserver只能用来实现server，而asyncore还可以实现客户端<br>2.socketserver实现了多线程和多进程，asyncore框架是单线程事件循环</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://pymotw.com/2/SocketServer/index.html#module-SocketServer">SocketServer – Creating network servers.</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SocketServer.py这个文件700来行，除去注释大概300来行左右，据网友称该模块实乃学习类继承之典范。&lt;br&gt;要理解这个模块真的非常的简单，也让人体会到同步编程的简单性。另外我现在比较关注web编程，所以会比较关注tcp部分忽略掉udp(源码版本Python2.7.11)&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析" scheme="https://www.zoulei.net/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>asyncore源码阅读</title>
    <link href="https://www.zoulei.net/2016/06/29/asyncore_note/"/>
    <id>https://www.zoulei.net/2016/06/29/asyncore_note/</id>
    <published>2016-06-29T03:24:21.000Z</published>
    <updated>2016-07-02T10:24:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>asyncore为select.select、poll的封装(实际上现在大家都使用更为高效的epoll)，变成了框架的使用模式，该库已经作为兼容模式存在，新的库为asyncio。且在2和3中asyncore代码有一点点差异。(源码版本2.7.11)</p>
<a id="more"></a>
<h3 id="dispatcher类-调度"><a href="#dispatcher类-调度" class="headerlink" title="dispatcher类(调度)"></a>dispatcher类(调度)</h3><p>文件asyncore.py中最重要的类为dispatcher，使用的时候只需要继承asyncore.dispatcher就好了</p>
<p>可以这样理解每一个继承了asyncore.dispatcher的类都代表了一个socket(监听socket或者连接socket)</p>
<p>在asyncore.py的最开始有一个全局字典socket_map对应fd和一个asyncore.dispatcher类，当你继承一个dispatcher类的时候总会调用函数在全局字典socket_map中创建一个映射，当然在关闭的时候也会从全局字典中删除</p>
<p>最后是一个loop死循环，可以很容易想到是使用了系统IO多路复用接口select.select对全局socket_map进行了操作。根据返回的事件进行操作(3个事件读、写、错误)</p>
<p>源码中我们着重看dispatcher类，它可以划分为以下几个要点</p>
<ol>
<li>添加了4个状态，connected/accepting/connecting/closing，想想为什么要设置这几个状态呢？？？<br>connected:已经连接上对方,比如监听套接字sock,addr = socket.accept()返回的sock</li>
<li>add_channel/del_channel/create_socket/set_socket这几个都是针对全局字典socket_map的操作。添加进去或者删除</li>
<li>readable/writable 用的地方不是太多，预先确定该socket该不该添加到socket的可读可写里面</li>
<li>listen/bind/connect/accept/send/recv/close 这几个函数嘛，对原有的行为稍微改动了下，比如listen设置为accepting状态，connect设置为connecting状态，send,recv一定条件出发close，close即为从全局字典中删除并关闭socket</li>
<li>handle_read_event/handle_connect_event/handle_write_event.当select有事件返回的时候就是调用的这3个方法。只是需要注意。这里并不是最终执行的操作(send、recv等)！！！这里也体现了标注socket状态的作用，read可以分为监听(accepting)、连接完成后(connecting)→→→这里就是一个hook，如果自己调用connect连接那么完成后是此状态，可以自己重写handle_connect处理该事件，如果是直接初始化的socket则直接为connected状态。handle_write_event也很明显，当为connecting状态的时候处理hook，否则处理写入事件</li>
<li>最后这一部分基本就是使用者需要重写的部分了。handle_expt/handle_read/handle_write/handle_connect/handle_accept/handle_close含义很明白，就不表述了</li>
</ol>
<p>在后面就是dispatcher的继承类dispatcher_with_send和file_dispatcher，前者嘛，试想一下你要发送非常多内容，肯定调用一次send发不完。它就给你解决了这个问题，当然方法也很简单。后面就是为了高效发送文件而产生的了</p>
<h3 id="流程图示-以一个客户端为例"><a href="#流程图示-以一个客户端为例" class="headerlink" title="流程图示(以一个客户端为例)"></a>流程图示(以一个客户端为例)</h3><p><img src="https://ficapy.b0.upaiyun.com/blogimg/asyncore%E7%AE%80%E6%98%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h3 id="sockets5-DEMO"><a href="#sockets5-DEMO" class="headerlink" title="sockets5 DEMO"></a>sockets5 DEMO</h3><p>对于使用asyncore，官方的例子我觉得已经表现的非常到位了。下面我放出一个使用它写的简单socks5server(作为一个demo，只对tcp进行处理，没有写远程dns解析)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncore</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">sockets_map = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Socks5Listen</span><span class="params">(asyncore.dispatcher)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address=<span class="params">(<span class="string">'localhost'</span>, <span class="number">8081</span>)</span>)</span>:</span></span><br><span class="line">        asyncore.dispatcher.__init__(self)</span><br><span class="line">        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.set_reuse_addr()</span><br><span class="line">        self.bind(address)</span><br><span class="line">        self.listen(<span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_accept</span><span class="params">(self)</span>:</span></span><br><span class="line">        pair = self.accept()</span><br><span class="line">        <span class="keyword">if</span> pair <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            sock, addr = pair</span><br><span class="line">            print(<span class="string">'socks connection from '</span>, addr)</span><br><span class="line">            Local(sock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(asyncore.dispatcher_with_send)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sock)</span>:</span></span><br><span class="line">        asyncore.dispatcher_with_send.__init__(self, sock=sock)</span><br><span class="line">        self.read_buffer = <span class="string">''</span></span><br><span class="line">        self.status = <span class="string">'init'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        data = self.recv(num)</span><br><span class="line">        self.read_buffer += data</span><br><span class="line">        <span class="keyword">if</span> len(self.read_buffer) != num:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _ = self.read_buffer</span><br><span class="line">            self.read_buffer = <span class="string">''</span></span><br><span class="line">            <span class="keyword">return</span> _</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.status == <span class="string">'init'</span>:</span><br><span class="line">            self.recv(<span class="number">262</span>)</span><br><span class="line">            self.send(<span class="string">b"\x05\x00"</span>)</span><br><span class="line">            self.status = <span class="string">'request'</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.status == <span class="string">'request'</span>:</span><br><span class="line">            data = self.read(<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">            mode = ord(data[<span class="number">1</span>])</span><br><span class="line">            addrtype = ord(data[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">if</span> addrtype == <span class="number">1</span>:  <span class="comment"># IPv4</span></span><br><span class="line">                addr = self.read(<span class="number">4</span>)</span><br><span class="line">                <span class="keyword">if</span> addr <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">                addr = socket.inet_ntoa(addr)</span><br><span class="line">            <span class="keyword">elif</span> addrtype == <span class="number">3</span>:  <span class="comment"># Domain name</span></span><br><span class="line">                addr = self.read(ord(self.recv(<span class="number">1</span>)[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">if</span> addr <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">            port = self.read(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> port <span class="keyword">is</span> <span class="keyword">None</span>: <span class="keyword">return</span></span><br><span class="line">            port = struct.unpack(<span class="string">'&gt;H'</span>, port)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="number">1</span>:  <span class="comment"># 1. Tcp connect</span></span><br><span class="line">                remote = Remote(addr, port)</span><br><span class="line">                sockets_map[self] = remote</span><br><span class="line">                sockets_map[remote] = self</span><br><span class="line">                self.status = <span class="string">'transfer'</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                reply = <span class="string">b"\x05\x07\x00\x01"</span>  <span class="comment"># Command not supported</span></span><br><span class="line">                self.send(reply)</span><br><span class="line">                self.close()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.status == <span class="string">'transfer'</span>:</span><br><span class="line">            data = self.recv(<span class="number">2048</span>)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                sockets_map[self].send(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_expt</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.handle_close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        asyncore.dispatcher_with_send.handle_close(self)</span><br><span class="line">        remote = sockets_map.get(self)</span><br><span class="line">        <span class="keyword">if</span> remote:</span><br><span class="line">            <span class="keyword">del</span> sockets_map[remote]</span><br><span class="line">        <span class="keyword">if</span> self <span class="keyword">in</span> sockets_map:</span><br><span class="line">            <span class="keyword">del</span> sockets_map[self]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Remote</span><span class="params">(asyncore.dispatcher_with_send)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, addr, port)</span>:</span></span><br><span class="line">        asyncore.dispatcher_with_send.__init__(self)</span><br><span class="line">        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.connect((addr, port))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_connect</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Tcp connect to'</span>, self.addr)</span><br><span class="line">        local = self.socket.getsockname()</span><br><span class="line">        reply = <span class="string">b"\x05\x00\x00\x01"</span></span><br><span class="line">        reply += socket.inet_aton(local[<span class="number">0</span>]) + struct.pack(<span class="string">"&gt;H"</span>, local[<span class="number">1</span>])</span><br><span class="line">        sockets_map[self].socket.send(reply)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_read</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = self.recv(<span class="number">2048</span>)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            sockets_map[self].send(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_expt</span><span class="params">(self)</span>:</span></span><br><span class="line">        reply = <span class="string">'\x05\x05\x00\x01\x00\x00\x00\x00\x00\x00'</span></span><br><span class="line">        self.send(reply)</span><br><span class="line">        self.handle_close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        asyncore.dispatcher_with_send.handle_close(self)</span><br><span class="line">        local = sockets_map.get(self)</span><br><span class="line">        <span class="keyword">if</span> local:</span><br><span class="line">            <span class="keyword">del</span> sockets_map[local]</span><br><span class="line">        <span class="keyword">if</span> self <span class="keyword">in</span> sockets_map:</span><br><span class="line">            <span class="keyword">del</span> sockets_map[self]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = Socks5Listen()</span><br><span class="line">asyncore.loop()</span><br></pre></td></tr></table></figure>
<p>一个socks5服务端会有3类socket。所以会有三个类。</p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><h6 id="LEGB作用域"><a href="#LEGB作用域" class="headerlink" title="LEGB作用域"></a>LEGB作用域</h6><p>asyncore中使用全局字典socket_map记录映射。想到全局就会想到global<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">main()</span><br><span class="line"><span class="keyword">print</span> a</span><br></pre></td></tr></table></figure><br>可以注意到这里必须要有global关键字，然而换成字典。为何就不需要global了。实际上这里要关注的是对象的id,对于数字、字符串这些对象是不可变的，然而字典对象是可变的。要改变不可变变量实际是重新赋值，所以对于改变外部不可变变量要用global，可变对象不需要</p>
<h6 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h6><p>俗称好莱坞模式(Don’t call us, we will call you)。比如库函数sum你很容易想到给几个数字它返回给你和。框架嘛。就像上面的asyncore你需要的是继承dispatcher类然后重新一些方法。虽然它能达到目的，可是如果你不看源码或许你永远也无法明白框架在后面做了什么。从我个人的理解来看我是比较喜欢成熟的框架的。毕竟如果不用框架自己用库函数写最后也可能是一个框架，当然很可能是一个垃圾的框架:D</p>
<h6 id="为什么多路IO复用一定是配合的非阻塞socket"><a href="#为什么多路IO复用一定是配合的非阻塞socket" class="headerlink" title="为什么多路IO复用一定是配合的非阻塞socket"></a>为什么多路IO复用一定是配合的非阻塞socket</h6><p>妈蛋，这个问题各种说法真是太多了。想一想如果select返回给你一个fd可读，那么他一定是可读的。如果这样那么一般情况下我们用select配合阻塞socket也是可以的。可是现实不这样纸啊。unix手册中明确说明了不是这样的。所以工程上几乎没有见过配合阻塞socket使用的例子。另外asyncore种connect方法用的是connect_ex</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://docs.python.org/2/library/asyncore.html">官方文档</a></p>
<p><a href="https://www.zhihu.com/question/37271342">知乎:为什么IO多路复用要搭配非阻塞socket</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;asyncore为select.select、poll的封装(实际上现在大家都使用更为高效的epoll)，变成了框架的使用模式，该库已经作为兼容模式存在，新的库为asyncio。且在2和3中asyncore代码有一点点差异。(源码版本2.7.11)&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析" scheme="https://www.zoulei.net/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>socket.recv</title>
    <link href="https://www.zoulei.net/2016/06/17/socket_recv/"/>
    <id>https://www.zoulei.net/2016/06/17/socket_recv/</id>
    <published>2016-06-17T08:06:14.000Z</published>
    <updated>2016-06-17T10:29:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅讨论阻塞socket的情况。在v2ex上看到了2个提问，<a href="https://www.v2ex.com/t/236313">socket.recv 完整接收数据</a>、<a href="https://www.v2ex.com/t/269954">python socket 一个很简单的问题把我难住了</a>.主要会有2个方面。怎么判断数据是否传输完成了进行下一步操作。recv什么时候返回数据，返回多少字节</p>
<a id="more"></a>
<h3 id="从一个读取文件的例子开始说起"><a href="#从一个读取文件的例子开始说起" class="headerlink" title="从一个读取文件的例子开始说起"></a>从一个读取文件的例子开始说起</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'backup.py'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        buffer = f.read(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> len(buffer) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        data += buffer</span><br></pre></td></tr></table></figure>
<p>这个例子中read是一直有数据返回的，文件读取完成就会一直返回空字符，这样就能判断什么时候完成就停止循环进入下一步操作了。</p>
<p>可能有些人会应用到socket编程中，recv后得到字符串，判断字符串长度。当长度为0的时候就认为传输完成了。惊奇的是这样写大多数时候居然真的能正常使用。看起来没什么问题。下面是一个例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, time</span><br><span class="line"></span><br><span class="line">s = socket.socket()</span><br><span class="line">s.connect((<span class="string">'down.sandai.net'</span>, <span class="number">80</span>))</span><br><span class="line">s.send(<span class="string">"""GET /thunder7/Thunder_dl_7.9.43.5054.exe HTTP/1.1</span><br><span class="line">Host: down.sandai.net</span><br><span class="line">User-Agent: curl/7.43.0</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line">"""</span>)</span><br><span class="line"></span><br><span class="line">data = <span class="string">''</span></span><br><span class="line">wait_time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    ret = s.recv(<span class="number">2048</span>)</span><br><span class="line">    print(len(ret))</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">if</span> end - start &gt; wait_time:</span><br><span class="line">        wait_time = end - start</span><br><span class="line">    data += ret</span><br><span class="line">    <span class="keyword">if</span> len(ret) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(wait_time)</span><br></pre></td></tr></table></figure><br>上面这个例子请求迅雷下载链接获得数据，在网络正常的时候是没有什么问题的。最后的打印的wait_time大概30左右。这其实是数据传输完成到socket关闭的时间(因为服务端设置了Connection: Keep-Alive且为30秒)。从效率来说数据传输完成我们白白等待了30秒，其次更重要的是<code>仅仅对方服务器执行关闭操作s.recv才会返回空</code>。万一对方服务器没有写好一直不关闭连接怎么办(不要以为不关闭不可能，不信可以连一下z.cn试一试)。<code>所以从tcp层面来判断数据传输完成是不可取的</code>，这种需求需要在应用层完成。</p>
<p>拿应用最广泛的http协议来说。它有明显的传输完成标志。上面的程序改写一下(忽略异常处理，不对chunk进行处理)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, time, re</span><br><span class="line"></span><br><span class="line">s = socket.socket()</span><br><span class="line">s.connect((<span class="string">'down.sandai.net'</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">s.send(<span class="string">"""GET /thunder7/Thunder_dl_7.9.43.5054.exe HTTP/1.1</span><br><span class="line">Host: down.sandai.net</span><br><span class="line">User-Agent: curl/7.43.0</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line">"""</span>)</span><br><span class="line"></span><br><span class="line">length_re = re.compile(<span class="string">r'Content-Length: (\d+)'</span>,re.MULTILINE)</span><br><span class="line">length, body = -<span class="number">2</span>, -<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    ret = s.recv(<span class="number">2048</span>)</span><br><span class="line">    data += ret</span><br><span class="line">    <span class="keyword">if</span> body &gt; <span class="number">0</span>:</span><br><span class="line">        body += len(ret)</span><br><span class="line">    <span class="keyword">if</span> body == length:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> length == -<span class="number">1</span> <span class="keyword">and</span> <span class="string">'\r\n\r\n'</span> <span class="keyword">in</span> data:</span><br><span class="line">        length = int(length_re.search(data).group(<span class="number">1</span>))</span><br><span class="line">        body = len(data.split(<span class="string">'\r\n\r\n'</span>)[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> length == body:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> len(ret) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(length)</span><br><span class="line">print(len(data))</span><br><span class="line">print(body)</span><br></pre></td></tr></table></figure><br>根据http应用层协议当服务端返回内容的时候，获取Content-Length头部内容然后recv接收所有需要内容后<code>主动关闭连接</code>,这样就不需要等待服务器关闭连接了。</p>
<p>另外recv或许还有一个比较容易曲解的地方recv(maxsize)并不是阻塞到直到获取到maxsize长度后才返回。这个地方可以这样理解，把这个IO流当做一个盒子。当盒子里面没有内容的时候recv是阻塞的。某一时刻盒子里面放进了一些内容，不管放进了多少recv会读取最多maxsize内容返回。顺便说一下epoll中边缘触发(edge-triggered)和水平触发(level-triggered)的理解。边缘触发就是当这个盒子中放进数据的时候我通知你一下。水平触发就是当这个盒子中还有数据没有取出的时候我通知你一下。这样就造成了使用边缘触发当通知的时候必须处理完该IO流(试想一下如果你第上一个通知没有处理完，下一个通知的时候也可以处理，依次递推可能造成最后一个通知没有处理完，因为没有下一个通知哒，所以漏处理了一些IO流)</p>
<p><em>总结来说就是2个方面。1.recv(maxsize)一有数据就返回并不是积累到maxsize长度再返回。2.判断传输完成不是TCP层面做的事情，应该在应用层处理</em></p>
<h3 id="其他的一些"><a href="#其他的一些" class="headerlink" title="其他的一些"></a>其他的一些</h3><h6 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h6><p>tcp层面的:是表示当没有tcp报文的时候发送tcp报文给对方。实际上TCP协议规范是只有2小时没有tcp交互才会关闭TCP连接的，可是现实中各种NAT设备并没有遵循该规范，毕竟和性能有关联,如果长时间没有tcp包交互那么可能会中断该TCP连接，此时就有了tcp层面的keepalive，当没有tcp包的时候会自动发送。你以为这样就完了，too naive！有的NAT设备会当tcp中长时间没有有效荷载的时候中断该连接。于是乎有的应用在应用层每隔一段时间发送一个echo数据这样子就能够避免这种情况了。下图设置了keepalive同时对socket设置超时的情况<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_keepalive_linux</span><span class="params">(sock, after_idle_sec=<span class="number">1</span>, interval_sec=<span class="number">3</span>, max_fails=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Set TCP keepalive on an open socket.</span><br><span class="line"></span><br><span class="line">    It activates after 1 second (after_idle_sec) of idleness,</span><br><span class="line">    then sends a keepalive ping once every 3 seconds (interval_sec),</span><br><span class="line">    and closes the connection after 5 failed ping (max_fails), or 15 seconds</span><br><span class="line">    """</span></span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, <span class="number">1</span>)</span><br><span class="line">    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, after_idle_sec)</span><br><span class="line">    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, interval_sec)</span><br><span class="line">    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, max_fails)</span><br><span class="line"></span><br><span class="line">s.settimeout(<span class="number">10</span>)</span><br><span class="line">set_keepalive_osx(s)</span><br></pre></td></tr></table></figure><br>下图是抓包结果<br><img src="https://ficapy.b0.upaiyun.com/blogimg/2016_06_17_15_47_21.png" alt=""><br>可以看到数据传输完成后每隔3秒钟发送了一个tcp包。由于同时设置了settimeout，十秒后没有tcp荷载，客户端断开了连接(<em>注意settimeout设置为秒只对阻塞模式有效</em>)</p>
<p>http层面的:这个就简单了，http1.0版本以前是请求→返回模式，请求一次就关闭了。因为tcp建立连接是挺耗时的，于是就有了一次数据来回就并不关闭下一个请求接着用。</p>
<h6 id="超时检测"><a href="#超时检测" class="headerlink" title="超时检测"></a>超时检测</h6><p>我觉得一个好的socket程序肯定会有超时机制和断线重连机制。上面的2个示例。测试中途断开网络再次重连接，会一直卡在recv阶段，对于一个死的TCP链接如果程序无法感知一直卡着绝对是无法接受的。如果是阻塞socket的超时我们只需要设置setttimeout就好了。配合应用层的echo也可以实现长连接。如果使用epoll这些那么settimeout就不行了，就需要自己维护状态检查~~~</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="http://stackoverflow.com/questions/12248132/how-to-change-tcp-keepalive-timer-using-python-script">How to change tcp keepalive timer using python script?</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文仅讨论阻塞socket的情况。在v2ex上看到了2个提问，&lt;a href=&quot;https://www.v2ex.com/t/236313&quot;&gt;socket.recv 完整接收数据&lt;/a&gt;、&lt;a href=&quot;https://www.v2ex.com/t/269954&quot;&gt;python socket 一个很简单的问题把我难住了&lt;/a&gt;.主要会有2个方面。怎么判断数据是否传输完成了进行下一步操作。recv什么时候返回数据，返回多少字节&lt;/p&gt;
    
    </summary>
    
      <category term="network" scheme="https://www.zoulei.net/categories/network/"/>
    
    
  </entry>
  
  <entry>
    <title>https笔记</title>
    <link href="https://www.zoulei.net/2016/06/01/https_note/"/>
    <id>https://www.zoulei.net/2016/06/01/https_note/</id>
    <published>2016-06-01T13:54:21.000Z</published>
    <updated>2016-06-01T16:51:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这年头网络劫持如此普遍，作为搞web开发的说不了解点https都不好意思。简单理解https可以非常简单，可是一旦上升到密码学。ヾ(｡｀Д´｡)牵扯到的概念真是太多了太特么复杂了。鄙人还是从个人实用角度出发。简洁记录一下https相关内容,另外本文作为回顾尚可，不适合作为初次了解https的参考。</p>
<a id="more"></a>
<p>从最简单的角度来说。简单理解HTTPS理解以下字段就好了<code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>.任何稍有常识的程序员一定对RSA公私钥体系有所耳闻。以小白的眼光从最简单的角度来看。第一个请求向服务器请求公匙，服务器返回公匙。客户端验证公匙。客户端使用公匙加密一个密钥传递给服务器，然后就用这个密匙使用AES加密传输数据就完事儿了。妈蛋多好理解啊，可是现实环境总是灰常复杂的T_T。不过总体而言也差不了多少。上图2张。<br><img src="https://ficapy.b0.upaiyun.com/blogimg/ssl_handshake_rsa.jpg" alt=""><br><img src="https://ficapy.b0.upaiyun.com/blogimg/2016_06_01_23_20_38.png" alt=""></p>
<p>wireshark中总体给出了灰常重要的几个关键词</p>
<ul>
<li>①Client Hello(发送客户端随机数，支持clipher，一些Extension，最知名的Extension应该是SNI，灰常好理解，就是表明是请求的哪个域名，这样就能够一个IP上放置N个证书哒，然后还有个有趣的东东<a href="https://github.com/dlundquist/sniproxy">sniproxy</a>)</li>
<li>②Server Hello(发送服务端随机数，返回商量好的clipher) </li>
<li>③Certificate(服务端返回公钥链)</li>
<li>④Client Key Exchange(就是传递一个密匙哒)Change Cipher Spec(没啥用TLS1.3已被移出)Finished(发送一段加密的验证数据让服务端验证，包含前面几步的一些信息)</li>
<li>⑤New Session Ticket(你看上面那么多流程，这里缓存一下结果哒，想要快一点下次直接传ticket就可以省掉好多步骤哒，<code>https优化第一事项</code>)Change Cipher Spec(同上没啥用)Finished(发送一段加密的验证数据让客户端验证)</li>
<li>⑥Over，开始用AES加密传输</li>
</ul>
<p>上面的步骤协商的clipher suite是TLS_RSA_WITH_AES_128_GCM_SHA256，事实上现在只要你自己不做死，是绝不可能出现这种不安全的clipher suite。因为执行openssl cliphers将会看到所有的RSA都会搭配DH算法一起使用，不会单独存在RSA(鄙人开始自己想看看没有DH交换的https交互是怎样的配置了好半天没成功，因为要自己编译openssl，如果不是灰常了解真做不了这个死。后来偶然发现阿里云CDN配置的https符合试验要求)</p>
<p>为什么不安全，因为想想看啊，wireshark作为一个嗅探抓包工具，导入个证书就能解密传输数据哒。这就意味着只要别人捕获了你的数据那么有朝一日搞到了你的证书私钥就能解密数据。其实也很好理解，因为这里最终协商的密匙是由3个部分组成2个随机数和使用公钥加密的那个字段，只要别人有了私匙就能用同样的办法计算得到最终的AES加密密匙。由此引入了一个DH密匙交换体系</p>
<p>介个DH交换咱就不说原理了，可以参照后文参考链接，大意就是双方共有一个key，然后我给你发一个随机明文，你给我发一个随机明文。<code>最后双方就灰常神奇了拥有了同样的密匙</code>，达到了密匙交换的目的。可是密匙交换体系有个脆弱的地方。如果第三方知道了共有的那个key，就能够被中间人(自己想一下为什么)~~~,引入密匙交换，握手交互就成了下图的样子<br><img src="http://ficapy.b0.upaiyun.com/blogimg/ssl_handshake_diffie_hellman.jpg" alt=""><br>这样上面的RSA密匙交换变成了DH交换，就有了PSF(向前安全性,即使有了私钥，那么别人也无法解密以前捕获的数据，因为DH交换的那个密匙算不出来嘛)。可是有了证书之后是可以用来中间人的(想想DH的弱项，要不为何叫向前安全性呢23333)</p>
<h2 id="HSTS-HPKP"><a href="#HSTS-HPKP" class="headerlink" title="HSTS,HPKP"></a>HSTS,HPKP</h2><p>HSTS:想一想你在地址栏输入一个网址你会去完全输入<em><a href="http://www.taobao.com">http://www.taobao.com</a></em>吗，当然不会！！好多人都会直接输入<em>taobao.com</em>（当然更多的人会去百毒淘宝）,那么浏览器怎么知道你要访问<em><a href="http://taobao.com">http://taobao.com</a></em>还是<em><a href="https://taobao.com">https://taobao.com</a></em>呢。毕竟https如此安全肯定是首选，然后就有了个http请求头类似下面这个样子<code>Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</code>客户端第一次收到这种请求就知道了下次要是再访问，那么将直接使用https不再使用http协议，增加安全性避免降级攻击（可以看到凡是开了https的大站点都必定开了此字段并且设置的很长）</p>
<p>HPKP:相反这个东西就没多大用了╮(╯▽╰)╭，可以试试效果，用chrome或者firefox先访问<em><a href="https://scotthelme.co.uk/">https://scotthelme.co.uk/</a></em> 再访问<em><a href="https://hpkp.scotthelme.co.uk/">https://hpkp.scotthelme.co.uk/</a></em> 会报隐私设置错误。为毛呢，因为有一个header字段是这样的<code>Public-Key-Pins: pin-sha256=&quot;X3pGTSOuJeEVw989IJ/cEtXUEmy52zs1TZQrU06KUKg=&quot;; pin-sha256=&quot;MHJYVThihUrJcxW6wcqyOISTXIsInsdj3xK8QrZbHec=&quot;; pin-sha256=&quot;isi41AizREkLvvft0IRW4u3XMFR2Yg7bvrF7padyCJg=&quot;; pin-sha256=&quot;I/bAACUzdYEFNw2ZKRaypOyYvvOtqBzg21g9a5WVClg=&quot;; pin-sha256=&quot;Y4/Gxyck5JLLnC/zWHtSHfNljuMbOJi6dRQuRJTgYdo=&quot;; pin-sha256=&quot;/oCVQg3nP3DroGpFdAbaiYzenycUftqrH3LAyaIal2g=&quot;; pin-sha256=&quot;0PiItvsnLZy1slbsVPGky8YnDsJavMNtxD0TPwsCdC8=&quot;; pin-sha256=&quot;t3EPvqF+7XoKypCPHyN1b5uey7zTfIGDHn4oBWz2pds=&quot;; pin-sha256=&quot;zqbcEslrpiH0bA9uhNyl2ovpLEfGJQM/QvZSVumMFJ8=&quot;; pin-sha256=&quot;V+J+7lHvE6X0pqGKVqLtxuvk+0f+xowyr3obtq8tbSw=&quot;; pin-sha256=&quot;Myokb3mG16eRkVBE+ZmFSKSpYQzWHKMY1MZbXgA8BkQ=&quot;; pin-sha256=&quot;WSg/oQliyMYyP6yZ0CzDdQ8PHmtUkoUsOsa5svxxXxo=&quot;; pin-sha256=&quot;9lBW+k9EF6yyG9413/fPiHhQy5Ok4UI5sBpBTuOaa/U=&quot;; pin-sha256=&quot;ipMu2Xu72A086/35thucbjLfrPaSjuw4HIjSWsxqkb8=&quot;; pin-sha256=&quot;6OnjvIKf0SxyerXzg9N0RvQ2sgaL6niV+MLn9wBrh+s=&quot;; pin-sha256=&quot;9dNiZZueNZmyaf3pTkXxDgOzLkjKvI+Nza0ACF5IDwg=&quot;; max-age=2592000; includeSubDomains; report-uri=&quot;https://scotthelme.report-uri.io/r/default/hpkp/enforce&quot;</code>它里面包含了公钥信息，如果和服务端返回的公钥不合那么会报错，为什么会有这个字段嘞，想想CA机制，任何一个可信根证书都能给任意域名提供签名证书然后能骗过浏览器进行中间人(类似实现比如<a href="https://github.com/droe/sslsplit">sslsplit</a>)，该情况就能防止这种情况发生。理想很丰满，现实很骨感，这个字段根本没什么人用，仅有有限的几个网站对此进行了设置，原因就是ヾ(｡｀Д´｡)CA跑去伪造你的域名的概率实在太特么小了，另外HSTS和HPKP都有一个特点那就是第一次访问没有被劫持，只有客户端收到了一个正确的HSTS设置才能对后面的请求发生作用。另外HKPK在浏览器设置代理的情况下是不启用的(应该是为了方便调试)，虽然HPKP如此的废柴。可是在另外一个地方实施却是不错的选择，如果你在APP上添加HPKP验证就能防止那些用fiddler抓包的小白，让抓包失效。如果要抓包请反编译APP去掉HPKP逻辑→_→</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://cattail.me/tech/2015/11/30/how-https-works.html">https原理简版</a><br><a href="https://blog.helong.info/blog/2015/09/06/tls-protocol-analysis-and-crypto-protocol-design/">见过最完整的https中文博文</a><br><a href="https://scotthelme.co.uk/">国外讲解https比较多的博客</a><br><a href="https://imququ.com">国内讲解https比较多的博客</a><br><a href="http://www.uuu.com.tw/Public/content/article/140825tips.htm">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</a><br><a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">Diffie-Hellman中文维基</a><br><a href="https://github.com/datatheorem/TrustKit">ios public key pinning</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这年头网络劫持如此普遍，作为搞web开发的说不了解点https都不好意思。简单理解https可以非常简单，可是一旦上升到密码学。ヾ(｡｀Д´｡)牵扯到的概念真是太多了太特么复杂了。鄙人还是从个人实用角度出发。简洁记录一下https相关内容,另外本文作为回顾尚可，不适合作为初次了解https的参考。&lt;/p&gt;
    
    </summary>
    
      <category term="network" scheme="https://www.zoulei.net/categories/network/"/>
    
    
  </entry>
  
</feed>
