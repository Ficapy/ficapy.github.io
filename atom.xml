<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>邹雷</title>
  <subtitle>刨过的坑,自己慢慢来填</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zoulei.net/"/>
  <updated>2018-03-16T07:39:45.556Z</updated>
  <id>https://www.zoulei.net/</id>
  
  <author>
    <name>ficapy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tornado 之WSGI</title>
    <link href="https://www.zoulei.net/2018/03/16/tornado_wsgi/"/>
    <id>https://www.zoulei.net/2018/03/16/tornado_wsgi/</id>
    <published>2018-03-16T03:28:02.000Z</published>
    <updated>2018-03-16T07:39:45.556Z</updated>
    
    <content type="html"><![CDATA[<p>WSGI毕竟是Python社区官方认可的规范，可是这种规范在多线程多进程模式下实现很简单，不太适合单线程异步这种情况。鉴于此Tornado并没有按照这个框架去实现一个WSGI的web框架，可是它却提供了基本的兼容，1.允许Tornado的application对象转变成WSGI application。2. 允许WSGI application在tornado ioloop中执行，只是这一切都不是完美的，它仅仅提供了基本的兼容，效率和可用性得不到保证。因此个人还是感觉很鸡肋的</p>
<a id="more"></a>
<h3 id="回顾WSGI"><a href="#回顾WSGI" class="headerlink" title="回顾WSGI"></a>回顾WSGI</h3><p>wsgi由<a href="https://www.python.org/dev/peps/pep-0333/">PEP333</a>开始，在<a href="https://www.python.org/dev/peps/pep-3333/">PEP3333</a>得到增强。分为两部分，一部分为容器，另一部分为应用。应用的最简形式如下<br>传入environ基础环境字典(必须包含一些值)和回调函数，最终返回一个可迭代对线<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    status = <span class="string">'200 OK'</span></div><div class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</div><div class="line">    start_response(status, response_headers)</div><div class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</div></pre></td></tr></table></figure><br>对于容器。则是每接收到一个http请求则调用一次应用。这样的好处是容器和应用可以完全隔离，应用可以使用任意容器来执行</p>
<h3 id="Tornado-application转变成WSGI-application"><a href="#Tornado-application转变成WSGI-application" class="headerlink" title="Tornado application转变成WSGI application"></a>Tornado application转变成WSGI application</h3><p>实现效果如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado.web</div><div class="line"><span class="keyword">import</span> tornado.wsgi</div><div class="line"><span class="keyword">import</span> wsgiref.simple_server</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        self.write(<span class="string">"Hello, world"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    application = tornado.wsgi.WSGIApplication([</div><div class="line">        (<span class="string">r"/"</span>, MainHandler),</div><div class="line">    ])</div><div class="line">    server = wsgiref.simple_server.make_server(<span class="string">''</span>, <span class="number">8888</span>, application)</div><div class="line">    server.serve_forever()</div></pre></td></tr></table></figure></p>
<p>在Tornado里面application接受一个参数调用，传入Requests对象。调用的结果是最终生成header以及handler._write_buffer对象(会触发iostream的写事件，最终由IOLoop触发socket写操作)。因此虽然它执行了RequestsHandler._execute操作，实际并没有发生socket发送操作，我们可以从handler对象取得完整的HTTP回复报文。然后调用start_response和返回一个可迭代对象<br>可以看到重点就是从WSGI server传递的environ字典里面重组出一个Request对象(模拟到和httpserver模块中的HTTPRequest对象一样)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIApplication</span><span class="params">(web.Application)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=<span class="string">""</span>, **settings)</span>:</span></div><div class="line">        web.Application.__init__(self, handlers, default_host, transforms=[],</div><div class="line">                                 wsgi=<span class="keyword">True</span>, **settings)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></div><div class="line">        handler = web.Application.__call__(self, HTTPRequest(environ))</div><div class="line">        <span class="keyword">assert</span> handler._finished</div><div class="line">        status = str(handler._status_code) + <span class="string">" "</span> + \</div><div class="line">            httplib.responses[handler._status_code]</div><div class="line">        headers = handler._headers.items()</div><div class="line">        <span class="keyword">for</span> cookie_dict <span class="keyword">in</span> getattr(handler, <span class="string">"_new_cookies"</span>, []):</div><div class="line">            <span class="keyword">for</span> cookie <span class="keyword">in</span> cookie_dict.values():</div><div class="line">                headers.append((<span class="string">"Set-Cookie"</span>, cookie.OutputString(<span class="keyword">None</span>)))</div><div class="line">        start_response(status, headers)</div><div class="line">        <span class="keyword">return</span> handler._write_buffer</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPRequest</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure><br>可以看到重点就是从environ里面构建出一个兼容httpserver的HTTPRequest对象。另外由于IOLoop在这种情况下不允许使用，所以依赖IOLoop的异步特性也就不存在了。而且连同多线程的特性也不在存在。所以只是一个玩具罢了吧</p>
<h3 id="在Tornado中运行WSGI-application"><a href="#在Tornado中运行WSGI-application" class="headerlink" title="在Tornado中运行WSGI application"></a>在Tornado中运行WSGI application</h3><p>上面的是将tornado的应用转变成WSGI兼容，然后让WSGI的容器去运行。这一个是反过来，让tornado作为容器去运行WSGI应用。实现这样的效果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    status = <span class="string">"200 OK"</span></div><div class="line">    response_headers = [(<span class="string">"Content-type"</span>, <span class="string">"text/plain"</span>)]</div><div class="line">    start_response(status, response_headers)</div><div class="line">    <span class="keyword">return</span> [<span class="string">"Hello world!\n"</span>]</div><div class="line"></div><div class="line">container = tornado.wsgi.WSGIContainer(simple_app)</div><div class="line">http_server = tornado.httpserver.HTTPServer(container)</div><div class="line">http_server.listen(<span class="number">8888</span>)</div><div class="line">tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>
<p>tornado.httpserver.HTTPServer会调用函数并传入一个Request对象。<span style="color:red"><strong>刚好和上面的过程相反</strong></span>。将Request对象分割为<code>environ</code>和<code>start_response</code>。直接贴1.0.0的原始代码吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIContainer</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, wsgi_application)</span>:</span></div><div class="line">        self.wsgi_application = wsgi_application</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, request)</span>:</span></div><div class="line">        data = &#123;&#125;</div><div class="line">        response = []</div><div class="line">        <span class="comment"># 将status和headers放入字典中,后续调用则写入body</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></div><div class="line">            data[<span class="string">"status"</span>] = status</div><div class="line">            data[<span class="string">"headers"</span>] = response_headers</div><div class="line">            <span class="keyword">return</span> response.append</div><div class="line">        <span class="comment"># wsgi app最终返回可迭代对象作为body</span></div><div class="line">        app_response = self.wsgi_application(</div><div class="line">            WSGIContainer.environ(request), start_response)</div><div class="line">        response.extend(app_response)</div><div class="line">        body = <span class="string">""</span>.join(response)</div><div class="line">        <span class="keyword">if</span> hasattr(app_response, <span class="string">"close"</span>):</div><div class="line">            app_response.close()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data: <span class="keyword">raise</span> Exception(<span class="string">"WSGI app did not call start_response"</span>)</div><div class="line">        <span class="comment"># 组合成整个http报文</span></div><div class="line">        status_code = int(data[<span class="string">"status"</span>].split()[<span class="number">0</span>])</div><div class="line">        headers = data[<span class="string">"headers"</span>]</div><div class="line">        header_set = set(k.lower() <span class="keyword">for</span> (k,v) <span class="keyword">in</span> headers)</div><div class="line">        body = escape.utf8(body)</div><div class="line">        <span class="keyword">if</span> <span class="string">"content-length"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</div><div class="line">            headers.append((<span class="string">"Content-Length"</span>, str(len(body))))</div><div class="line">        <span class="keyword">if</span> <span class="string">"content-type"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</div><div class="line">            headers.append((<span class="string">"Content-Type"</span>, <span class="string">"text/html; charset=UTF-8"</span>))</div><div class="line">        <span class="keyword">if</span> <span class="string">"server"</span> <span class="keyword">not</span> <span class="keyword">in</span> header_set:</div><div class="line">            headers.append((<span class="string">"Server"</span>, <span class="string">"TornadoServer/0.1"</span>))</div><div class="line"></div><div class="line">        parts = [<span class="string">"HTTP/1.1 "</span> + data[<span class="string">"status"</span>] + <span class="string">"\r\n"</span>]</div><div class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> headers:</div><div class="line">            parts.append(escape.utf8(key) + <span class="string">": "</span> + escape.utf8(value) + <span class="string">"\r\n"</span>)</div><div class="line">        parts.append(<span class="string">"\r\n"</span>)</div><div class="line">        parts.append(body)</div><div class="line">        <span class="comment"># 发送完成</span></div><div class="line">        request.write(<span class="string">""</span>.join(parts))</div><div class="line">        request.finish()</div><div class="line">        self._log(status_code, request)</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">environ</span><span class="params">(request)</span>:</span></div><div class="line">        hostport = request.host.split(<span class="string">":"</span>)</div><div class="line">        <span class="keyword">if</span> len(hostport) == <span class="number">2</span>:</div><div class="line">            host = hostport[<span class="number">0</span>]</div><div class="line">            port = int(hostport[<span class="number">1</span>])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            host = request.host</div><div class="line">            port = <span class="number">443</span> <span class="keyword">if</span> request.protocol == <span class="string">"https"</span> <span class="keyword">else</span> <span class="number">80</span></div><div class="line">        environ = &#123;</div><div class="line">            <span class="string">"REQUEST_METHOD"</span>: request.method,</div><div class="line">            <span class="string">"SCRIPT_NAME"</span>: <span class="string">""</span>,</div><div class="line">            <span class="string">"PATH_INFO"</span>: request.path,</div><div class="line">            <span class="string">"QUERY_STRING"</span>: request.query,</div><div class="line">            <span class="string">"REMOTE_ADDR"</span>: request.remote_ip,</div><div class="line">            <span class="string">"SERVER_NAME"</span>: host,</div><div class="line">            <span class="string">"SERVER_PORT"</span>: port,</div><div class="line">            <span class="string">"SERVER_PROTOCOL"</span>: request.version,</div><div class="line">            <span class="string">"wsgi.version"</span>: (<span class="number">1</span>, <span class="number">0</span>),</div><div class="line">            <span class="string">"wsgi.url_scheme"</span>: request.protocol,</div><div class="line">            <span class="string">"wsgi.input"</span>: cStringIO.StringIO(escape.utf8(request.body)),</div><div class="line">            <span class="string">"wsgi.errors"</span>: sys.stderr,</div><div class="line">            <span class="string">"wsgi.multithread"</span>: <span class="keyword">False</span>,</div><div class="line">            <span class="string">"wsgi.multiprocess"</span>: <span class="keyword">True</span>,</div><div class="line">            <span class="string">"wsgi.run_once"</span>: <span class="keyword">False</span>,</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> <span class="string">"Content-Type"</span> <span class="keyword">in</span> request.headers:</div><div class="line">            environ[<span class="string">"CONTENT_TYPE"</span>] = request.headers[<span class="string">"Content-Type"</span>]</div><div class="line">        <span class="keyword">if</span> <span class="string">"Content-Length"</span> <span class="keyword">in</span> request.headers:</div><div class="line">            environ[<span class="string">"CONTENT_LENGTH"</span>] = request.headers[<span class="string">"Content-Length"</span>]</div><div class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> request.headers.iteritems():</div><div class="line">            environ[<span class="string">"HTTP_"</span> + key.replace(<span class="string">"-"</span>, <span class="string">"_"</span>).upper()] = value</div><div class="line">        <span class="keyword">return</span> environ</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_log</span><span class="params">(self, status_code, request)</span>:</span></div><div class="line">        <span class="keyword">if</span> status_code &lt; <span class="number">400</span>:</div><div class="line">            log_method = logging.info</div><div class="line">        <span class="keyword">elif</span> status_code &lt; <span class="number">500</span>:</div><div class="line">            log_method = logging.warning</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            log_method = logging.error</div><div class="line">        request_time = <span class="number">1000.0</span> * request.request_time()</div><div class="line">        summary = request.method + <span class="string">" "</span> + request.uri + <span class="string">" ("</span> + \</div><div class="line">            request.remote_ip + <span class="string">")"</span></div><div class="line">        log_method(<span class="string">"%d %s %.2fms"</span>, status_code, summary, request_time)</div></pre></td></tr></table></figure></p>
<p>主要是将Requests转变成environ，传入给WSGI应用。最终根据应用的返回重组成一个HTTP回复报文字符串调用发送逻辑，流程完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WSGI毕竟是Python社区官方认可的规范，可是这种规范在多线程多进程模式下实现很简单，不太适合单线程异步这种情况。鉴于此Tornado并没有按照这个框架去实现一个WSGI的web框架，可是它却提供了基本的兼容，1.允许Tornado的application对象转变成WSGI application。2. 允许WSGI application在tornado ioloop中执行，只是这一切都不是完美的，它仅仅提供了基本的兼容，效率和可用性得不到保证。因此个人还是感觉很鸡肋的&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之web</title>
    <link href="https://www.zoulei.net/2018/03/15/tornado_web/"/>
    <id>https://www.zoulei.net/2018/03/15/tornado_web/</id>
    <published>2018-03-15T09:23:07.000Z</published>
    <updated>2018-03-16T03:25:03.691Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章讲解了httpserver。它最终传入的是一个函数，接受的是Request对象，这和Tornado所展示的Hello World有一些差距。tornado的web模块就是将它从一个函数变化成一个类对象，并且包含了基础的路由功能，最终实现类似与这样的Hello World(代码基于1.0.0版本)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> web</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> httpserver</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        self.write(<span class="string">b"Hello World"</span>)</div><div class="line"></div><div class="line">application = web.Application([</div><div class="line">    (<span class="string">r"/"</span>, MainHandler)</div><div class="line">])</div><div class="line"></div><div class="line">http_server = httpserver.HTTPServer(application)</div><div class="line">http_server.listen(<span class="number">8888</span>)</div><div class="line">ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="将handler-request回调封装为RequestHandler类和Application"><a href="#将handler-request回调封装为RequestHandler类和Application" class="headerlink" title="将handler_request回调封装为RequestHandler类和Application"></a>将handler_request回调封装为RequestHandler类和Application</h3><p>和上一篇的httpserver并没有太大的变动，传入的对象由单个函数变成了application对象，并且web模块有RequestHandler和Application类，能猜想到web模块提供了路由功能，对请求的HTTP。它先得到请求路径和HTTP方法。找到对应的类。调用对应的方法。由此写出以下最简代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, request, application)</span>:</span></div><div class="line">        self.request = request</div><div class="line">        self.application = application</div><div class="line">        self._write_chunk = <span class="string">b""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, chunk)</span>:</span></div><div class="line">        self._write_chunk += chunk</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></div><div class="line">        self.request.write(<span class="string">b"HTTP/1.0 200 OK\r\nContent-Length: %d\r\n\r\n%s"</span> % (</div><div class="line">            len(self._write_chunk), self._write_chunk))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_execute</span><span class="params">(self)</span>:</span></div><div class="line">        self.get()</div><div class="line">        self.finish()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers)</span>:</span></div><div class="line">        self.handlers = handlers</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, request)</span>:</span></div><div class="line">        <span class="comment"># 先从request得到访问host、url和method对handlers进行匹配</span></div><div class="line">        handler = self.handlers[<span class="number">0</span>][<span class="number">1</span>](request, self)</div><div class="line">        handler._execute()</div></pre></td></tr></table></figure></p>
<p>将所有的RequestHandler类均放置到Application下面。当它被tornado.httpserver调用传入request对象的时候会调用Application的<code>__call__</code>函数。因为self.handlers中，每一个handler均有对应的路由地址，毫无疑问，这个地方会存在一个匹配过程。因为调用<code>__call__</code>的时候request对象已经可以提取到host、port、url、header、body等各种信息，最常用的只需要使用host和url即可确定调用哪一个RequestHandler。匹配后对RestsHandler进行初始化,此时传入了request对象和Application对象本身，最后调用_execute完成整个过程的执行</p>
<h3 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h3><p>路由功能的实现主要依靠正则匹配。比如实现对博客地址的匹配<code>/(\d{4})/(\d{2})/(\d{2})/(.+?)</code>。分别表示年、月、日、主题，或者使用正则命名分组<code>/(?P&lt;year&gt;\d{4})/(?P&lt;month&gt;\d{2})/(?P&lt;day&gt;\d{2})/(?P&lt;theme&gt;.+?)</code>。那么我们只需要再添加的时候执行re.compile。在匹配的时候执行re.match即可。对于普通的不存在正则分组的情况，就不需要传入正则分组匹配的内容。否则像以下这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class BlogHandler(RequestHandler):</div><div class="line">        def get(self,year,month,day):</div><div class="line">                pass</div></pre></td></tr></table></figure></p>
<p>在Tornado里面它使用了URLSpec类来封装这个事情</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>和上一篇的httpserver中使用handler_request函数不同。本篇的web模块对它进行了进一步的封装。我们面对的编写主要的业务逻辑均是继承自RequestHandler对象。在上一章基本面对的还是直接对iostream进行写操作，写入header、写入cookies、写入etag、模板渲染这些都是没有直接提供的。web模块作为它的更高级别封装，它提供了这些功能。</p>
<ul>
<li>路由匹配</li>
<li>给RequestHandler对象暴露Application对象和Request对象</li>
<li>提供状态码、跳转、url参数、header、cookies、缓存头、模板渲染、CSRF、日志记录等功能</li>
<li>提供http请求生命周期内的各项hook事件prepare、on_finish、on_connection_close</li>
<li>提供最常用的辅助函数get_login_url、get_current_user等</li>
<li>基于RequestHandler继承出了一些其他对象，比如ErrorHandler、StaticFileHandler、RedirectHandler等。注意，这一些和Flask等web框架的用法不一样。在Flask中是直接return ErrorHandler()等等。可是在Tornado中最后执行的是RequestHandler._execute，它是不支持直接返回这一些对象的。比如跳转直接执行self.redirect即可。这一些继承对象应该使用Application.add_handler进行调用。配合url匹配规则，然后最终被调用ErrorHandler._execute等等</li>
</ul>
<p>web里面还存在一个装饰器函数asynchronous，这个装饰器在Tornado存在了很长时间，只是现在基本可以不使用它了。可是依旧很多人喜欢一言不合就带上它。用法是这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequestHandler</span><span class="params">(web.RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @web.asynchronous</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        http = httpclient.AsyncHTTPClient()</div><div class="line">        http.fetch(<span class="string">"http://friendfeed.com/"</span>, self._on_download)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_on_download</span><span class="params">(self, response)</span>:</span></div><div class="line">        self.write(<span class="string">"Downloaded!"</span>)</div><div class="line">        self.finish()</div></pre></td></tr></table></figure><br>产生的原因是最终web.RequestHandler._execute调用了get函数。get执行完http.fetch整个过程就完成了。只是http.fetch它并没有阻塞，最终的结果是加入了IOLoop的回调，_execute的默认逻辑是当get函数执行完毕后会立即调用self.finish表示请求流程结束。明显这不是我们需要的逻辑，正常逻辑是等待网页下载完毕后再返回内容，因此web.asynchronous的逻辑很简单。将get函数设置一个标志位<code>self._auto_finish = False</code>表明该函数不需要调用<code>self.finish()</code>操作，自然最后再手动调用finish就好了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章讲解了httpserver。它最终传入的是一个函数，接受的是Request对象，这和Tornado所展示的Hello World有一些差距。tornado的web模块就是将它从一个函数变化成一个类对象，并且包含了基础的路由功能，最终实现类似与这样的Hello World(代码基于1.0.0版本)&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; tornado &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; web&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; tornado &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; httpserver&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; tornado &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ioloop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(web.RequestHandler)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.write(&lt;span class=&quot;string&quot;&gt;b&quot;Hello World&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;application = web.Application([&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;r&quot;/&quot;&lt;/span&gt;, MainHandler)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;http_server = httpserver.HTTPServer(application)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;http_server.listen(&lt;span class=&quot;number&quot;&gt;8888&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ioloop.IOLoop.instance().start()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之httpserver</title>
    <link href="https://www.zoulei.net/2018/03/15/tornado_httpserver/"/>
    <id>https://www.zoulei.net/2018/03/15/tornado_httpserver/</id>
    <published>2018-03-15T03:37:29.000Z</published>
    <updated>2018-03-15T09:14:55.763Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado可以当做一个http客户端去发送请求，可以处理需要和客户端建立长连接的请求。可是Tornado最为知名的还是它作为一个HTTP web框架…,上一篇讲述了IOLoop的套路。本篇讲解一下如何将IOLoop和httpserver联系起来(本代码思路依据1.0.0版本)</p>
<a id="more"></a>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>本文的基本目标是实现这个需求<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> httpserver</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(request)</span>:</span></div><div class="line">    message = <span class="string">b"Hello World\n"</span></div><div class="line">    request.write(<span class="string">b"HTTP/1.0 200 OK\r\nContent-Length: %d\r\n\r\n%s"</span> % (</div><div class="line">        len(message), message))</div><div class="line">    request.finish()</div><div class="line"></div><div class="line">http_server = httpserver.HTTPServer(handle_request)</div><div class="line">http_server.listen(<span class="number">8888</span>)</div><div class="line">ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure></p>
<h3 id="最简服务端"><a href="#最简服务端" class="headerlink" title="最简服务端"></a>最简服务端</h3><p>根据上一篇。我们可以想到当执行listen监听操作的时候，会创建一个监听socket.然后将处理函数添加到事件回调中。不考虑异常因素，最简单的是这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</div><div class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> EVENT_READ, EVENT_WRITE</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPServer</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handler)</span>:</span></div><div class="line">        self.handler = handler</div><div class="line">        self.io_loop = ioloop.IOLoop.instance()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port)</span>:</span></div><div class="line">        self.s = socket.socket()</div><div class="line">        self.s.setblocking(<span class="number">0</span>)</div><div class="line">        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</div><div class="line">        self.s.bind((<span class="string">'127.0.0.1'</span>, port))</div><div class="line">        self.s.listen(<span class="number">128</span>)</div><div class="line">        self.io_loop.add_handler(self.s.fileno(), EVENT_READ, self._handle)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_handle</span><span class="params">(self)</span>:</span></div><div class="line">        client_sock, _ = self.s.accept()</div><div class="line">        client_sock.send(<span class="string">b"HTTP/1.0 200 OK\r\nContent-Length: 12\r\n\r\nHello World\n"</span>)</div><div class="line">        client_sock.close()</div></pre></td></tr></table></figure><br>对于监听socket,当触发可读的时候意味有新的客户端连接进来了，此时调用回调进行accept得到交互socket连接。简单起见直接send发送一个简易的HTTP消息然后关闭socket</p>
<h3 id="封装Request对象"><a href="#封装Request对象" class="headerlink" title="封装Request对象"></a>封装Request对象</h3><p>从上面的示例中可以看到。它没有调用传入的request函数，因为socket对象并没有write和finish方法。此外，即使我们将socket的send和close当做write和finish。它还有一个巨大的缺陷。我们只是进行了发送，而没有对接收到的http报文进行任何处理。<br>一般而言，会从它的行首、头部、消息体得到某一些我们需要的内容，然后对内容进行处理，最终写入信息，过程结束。因此，封装一个Request对象是必须的，最后将封装的对象传入到handler函数以供使用。如何封装呢？我们只需要知道一个完整的HTTP报文即可以得到一个requests对象，而一个http报文又有明显的分隔符.例如下文这个请求报文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET /docs/index.html HTTP/1.1</div><div class="line">Host: www.ipinfo.com</div><div class="line">Accept: image/gif, image/jpeg, */*</div><div class="line">Accept-Language: en-us</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)</div><div class="line">(blank line)</div></pre></td></tr></table></figure></p>
<p>获取流程如下。当读取到第一个<code>\r\n</code>即确定Reques Line部分，当读取到<code>\r\n\r\n</code>即确定Header部分，如果Header部分存在Content-Length则表示存在body部分，存在则继续读取Content-Length长度。如此下来单个HTTP报文读取完毕。可以构建这个过程，Requests Line读取完毕后—&gt;回调读取Header部分—&gt;回调读取Body部分—&gt;构建Request对象—&gt;回调handler函数，将Request对象传入。另外第一步可以省略,读取Header即包含Requests Line</p>
<p>可以看到对于一个socket对象,将它根据分隔符以及长度读取就能解析成单个http包，另外对于很多流协议也是如此。我们将socket封装一下。让它提供两个功能read_until、read_bytes。允许读取到分隔符后调用回调函数、读取到固定长度后调用回调函数。最简代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> ioloop</div><div class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> EVENT_READ</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOStream</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, socket)</span>:</span></div><div class="line">        self.socket = socket</div><div class="line">        self.ioloop = ioloop.IOLoop.instance()</div><div class="line">        self.ioloop.add_handler(self.socket.fileno(), EVENT_READ, self._handler)</div><div class="line">        self._read_buffer = <span class="string">b""</span></div><div class="line">        self._read_delimiter = <span class="keyword">None</span></div><div class="line">        self._read_bytes = <span class="keyword">None</span></div><div class="line">        self._read_callback = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_handler</span><span class="params">(self)</span>:</span></div><div class="line">        data = self.socket.recv(<span class="number">1024</span>)</div><div class="line">        self._read_buffer += data</div><div class="line">        <span class="keyword">if</span> self._read_delimiter <span class="keyword">and</span> self._read_delimiter <span class="keyword">in</span> self._read_buffer:</div><div class="line">            result, self._read_buffer = self._read_buffer.split(self._read_delimiter)</div><div class="line">            self._read_callback(result)</div><div class="line">            self._read_delimiter = <span class="keyword">None</span></div><div class="line">            self._read_callback = <span class="keyword">None</span></div><div class="line">        <span class="keyword">elif</span> self._read_bytes <span class="keyword">and</span> len(self._read_buffer) &gt; self._read_bytes:</div><div class="line">            result = self._read_buffer[:self._read_bytes]</div><div class="line">            self._read_buffer = self._read_buffer[self._read_bytes:]</div><div class="line">            self._read_callback(result)</div><div class="line">            self._read_bytes = <span class="keyword">None</span></div><div class="line">            self._read_callback = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_until</span><span class="params">(self, delimiter, callback)</span>:</span></div><div class="line">        self._read_delimiter = delimiter</div><div class="line">        self._read_callback = callback</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_bytes</span><span class="params">(self, length, callback)</span>:</span></div><div class="line">        self._read_bytes = length</div><div class="line">        self._read_callback = callback</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.socket.send(data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></div><div class="line">        self.ioloop.ioloop.unregister(self.socket.fileno())</div><div class="line">        self.socket.close()</div></pre></td></tr></table></figure><br>对于创建的IOStream对象，它添加READ事件，将回调函数设置为self._handler。当使用read_until的时候将历史数据给callback函数调用。<br>再看一下HTTPConnect对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPConnection</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, io_stream, handler_callback)</span>:</span></div><div class="line">        self.io_loop = ioloop.IOLoop.instance()</div><div class="line">        self.stream = io_stream</div><div class="line">        self.handler_callback = handler_callback</div><div class="line">        self.stream.read_until(<span class="string">b'\r\n\r\n'</span>, self._parse_header)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_parse_header</span><span class="params">(self, data)</span>:</span></div><div class="line">        <span class="comment"># 忽略行首，全部当做header</span></div><div class="line">        request = Request(connect=self, header=data)</div><div class="line">        self.handler_callback(request)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.stream.write(data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></div><div class="line">        self.stream.close()</div></pre></td></tr></table></figure><br>显然，它传入的是IOStream对象，并且在初始化的时候就调用read_until读取HTTP Header部分内容。简单起见，这里只读取并没有解析。最后封装成Request对象。让handle_request函数调用。达到我们文章开头的目的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, connect, header)</span>:</span></div><div class="line">        self.connect = connect</div><div class="line">        self.header = header</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.connect.write(data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></div><div class="line">        self.connect.finish()</div></pre></td></tr></table></figure><br>将最开始的最简服务器部分稍微改动一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle</span><span class="params">(self)</span>:</span></div><div class="line">    client_sock, _ = self.s.accept()</div><div class="line">    stream = IOStream(client_sock)</div><div class="line">    HTTPConnection(stream, self.handler)</div></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>IOStream、HTTPConnection、Request、HTTPServer。其中暴漏给用户的几乎只有Request对象，从上面的分析中应该可以发现。将文件描述符加入事件，等待IOStream的全局_header进行回调，全局_header又针对各种情况(分隔符条件满足、长度条件满足)发起回调。同时<span style="color:red"><strong>如果不调用iostream.read_until等那么全局的_header就没有意义了</strong></span>。搞定IOStream后。立马在HTTPConnection里面调用<code>iostream.read_until</code>。被回调则表明HTTP头部接收完成。组装成Requests然后调用handle_request。</p>
<p>作用分工:<br>HTTPServer:     创建监听socket,传入http处理回调函数<br>IOStream:   提供通用TCP流解析，最重要的是提供了write、read_until、read_length，<span style="color:red"><strong>且可以传入回调</strong></span><br>Request:    将字符串解析成一个Request对象。便于简单的获取访问信息。如url、host、port、body等等<br>HTTPConnection:  将前三者联系起来,调用IOStream.read_until开启获取HTTP数据包的流程</p>
<p>另外本文简单起见，只注册了READ事件。对于send操作。同样是需要进行注册事件。等到WRITE事件触发才执行send操作，希望不要引起误解，另外本例中使用HTTP/1.0的逻辑，处理完成单个链接后直接关闭。对于HTTP/1.1来说要实现keep-alive只需要在finish的使用并不关闭链接，而是继续执行self.read_until(b’\r\n\r\n’,self._parse_header)继续等待处理下一个HTTP报文</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tornado可以当做一个http客户端去发送请求，可以处理需要和客户端建立长连接的请求。可是Tornado最为知名的还是它作为一个HTTP web框架…,上一篇讲述了IOLoop的套路。本篇讲解一下如何将IOLoop和httpserver联系起来(本代码思路依据1.0.0版本)&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Tornado 之IOLoop</title>
    <link href="https://www.zoulei.net/2018/03/14/tornado_ioloop/"/>
    <id>https://www.zoulei.net/2018/03/14/tornado_ioloop/</id>
    <published>2018-03-14T10:03:18.000Z</published>
    <updated>2018-03-15T03:21:18.382Z</updated>
    
    <content type="html"><![CDATA[<p>这是Tornado系列的开篇,Tornado作为异步web框架2010年发布1.0版本。可以说Python社区搞了这么多年，为了获得比多线程多进程更高的性能，经历了Twisted、Tornado、yield、gevent、yield from、asyncio。也不知道什么时候才是一个尽头~~。Tornado过了这么多年还算开发活跃(<a href="https://github.com/tornadoweb/tornado/graphs/contributors">一个大神扛起了一片天啊</a>)，不同于多线程模型的一潭死水，看它的代码你会发现它还是紧跟潮流的，而且有一点。它的内部虽然一直在变动，但是提供给用户的使用接口是很稳定的，后续就会发现这个坑有多大</p>
<a id="more"></a>
<p>截止目前最新版本的代码是4.5，排除测试总代码量大约为12000行。我个人喜欢看精简版本的代码，所以本文为1.0.0版本。总代码量为4200行，比较容易看懂。毕竟别人优化了八年，期待一个星期精读能搞明白各种工程优化是不现实的。</p>
<h3 id="IOLoop"><a href="#IOLoop" class="headerlink" title="IOLoop"></a>IOLoop</h3><p>说到异步非阻塞大多数人都知道是异步IO模型(select、poll、epoll、kqueue)。没错在阻塞模型中比如使用<code>socket.recv</code>它会主线程造成阻塞。这直接导致了在python中需要使用多线程或者多进程模型才能够同时处理多个请求。可是在异步模型中允许对文件描述符进行监听，操作系统提供功能，当文件的状态发生变化(可读、可写、异常)程序能够获得这一状态。对我们来说就是当明确知道某文件存在什么事件的时候去触发相应的处理函数。注意，这就是一个<span style="color:red"><strong>回调、回调、回调(重要的事情说三遍)</strong></span></p>
<p>可以把IOLoop当做一个停不下来的死循环，类似下面这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> bisect</div><div class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOLoop</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._callback = set()</div><div class="line">        self._timeout = []</div><div class="line">        self.ioloop = DefaultSelector()</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</div><div class="line">            cls._instance = cls()</div><div class="line">        <span class="keyword">return</span> cls._instance</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, fd, event, func)</span>:</span></div><div class="line">        self.ioloop.register(fd, event, func)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_handler</span><span class="params">(self, fd, event)</span>:</span></div><div class="line">        temp = ioloop.get_key(fd)</div><div class="line">        ioloop.unregister(fd)</div><div class="line">        ioloop.register(fd, event, temp.data)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_callback</span><span class="params">(self, func)</span>:</span></div><div class="line">        self._callback.add(func)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_timeout</span><span class="params">(self, t, func)</span>:</span></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">_T</span>:</span></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, t, func)</span>:</span></div><div class="line">                self.t = t</div><div class="line">                self.callback = func</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></div><div class="line">                <span class="keyword">return</span> self.t &lt; other.t</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></div><div class="line">                <span class="keyword">return</span> self.t &gt; other.t</div><div class="line"></div><div class="line">        t = _T(t, func)</div><div class="line">        bisect.insort(self._timeout, t)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> self._callback.copy():</div><div class="line">                i()</div><div class="line">                self._callback.remove(i)</div><div class="line"></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> self._timeout.copy():</div><div class="line">                <span class="keyword">if</span> time.time() &gt; i.t:</div><div class="line">                    i.callback()</div><div class="line">                    self._timeout.remove(i)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">break</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> self.ioloop.select(timeout=<span class="number">0.2</span>):</div><div class="line">                k.data()</div></pre></td></tr></table></figure></p>
<p>你只需要记住以下几点</p>
<ol>
<li><span style="color:red"><strong>IOLoop是一个单例</strong></span></li>
<li>IOLoop提供了处理三种情况的方法，分别是回调形式(_callback)、定时器形式(_timeout)、网络IO(selectors)</li>
<li>最后是一个while 1的死循环</li>
</ol>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><p>正因为IOLoop是一个单例。所以所有的函数最终都通过add_callback、add_timeout、add_handler放置到了IOLoop下面，最终被执行start依次调用，再调用的过程中，这些函数又使用ioloop.IOLoop.instance().add_callback等不断的加入一些事件处理。导致形成了一个callback链条，让我们最终得到结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 代码为python3</span></div><div class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector, EVENT_WRITE, EVENT_READ</div><div class="line"><span class="keyword">import</span> socket</div><div class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</div><div class="line"></div><div class="line">done = <span class="keyword">False</span></div><div class="line">selector = DefaultSelector()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></div><div class="line">    parse = urlparse(url)</div><div class="line">    s = socket.socket()</div><div class="line">    s.setblocking(<span class="keyword">False</span>)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        s.connect((parse.hostname, <span class="number">80</span>))</div><div class="line">    <span class="keyword">except</span> BlockingIOError:</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    selector.register(s.fileno(), EVENT_WRITE, <span class="keyword">lambda</span>: connected(s, parse.path, parse.hostname))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(s, path, host)</span>:</span></div><div class="line">    selector.unregister(s.fileno())</div><div class="line">    s.send((<span class="string">'GET &#123;&#125; HTTP/1.0\r\nHost:&#123;&#125;\r\n\r\n'</span>.format(path, host)).encode())</div><div class="line">    buf = []</div><div class="line">    selector.register(s.fileno(), EVENT_READ, <span class="keyword">lambda</span>: readable(s, buf))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readable</span><span class="params">(s, buf)</span>:</span></div><div class="line">    <span class="keyword">global</span> done</div><div class="line">    chunk = s.recv(<span class="number">1024</span>)</div><div class="line">    <span class="keyword">if</span> chunk:</div><div class="line">        buf.append(chunk)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        done = <span class="keyword">True</span></div><div class="line">        selector.unregister(s.fileno())</div><div class="line">        print((<span class="string">b''</span>.join(buf)).decode())</div><div class="line">        s.close()</div><div class="line"></div><div class="line"></div><div class="line">get(<span class="string">"http://httpbin.org/ip"</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> done:</div><div class="line">    events = selector.select()</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> events:</div><div class="line">        k.data()</div></pre></td></tr></table></figure>    </p>
<p>如上例.当我们调用get()开始执行代码的时候它只是开启了第一步创建了一个socket链接并在selector中注册了一个事件，等待READ事件被触发，k.data()被调用，即connected函数被调用，发送数据之后再次注册READ事件。依然等待直到k.data()被调用，即readable被调用。最后直至数据读取完成。表示整个过程结束</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>观察IOLoop例子中的start死循环可以知道。它其实也是伴随着阻塞的，在<code>self.ioloop.select(timeout=0.2)</code>中如果持续0.2秒没有等待的IO事件发生，那么会阻塞0.2秒，看似0.2秒也不长，但其实非常大量的事件并不是IO事件，而是在self._callback集合中。因此从效率方面考虑添加_callback的时候触发IO事件，让select不再去阻塞那0.2秒，因此创建了一个管道对象来解决了这个问题，当添加的_callback的时候同时向管道写入一个字符。那么就不存在0.2秒的阻塞了</p>
<h3 id="应用一-PeriodicCallback"><a href="#应用一-PeriodicCallback" class="headerlink" title="应用一 PeriodicCallback"></a>应用一 PeriodicCallback</h3><p>ioloop.py下面有一个非常简单的PeriodicCallback类，它的作用是定期将callback加入到IOLoop的_timeout列表中。比如你需要每隔三十分钟去清理一次临时文件夹产生的垃圾文件等等。简易实现大概是这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicCallback</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval, func)</span>:</span></div><div class="line">        self.interval = interval</div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line">        timeout = time.time() + self.interval</div><div class="line">        IOLoop.instance().add_timeout(timeout, self.callback)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(self)</span>:</span></div><div class="line">        self.func()</div><div class="line">        self.start()</div></pre></td></tr></table></figure><br>再执行start之后添加到了_timeout。待时间到达后执行一次然后再调用start，如此反复😳。最后达到了无限循环执行的效果</p>
<h3 id="应用二-自动重启"><a href="#应用二-自动重启" class="headerlink" title="应用二 自动重启"></a>应用二 自动重启</h3><p>对于web框架而言，在开发过程中当代码发生变更自动重启机制几乎是都必备的。在Flask中是主线程单独开了一个进程，在进程里面将主函数开一个线程运行。然后执行死循环进行代码变更检测。发现变更则进行进程退出操作。主线程捕获退出状态进行重启。示例代码可以<a href="/2016/07/25/werkzeug_note_requests_response_auto_realod/index.html#热重启实现原理">看这里</a></p>
<p>可以看到自动重启基本由三个部分组成。</p>
<ol>
<li>主代码正常执行</li>
<li>检测代码变更逻辑定期执行</li>
<li>检测到变更后重启程序</li>
</ol>
<p>对于第一个条件而言Tornado没什么，就是主线程正常操作，第二个条件就利用了上面说的PeriodicCallback，将检测函数定期执行就好。第三个条件使用os.execv重载整个进程。bingo,没有单独的开启线程，开启进程。单线程完成了自动重启的操作。最简代码应该是这样的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"><span class="keyword">import</span> ioloop</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> types</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(io_loop=None, check_time=<span class="number">500</span>)</span>:</span></div><div class="line">    io_loop = io_loop <span class="keyword">or</span> ioloop.IOLoop.instance()</div><div class="line">    modify_times = &#123;&#125;</div><div class="line">    callback = functools.partial(_reload_on_update, modify_times)</div><div class="line">    scheduler = ioloop.PeriodicCallback(callback, check_time, io_loop=io_loop)</div><div class="line">    scheduler.start()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_reload_on_update</span><span class="params">(modify_times)</span>:</span></div><div class="line">    <span class="keyword">for</span> module <span class="keyword">in</span> sys.modules.values():</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(module, types.ModuleType): <span class="keyword">continue</span></div><div class="line">        path = getattr(module, <span class="string">"__file__"</span>, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path: <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> path.endswith(<span class="string">".pyc"</span>) <span class="keyword">or</span> path.endswith(<span class="string">".pyo"</span>):</div><div class="line">            path = path[:<span class="number">-1</span>]</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            modified = os.stat(path).st_mtime</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> modify_times:</div><div class="line">            modify_times[path] = modified</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">if</span> modify_times[path] != modified:</div><div class="line">            os.execv(sys.executable, [sys.executable] + sys.argv)</div></pre></td></tr></table></figure><br>使用sys.modules查看所有已加载的模块。每500毫秒将文件改动时间和已有数据进行对比。如果不同则执行os.execv覆盖掉当前进程，后续该代码虽然为了跨平台逻辑上有变动。可是整体思路是没有改变的</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结而言IOLoop的逻辑还是很好理解的。它可以被认为是一个独立性非常强的模块。一个单例，整体是一个死循环提供三种情况的处理。在运行过程中不断的调用单例的成员函数，完成对一个事务(比如获得一个网页的内容)的处理。至于为什么没有被阻塞。每当要IO阻塞的时候(比如connect)就注册一个事件回调，然后继续运行不会阻塞的部分。等到事件完成再进行IO操作就不会阻塞了。从而达到整体非阻塞的效果</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Tornado系列的开篇,Tornado作为异步web框架2010年发布1.0版本。可以说Python社区搞了这么多年，为了获得比多线程多进程更高的性能，经历了Twisted、Tornado、yield、gevent、yield from、asyncio。也不知道什么时候才是一个尽头~~。Tornado过了这么多年还算开发活跃(&lt;a href=&quot;https://github.com/tornadoweb/tornado/graphs/contributors&quot;&gt;一个大神扛起了一片天啊&lt;/a&gt;)，不同于多线程模型的一潭死水，看它的代码你会发现它还是紧跟潮流的，而且有一点。它的内部虽然一直在变动，但是提供给用户的使用接口是很稳定的，后续就会发现这个坑有多大&lt;/p&gt;
    
    </summary>
    
      <category term="Tornado" scheme="https://www.zoulei.net/categories/Tornado/"/>
    
    
  </entry>
  
  <entry>
    <title>Python高级多线程并发</title>
    <link href="https://www.zoulei.net/2018/03/12/python_concurrent_futures_thread/"/>
    <id>https://www.zoulei.net/2018/03/12/python_concurrent_futures_thread/</id>
    <published>2018-03-12T10:49:33.000Z</published>
    <updated>2018-03-12T11:27:47.101Z</updated>
    
    <content type="html"><![CDATA[<p>在多线程多进程当道的年代这个被称为高级并发的模块还是很令人惊艳的。concurrent.future模块的厉害之处在于封装了多线程、多进程、锁、队列到一起。这些细节使用者都不需要知道。四五行代码能实现以往二三十行实现的效果。而且多线程和多进程的使用方式完全一样，堪称完美杰作。可惜，现在已经是异步时代了，主要是因为tornado用到了它的Future模块。我就看看它大概是怎样实现的</p>
<a id="more"></a>
<p>来自官方文档的示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> concurrent.futures</div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"></div><div class="line">URLS = [<span class="string">'http://www.foxnews.com/'</span>,</div><div class="line">        <span class="string">'http://www.cnn.com/'</span>,</div><div class="line">        <span class="string">'http://europe.wsj.com/'</span>,</div><div class="line">        <span class="string">'http://www.bbc.co.uk/'</span>,</div><div class="line">        <span class="string">'http://some-made-up-domain.com/'</span>]</div><div class="line"></div><div class="line"><span class="comment"># Retrieve a single page and report the URL and contents</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url, timeout)</span>:</span></div><div class="line">    <span class="keyword">with</span> urllib.request.urlopen(url, timeout=timeout) <span class="keyword">as</span> conn:</div><div class="line">        <span class="keyword">return</span> conn.read()</div><div class="line"></div><div class="line"><span class="comment"># We can use a with statement to ensure threads are cleaned up promptly</span></div><div class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">    <span class="comment"># Start the load operations and mark each future with its URL</span></div><div class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">60</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</div><div class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</div><div class="line">        url = future_to_url[future]</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            data = future.result()</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</div><div class="line">            print(<span class="string">'%r generated an exception: %s'</span> % (url, exc))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'%r page is %d bytes'</span> % (url, len(data)))</div></pre></td></tr></table></figure>
<p>首先考虑一个问题。在多线程里面，一般我们直接<code>threading.Thread(target=)</code>,但是直接运行不会得到返回的结果的。这里就用到了<code>Future</code>对象。类似与装饰器，最终运行的函数被嵌套，结果被添加到<code>Future</code>对象上。你可以将<code>Future</code>当做一个及其简单的对象，就像下面这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.result = <span class="keyword">None</span></div><div class="line">        self._state = <span class="string">"PENDING"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, value)</span>:</span></div><div class="line">        self._state = <span class="string">"FINISHED"</span></div><div class="line">        self.result = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.result</div></pre></td></tr></table></figure></p>
<p>因此最终最新的并非是原始的函数。此处被封装成了WorkItem对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerItem</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, future, fn, *args, **kwargs)</span>:</span></div><div class="line">        self.fn = fn</div><div class="line">        self.args = args</div><div class="line">        self.kwargs = kwargs</div><div class="line">        self.future = future</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            ret = self.fn(*self.args, **self.kwargs)</div><div class="line">            self.future.set_result(ret)</div><div class="line"></div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            self.future.set_result(e)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_worker</span><span class="params">(work_queue)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            work_item = work_queue.get(block=<span class="keyword">True</span>)</div><div class="line">            <span class="keyword">if</span> work_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                work_item.run()</div><div class="line">    <span class="keyword">except</span> BaseException:</div><div class="line">        traceback.print_exc()</div></pre></td></tr></table></figure></p>
<p>其次它能够允许对创建的线程数量进行控制max_client。这个也可以想到通过队列来控制，当submit创建任务的时候并不是直接调用threading.Thread创建一个全新的线程。而是仅仅把它加入到队列，判断当前线程数量是否小于最大数量。当然在线程中就是不断循环执行Work。<code>Future</code>、<code>WorkItem</code>、<code>_worker</code>都是影藏没有对用户暴露。真正对用户暴露的只有一个ThreadPoolExecutor,大概可以这样认为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_workers)</span>:</span></div><div class="line">        self.max_workers = max_workers</div><div class="line">        self._queue = Queue()</div><div class="line">        self._thread = set()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(self, fn, *args, **kwargs)</span>:</span></div><div class="line">        f = Future()</div><div class="line">        worker_item = WorkerItem(f, fn, *args, **kwargs)</div><div class="line">        self._queue.put(worker_item)</div><div class="line">        <span class="keyword">if</span> len(self._thread) &lt; self.max_workers:</div><div class="line">            t = Thread(target=_worker, args=(self._queue,))</div><div class="line">            t.daemon = <span class="keyword">True</span></div><div class="line">            t.start()</div><div class="line">        <span class="keyword">return</span> f</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self._thread:</div><div class="line">            i.join()</div></pre></td></tr></table></figure>
<p>从上面可以看到每次submit后会得到一个<code>Future</code>对象。设想一下当线程执行得到结果后我们可以根据<code>Future</code>的状态轮询得到我们需要的结果。大概可以这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</div><div class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">1</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> future_to_url.copy().keys():</div><div class="line">            <span class="keyword">if</span> i._state == <span class="string">"FINISHED"</span>:</div><div class="line">                print(i.get_result())</div><div class="line">                future_to_url.pop(i)</div><div class="line">        <span class="keyword">if</span> len(future_to_url) == <span class="number">0</span>:</div><div class="line">            <span class="keyword">break</span></div></pre></td></tr></table></figure></p>
<p><span style="color:red"><strong>但是可能作者觉得这种方式太low,效率太低。实现了一个as_completed函数，直接让理解难度提升一个数量级。。。。</strong></span></p>
<p>大概就是先生成了一个waiters对象(这个对象有threading.Event)，并将这些对象添加到所有的未完成的Futures中。任一对象完成则会触发事件的设置。这样阻塞被暂时取消，可以得到结果返回，代码注释如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_completed</span><span class="params">(fs, timeout=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        end_time = timeout + time.time()</div><div class="line"></div><div class="line">    fs = set(fs)</div><div class="line">    <span class="keyword">with</span> _AcquireFutures(fs):</div><div class="line">        <span class="comment"># 先挑选出所有已经有结果的Future</span></div><div class="line">        finished = set(</div><div class="line">                f <span class="keyword">for</span> f <span class="keyword">in</span> fs</div><div class="line">                <span class="keyword">if</span> f._state <span class="keyword">in</span> [CANCELLED_AND_NOTIFIED, FINISHED])</div><div class="line">        pending = fs - finished</div><div class="line">        <span class="comment"># 创建了一个waiter对象。该对象用于threading.Event。然后将自身添加到了所有的Futures上面</span></div><div class="line">        waiter = _create_and_install_waiters(fs, _AS_COMPLETED)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="comment"># 先依次返回已完成的Future</span></div><div class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> finished</div><div class="line"></div><div class="line">        <span class="keyword">while</span> pending:</div><div class="line">            <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                wait_timeout = <span class="keyword">None</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                wait_timeout = end_time - time.time()</div><div class="line">                <span class="keyword">if</span> wait_timeout &lt; <span class="number">0</span>:</div><div class="line">                    <span class="keyword">raise</span> TimeoutError(</div><div class="line">                            <span class="string">'%d (of %d) futures unfinished'</span> % (</div><div class="line">                            len(pending), len(fs)))</div><div class="line">            </div><div class="line">            <span class="comment"># 当Future被进行设置结果会触发threading.Event.set</span></div><div class="line">            <span class="comment"># 那么该处的阻塞就会被取消</span></div><div class="line">            waiter.event.wait(wait_timeout)</div><div class="line"></div><div class="line">            <span class="keyword">with</span> waiter.lock:</div><div class="line">                <span class="comment"># 又得到一批已完成的Futures</span></div><div class="line">                finished = waiter.finished_futures</div><div class="line">                waiter.finished_futures = []</div><div class="line">                <span class="comment"># 取消状态,等待下一次的set</span></div><div class="line">                waiter.event.clear()</div><div class="line">            </div><div class="line">            <span class="comment"># 依次返回并从pending队列中移出</span></div><div class="line">            <span class="keyword">for</span> future <span class="keyword">in</span> finished:</div><div class="line">                <span class="keyword">yield</span> future</div><div class="line">                pending.remove(future)</div><div class="line"></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> fs:</div><div class="line">            <span class="keyword">with</span> f._condition:</div><div class="line">                f._waiters.remove(waiter)</div></pre></td></tr></table></figure></p>
<p>多线程的方式相较多进程要简单很多。多进程的实现有机会再写续篇~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在多线程多进程当道的年代这个被称为高级并发的模块还是很令人惊艳的。concurrent.future模块的厉害之处在于封装了多线程、多进程、锁、队列到一起。这些细节使用者都不需要知道。四五行代码能实现以往二三十行实现的效果。而且多线程和多进程的使用方式完全一样，堪称完美杰作。可惜，现在已经是异步时代了，主要是因为tornado用到了它的Future模块。我就看看它大概是怎样实现的&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的多线程锁</title>
    <link href="https://www.zoulei.net/2018/03/12/Python_Thread_Lock/"/>
    <id>https://www.zoulei.net/2018/03/12/Python_Thread_Lock/</id>
    <published>2018-03-12T06:16:13.000Z</published>
    <updated>2018-03-12T09:21:24.786Z</updated>
    
    <content type="html"><![CDATA[<p>多线程是个坑爹的课题，有多线程就有锁。Python中有低级线程模块_thread、再封装一下就是threading、再来一下就是<code>from concurrent.futures import ThreadPoolExecutor</code>。其中涉及到的锁大概有Lock、RLock、Condition、Semaphore、BoundedSeamphore、Event。这么多看起来怪吓人的，其实这么多的锁全部只是由Lock演化出来的</p>
<a id="more"></a>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p><code>Lock = _thread._allocate_lock</code> 这个是直接由最低级别的_thread直接引用过来的。创建锁的时候是处于未被锁定的状态。这应该是最容易被理解和使用的一种锁了。刚学习的时候铁定写过类似下面这种示例。本质原因是python中的原子操作是针对单条指令。而a+=1被翻译成了多条指令。执行过程中任何时刻可能被打断</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">global</span> a</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</div><div class="line">        a += <span class="number">1</span></div><div class="line"></div><div class="line">t = [threading.Thread(target=change) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</div><div class="line">[i.start() <span class="keyword">for</span> i <span class="keyword">in</span> t]</div><div class="line">[i.join() <span class="keyword">for</span> i <span class="keyword">in</span> t]</div><div class="line">print(a)</div></pre></td></tr></table></figure>
<p>解决方法就是<span style="color:red"><strong>所有线程共享同一个锁，虽然锁有很多种，但是几乎都是这样暴露给用户使用的</strong></span>，这是大家都知道的。一个锁都好理解。如果有两个锁就不是那么好理解了，比如这个有点装逼的例子。交叉打印Hello和World</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">lock_a = Lock()</div><div class="line">lock_b = Lock()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        lock_a.acquire()</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line">        print(<span class="string">"Hello"</span>)</div><div class="line">        lock_b.release()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        lock_b.acquire()</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line">        print(<span class="string">"World"</span>)</div><div class="line">        lock_a.release()</div><div class="line"></div><div class="line">Thread(target=hello).start()</div><div class="line">Thread(target=world).start()</div></pre></td></tr></table></figure>
<h3 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h3><p>可重入锁允许线程获得锁之后该线程可以无数次的再次获得锁。看起来没什么用，大概也确实没啥用吧，不过考虑一下下面这种场景<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Change</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.a = <span class="number">1</span></div><div class="line">        self.b = <span class="number">1</span></div><div class="line">        self.lock = RLock()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adda</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.lock:</div><div class="line">            self.a += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addb</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.lock:</div><div class="line">            self.b += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addab</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.lock:</div><div class="line">            self.adda()</div><div class="line">            self.addb()</div></pre></td></tr></table></figure><br>你有一个类。其中adda改变a,addb改变b.还提供方法addab同时调用前两者。如果没有可重入锁那么你将不得不把两个函数粘贴到addab下面。它的实现原理是获取锁的时候根据get_ident得到当前线程标识。如果和当前锁的标识一样则仅仅是给值加1，否则就尝试去获取锁。简要代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, get_ident</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RLock</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.lock = Lock()</div><div class="line">        self._owner = <span class="keyword">None</span></div><div class="line">        self._count = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self)</span>:</span></div><div class="line">        me = get_ident()</div><div class="line">        <span class="keyword">if</span> self._owner == me:</div><div class="line">            self._count += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        rc = self.lock.acquire()</div><div class="line">        <span class="keyword">if</span> rc:</div><div class="line">            self._owner = me</div><div class="line">            self._count = <span class="number">1</span></div><div class="line"></div><div class="line">    __enter__ = acquire</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">release</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self._owner != get_ident():</div><div class="line">            <span class="keyword">raise</span> RuntimeError()</div><div class="line">        self._count -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> self._count == <span class="number">0</span>:</div><div class="line">            self._owner = <span class="keyword">None</span></div><div class="line">            self.lock.release()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></div><div class="line">        self.release()</div></pre></td></tr></table></figure>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>被称为条件变量，这个应该是很少被使用的。它允许传入一个锁，当满足条件的时候触发通知(可以看一下queue模块的实现，当get不到数据的时候就执行wait等待，新加入数据的时候执行notify通知唤醒)，这应该是它被称为条件变量的原因(感觉都有点牵强😕),和Lock以及RLock不同。这个东东主要是用来通知其他线程的。大概有两个方法wait(阻塞直到被通知)，notify(唤醒wait)。<br>实现的思路是所有的线程共享同一个锁A，同时有一个共用的锁列表。每当调用wait的时候生成一个新的锁放入锁列表，然后获得该锁，再释放锁A(因为wait必须在获得锁A才能调用，如果不释放则其他线程无法获得锁A)。最绝的来了，<span style="color:red"><strong>再次获得新生成的锁造成死锁</strong></span>。由此该线程被挂起。直到其他获得锁A的线程执行notify操作。将wait的锁释放。<br>实现代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._lock = RLock()</div><div class="line">        self._waiters = deque()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._lock.__enter__()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._lock.__exit__(*args)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">assert</span> get_ident() == self._lock._owner</div><div class="line">        waiter = Lock()</div><div class="line">        self._waiters.append(waiter)</div><div class="line"></div><div class="line">        waiter.acquire()</div><div class="line">        self._lock.release()</div><div class="line">        waiter.acquire()</div><div class="line">        self._lock.acquire()</div><div class="line">        <span class="keyword">del</span> waiter</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">assert</span> get_ident() == self._lock._owner</div><div class="line">        <span class="keyword">for</span> waiter <span class="keyword">in</span> self._waiters.copy():</div><div class="line">            waiter.release()</div><div class="line">            self._waiters.remove(waiter)</div></pre></td></tr></table></figure></p>
<p>这个东东吧其实不太适合被直接使用。但是网上还是有人硬生生凑了一个消费者生产者的例子出来做演示<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Producer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">            integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</div><div class="line">            <span class="keyword">with</span> self.condition:</div><div class="line">                self.integers.append(integer)</div><div class="line">                self.condition.notify()</div><div class="line">                time.sleep(<span class="number">0.5</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Consumer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.condition:</div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">                <span class="keyword">while</span> self.integers:</div><div class="line">                    integer = self.integers.pop()</div><div class="line">                    print(integer)</div><div class="line">                self.condition.wait()</div><div class="line"></div><div class="line">integers = []</div><div class="line">condition = Condition()</div><div class="line">Producer(integers, condition).start()</div><div class="line">Consumer(integers, condition).start()</div></pre></td></tr></table></figure><br>这个例子有个地方需要注意。notify和wait并不是一一对应的。不代表执行了notify，wait部分一定会被执行。所以如果消费者部分这样写会造成部分没有被处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Consumer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.condition:</div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">                self.condition.wait()</div><div class="line">                integer = self.integers.pop()</div><div class="line">                print(integer)</div></pre></td></tr></table></figure></p>
<h3 id="Semaphore-amp-BoundedSeamphore"><a href="#Semaphore-amp-BoundedSeamphore" class="headerlink" title="Semaphore &amp; BoundedSeamphore"></a>Semaphore &amp; BoundedSeamphore</h3><p>上面先介绍Condition是有原因的，因为多线程信号量和事件都是基于它生成的。信号量常用于限制对有限资源的访问。比如你有1000个线程，如果每一个线程都去创建数据库连接，那么数据库可能会崩。或者爬虫创建对网站的连接，太过凶残并不好，这个时候用信号量来处理就不错。</p>
<p>这里如果直接使用Lock来构建。那么一个锁同时只允许一个线程来获得显然是不达不到要求的。祭出刚才构建的Condition<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>:</span></div><div class="line">    <span class="comment"># value值用完了就被调用wait.只有notify能解除</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">1</span>)</span>:</span></div><div class="line">        self._lock = Condition()</div><div class="line">        self.value = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self._lock:</div><div class="line">            <span class="keyword">if</span> self.value == <span class="number">0</span>:</div><div class="line">                self._lock.wait()</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.value -= <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></div><div class="line">        self.value += <span class="number">1</span></div><div class="line">        self._lock.notify()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span><span class="params">(Semaphore)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">1</span>)</span>:</span></div><div class="line">        super(BoundedSemaphore, self).__init__(value=value)</div></pre></td></tr></table></figure></p>
<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>Event和Condition差不多。区别就是上面提到的，使用Condition，如果在单线程，那么当notify的时候是无法触发wait的，再调用wait线程会被阻塞。<span style="color:red"><strong>但是Event就支持在单线程使用。</strong></span>提供两个主要方法，set和wait。但是它并不需要先获得锁。使用好像更方便一点，实现如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._cond = Condition()</div><div class="line">        self._flag = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self._cond:</div><div class="line">            self._flag = <span class="keyword">True</span></div><div class="line">            self._cond.notify()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self._cond:</div><div class="line">            self._flag = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">with</span> self._cond:</div><div class="line">            signaled = self._flag</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> signaled:</div><div class="line">                signaled = self._cond.wait()</div><div class="line">            <span class="keyword">return</span> signaled</div></pre></td></tr></table></figure></p>
<p>如果把刚才那个生产者消费者换到它上面来，大概是这个样子了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Producer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">            integer = random.randint(<span class="number">0</span>, <span class="number">256</span>)</div><div class="line">            self.integers.append(integer)</div><div class="line">            self.condition.set()</div><div class="line">            time.sleep(<span class="number">0.5</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, integers, condition)</span>:</span></div><div class="line">        super(Consumer, self).__init__()</div><div class="line">        self.integers = integers</div><div class="line">        self.condition = condition</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">while</span> self.integers:</div><div class="line">                integer = self.integers.pop()</div><div class="line">                print(integer)</div><div class="line">            self.condition.wait()</div><div class="line"></div><div class="line">integers = []</div><div class="line">condition = Event()</div><div class="line">Producer(integers, condition).start()</div><div class="line">Consumer(integers, condition).start()</div></pre></td></tr></table></figure><br>当然，没啥必要用这些比较低级的东东。能用通用高级数据结构就直接用，这样大家都比较好理解，总结就是只是给共享资源加锁用Lock、限制资源访问使用BoundedSeamphore，唤醒相关线程使用Event</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程是个坑爹的课题，有多线程就有锁。Python中有低级线程模块_thread、再封装一下就是threading、再来一下就是&lt;code&gt;from concurrent.futures import ThreadPoolExecutor&lt;/code&gt;。其中涉及到的锁大概有Lock、RLock、Condition、Semaphore、BoundedSeamphore、Event。这么多看起来怪吓人的，其实这么多的锁全部只是由Lock演化出来的&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 信号</title>
    <link href="https://www.zoulei.net/2018/03/06/linux_signal/"/>
    <id>https://www.zoulei.net/2018/03/06/linux_signal/</id>
    <published>2018-03-06T04:29:40.000Z</published>
    <updated>2018-03-06T04:35:15.156Z</updated>
    
    <content type="html"><![CDATA[<p>信号是进程间通信的一种方式,同时它是一种异步的形式。先注册信号处理函数，当接收到信号的时候回调该函数进程处理。信号在系统中以数字的形式标识。每个信号对应着一个处理函数</p>
<a id="more"></a>
<h3 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h3><p>来个python打印支持的信号<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> signal</div><div class="line"></div><div class="line">signals_to_names = &#123;</div><div class="line">    getattr(signal, n): n</div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> dir(signal)</div><div class="line">    <span class="keyword">if</span> n.startswith(<span class="string">'SIG'</span>) <span class="keyword">and</span> <span class="string">'_'</span> <span class="keyword">not</span> <span class="keyword">in</span> n</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> s, name <span class="keyword">in</span> sorted(signals_to_names.items()):</div><div class="line">    handler = signal.getsignal(s)</div><div class="line">    <span class="keyword">if</span> handler <span class="keyword">is</span> signal.SIG_DFL:</div><div class="line">        handler = <span class="string">'SIG_DFL'</span></div><div class="line">    <span class="keyword">elif</span> handler <span class="keyword">is</span> signal.SIG_IGN:</div><div class="line">        handler = <span class="string">'SIG_IGN'</span></div><div class="line">    print(<span class="string">'&#123;:&lt;10&#125; (&#123;:2d&#125;):'</span>.format(name, s), handler)</div></pre></td></tr></table></figure></p>
<p>因为平时用的少，而ubuntu上的<code>man 7 signal</code>的内容比较多，我只是在osx上看了一下singal的文档。它仅包含下列一些信号</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>默认动作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>终止进程</td>
<td>让程序挂起</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止进程</td>
<td>打断程序的执行</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>dump</td>
<td>程序</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>dump</td>
<td>非法指令</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>dump</td>
<td>陷阱</td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>dump</td>
<td>打断程序</td>
</tr>
<tr>
<td>7</td>
<td>SIGEMT</td>
<td>dump</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>dump</td>
<td>浮点数异常</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止进程</td>
<td>杀死程序(不可修改)</td>
</tr>
<tr>
<td>10</td>
<td>SIGBUS</td>
<td>dump</td>
<td>总线错误</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>dump</td>
<td>段错误</td>
</tr>
<tr>
<td>12</td>
<td>SIGSYS</td>
<td>dump</td>
<td>调用不存在的系统调用</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>终止进程</td>
<td>给一个没有读的管道写数据</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>终止进程</td>
<td>实时计时器超时</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止进程</td>
<td>软中断信号</td>
</tr>
<tr>
<td>16</td>
<td>SIGURG</td>
<td>已废弃</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>SIGSTOP</td>
<td>停止进程</td>
<td>停止(不可修改)</td>
</tr>
<tr>
<td>18</td>
<td>SIGTSTP</td>
<td>停止进程</td>
<td>从键盘生成停止信号</td>
</tr>
<tr>
<td>19</td>
<td>SIGCONT</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>SIGCHLD</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>停止进程</td>
<td>后台进程尝试读取终端时触发</td>
</tr>
<tr>
<td>22</td>
<td>SIGTOU</td>
<td>停止进程</td>
<td>后台进程尝试写入终端时触发</td>
</tr>
<tr>
<td>23</td>
<td>SIGIO</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>终止进程</td>
<td>进程的cpu时间片到期(setrlimit)</td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>终止进程</td>
<td>文件大小超过限制(setrlimit)</td>
</tr>
<tr>
<td>26</td>
<td>SIGVTLRM</td>
<td>终止进程</td>
<td>虚拟时钟超时(setitimer)</td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>终止进程</td>
<td>profil时钟超时(setitimer)</td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>SIGINFO</td>
<td>废弃</td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>SIGUSR1</td>
<td>终止进程</td>
<td>用户自定义信号1</td>
</tr>
<tr>
<td>31</td>
<td>SIGUSR2</td>
<td>终止进程</td>
<td>用户自定义信号2</td>
</tr>
</tbody>
</table>
<h3 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h3><p>信号可以产生自软件和硬件，硬件来说，我们最常用的<code>Ctrl+C</code>来终止一个程序的执行，软件层面就是经常使用<code>kill -9 pid</code>来强制终止一个程序。观察上表可以发现还有很多类似非法指令、陷入、段错误等等都是由操作系统触发反馈给应用程序。还有就是我们自己编写程序进行系统调用触发。比如python中常用的<code>signal.alarm</code></p>
<h3 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h3><p>观察信号表可以发现虽然有31个信号。但是默认动作只有终止进程、dump、停止进程三种。这算成了多对一的关系，多个信号对应一个处理结果。想想这其实是一种人为的约定。操作系统遇到一些异常的时候本可以直接卡擦掉进程。但是还是先知会你一声，万一程序作者觉得遇到这种情况还能再抢救一下那就不异常了。所以规定这么多信号id。还是为了方便编程的时候对信号进行分类处理。而且不仅仅约定俗成。后面还有两个自定义信号让你自己进行定义</p>
<p>信号处理基本有三种套路，默认、忽略、自定义。如果你觉得遇到异常你还可以再抢救一下那就自定义或者忽略。但是假如忽略掉所有的信号。管理人员可能就无法退出你的程序了。<span style="color:red"><strong>因此SIGKILL和SIGSTOP强制不允许被忽略或者自定义</strong></span>。所以<code>kill -9</code>就是一个大杀器</p>
<p>但是很多人并不被推荐用<code>kill -9</code>，而更多的人推荐用<code>kill -15</code>。原因是强制虽然强。但是这样编程人员别无选择。有的程序在意外退出前需要做一些清理工作，比如删掉临时文件啥的。当然，渣水平的作者怎么可能会去自定义处理SIGTERM信号┑(￣Д ￣)┍</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>比如tornado中可以使用信号机制记录响应时间超过阈值的栈帧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado.httpserver</div><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">import</span> tornado.web</div><div class="line"><span class="keyword">import</span> traceback</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_block</span><span class="params">(_, frame)</span>:</span></div><div class="line">    a = traceback.format_stack(frame)</div><div class="line">    print(<span class="string">""</span>.join(a))</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        time.sleep(<span class="number">10</span>)</div><div class="line">        self.write(<span class="string">"Hello, world"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    application = tornado.web.Application([</div><div class="line">        (<span class="string">r"/"</span>, MainHandler),</div><div class="line">    ])</div><div class="line">    http_server = tornado.httpserver.HTTPServer(application)</div><div class="line">    http_server.listen(<span class="number">8888</span>)</div><div class="line">    ioloop = tornado.ioloop.IOLoop.current()</div><div class="line">    ioloop.set_blocking_signal_threshold(<span class="number">1</span>, record_block)</div><div class="line">    ioloop.start()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>关于它的实现就比较简单了。先使用<code>signal.signal(signal.SIGALRM,callback)</code>注册信号回调函数。在ioloop主循环中每次事件完成后将实时计时器归零<code>signal.setitimer(signal.ITIMER_REAL, 0, 0)</code>后再重新开始计时。此处为什么不是用alarm而使用setitimer。因为前者只支持整数秒，后者支持浮点数</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://pymotw.com/3/signal/index.html">signal — Asynchronous System Events</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号是进程间通信的一种方式,同时它是一种异步的形式。先注册信号处理函数，当接收到信号的时候回调该函数进程处理。信号在系统中以数字的形式标识。每个信号对应着一个处理函数&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.zoulei.net/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>利用BK树优化汉明距离查询</title>
    <link href="https://www.zoulei.net/2018/03/04/Postgresql_use_bktree_hamming/"/>
    <id>https://www.zoulei.net/2018/03/04/Postgresql_use_bktree_hamming/</id>
    <published>2018-03-04T02:45:47.000Z</published>
    <updated>2018-03-04T03:22:06.071Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2018/03/03/BKTree_VPTree/">上一篇</a> 介绍了BK树和VP树，并说明用它可以优化汉明距离的查询。用来处理重复图片的问题。本篇我们做出示例演示如何使用，最终的结果是100万条数据。相对于全表遍历的31秒下降到54毫秒。使用了正确的索引速度提升了五百多倍</p>
<a id="more"></a>
<h3 id="获得图片的simhash"><a href="#获得图片的simhash" class="headerlink" title="获得图片的simhash"></a>获得图片的simhash</h3><p>我们直接使用python的第三方库<a href="https://github.com/JohannesBuchner/imagehash">imagehash</a>。代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">import</span> imagehash</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_phash</span><span class="params">(file_path)</span>:</span></div><div class="line">    img = Image.open(file_path)</div><div class="line">    phash = imagehash.phash(img).hash.flatten()</div><div class="line">    phash_list = list(map(bool, phash))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum((<span class="number">2</span> ** k) * v <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(phash_list[<span class="number">1</span>:][::<span class="number">-1</span>]))</div></pre></td></tr></table></figure></p>
<p>需要注意的是。默认得到的phash是一个经过hex编码的字符串。这样会很长，而<span style="color:red"><strong>我们需要保存到数据库的数据是一个bigint类型。因此我们直接获得64位的np.array，</strong></span>将它转换成数字。因为int64中第一位是符号位。后63位是补码。如果直接将64位都转成正整数，很有可能会保存出错。从最方便的角度来说我们可以去掉第一位(实际上我测试了好多个。发现第一位基本都是1)。这样转换得到的数字就能直接存储到数据库了。</p>
<p>如果真的要模拟转换成bigint的效果。可以看我写的<a href="https://gist.github.com/ficapy/e7012d193c5ea85110a404c006ed7273">这个</a></p>
<h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><ul>
<li>来个示例</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--  创建表</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> int8tmp_2</div><div class="line">(</div><div class="line">	a <span class="built_in">bigint</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">-- 写入一百万条数据</span></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> int8tmp_2 <span class="keyword">SELECT</span> val</div><div class="line">                      <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">sqrt</span>(random()) :: <span class="built_in">NUMERIC</span> * <span class="number">9223372036854775807</span> * <span class="number">2</span> -</div><div class="line">                                   <span class="number">9223372036854775807</span> :: <span class="built_in">NUMERIC</span> <span class="keyword">AS</span> val</div><div class="line">                            <span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="number">1000000</span>)) t;</div><div class="line"><span class="comment">-- 创建一个查询函数</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> <span class="keyword">bit_count</span>(<span class="keyword">value</span> <span class="built_in">BIGINT</span>)</div><div class="line">  <span class="keyword">RETURNS</span> <span class="built_in">NUMERIC</span></div><div class="line"><span class="keyword">AS</span> $$ <span class="keyword">SELECT</span> <span class="keyword">SUM</span>((<span class="keyword">value</span> &gt;&gt; <span class="built_in">bit</span>) &amp; <span class="number">1</span>)</div><div class="line">      <span class="keyword">FROM</span> generate_series(<span class="number">0</span>, <span class="number">63</span>) <span class="built_in">bit</span> $$</div><div class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span> IMMUTABLE <span class="keyword">STRICT</span>;</div><div class="line"></div><div class="line"><span class="comment">-- 查询</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  a,</div><div class="line">  <span class="keyword">bit_count</span>(a # <span class="number">8192711222023195111</span>) <span class="keyword">AS</span> hd</div><div class="line"><span class="keyword">FROM</span> int8tmp_2</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">bit_count</span>(a # <span class="number">8192711222023195111</span>) &lt; <span class="number">4</span></div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hd;    </div><div class="line"></div><div class="line"><span class="comment">-- 结果大概这样</span></div><div class="line"><span class="comment">-- [2018-03-04 11:06:56] 1 row retrieved starting from 1 in 25s 403ms (execution: 25s 383ms, fetching: 20ms)</span></div></pre></td></tr></table></figure>
<ul>
<li>使用BK树创建索引</li>
</ul>
<p>我选择了这个扩展<a href="https://github.com/fake-name/pg-spgist_hamming">fake-name/pg-spgist_hamming</a>. 安装的套路是这样的(只支持PG9.6以上版本)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone .......</div><div class="line">cd bktree</div><div class="line">USE_PGXS=1 make</div><div class="line">USE_PGXS=1 make install</div></pre></td></tr></table></figure>
<p><span style="color:red"><strong>注意这个库同时提供了bktree和vptree,但是我没搞懂vptree,vptree的表现很奇怪,另外不能同时使用bktree和vptree。因为它们有一些重载的操作符重复了</strong></span></p>
<ul>
<li>使用流程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 启用扩展</span></div><div class="line"><span class="keyword">CREATE</span> EXTENSION bktree;</div><div class="line"><span class="comment">-- 创建</span></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> int8idx_2 <span class="keyword">ON</span> int8tmp_2 <span class="keyword">USING</span> spgist ( a bktree_ops );</div><div class="line"><span class="comment">-- 查询( &lt;-&gt; 运算符表示计算汉明距离, &lt;@()表示符合汉明距离小于N)</span></div><div class="line"><span class="keyword">SELECT</span></div><div class="line">  a,</div><div class="line">  a &lt;-&gt; <span class="number">8192711222023195111</span> <span class="keyword">AS</span> hd</div><div class="line"><span class="keyword">FROM</span> int8tmp_2</div><div class="line"><span class="keyword">WHERE</span> a &lt;@ (<span class="number">8192711222023195111</span>, <span class="number">4</span>)</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hd;</div><div class="line"><span class="comment">-- 结果大概是这样的</span></div><div class="line">[2018-03-04 11:18:25] 1 row retrieved starting from 1 in 44ms (execution: 31ms, fetching: 13ms)</div></pre></td></tr></table></figure>
<p>世界真美妙┑(￣Д ￣)┍</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/digoal/blog/blob/master/201708/20170804_01.md">海量数据,海明(simhash)距离高效检索(smlar) - 阿里云RDS PosgreSQL最佳实践</a><br><a href="https://stackoverflow.com/questions/46280722/bit-count-function-in-postgresql">bit_count function in PostgreSQL</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2018/03/03/BKTree_VPTree/&quot;&gt;上一篇&lt;/a&gt; 介绍了BK树和VP树，并说明用它可以优化汉明距离的查询。用来处理重复图片的问题。本篇我们做出示例演示如何使用，最终的结果是100万条数据。相对于全表遍历的31秒下降到54毫秒。使用了正确的索引速度提升了五百多倍&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>BK树和VP树</title>
    <link href="https://www.zoulei.net/2018/03/03/BKTree_VPTree/"/>
    <id>https://www.zoulei.net/2018/03/03/BKTree_VPTree/</id>
    <published>2018-03-03T09:17:02.000Z</published>
    <updated>2018-03-04T02:18:38.874Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一个项目需要用到simhash.获取图片的hash值并保存到数据库。在生成新的hash的时候和数据库进行比对。达到去重的效果。假如图片达到了一定数量级，那么每次查询会进行全表扫描，效率是比较低下的，而数据库默认的一些索引又无法达到这个需求，后来看到了BK树。记录一下</p>
<a id="more"></a>
<p>使用Python的库<a href="https://github.com/JohannesBuchner/imagehash">imageHash</a> 运算后会得到64bit长度的结果(最后使用了hex编码导致结果看起来很长)。如果两张图片的bit进行异或后不同的地方越小。说明两张图片越相似。度量这2个bit不相似程度被称之为汉明距离</p>
<p>这个距离它又满足以下性质(被称为Levenshtein)</p>
<ol>
<li>d(x, y) = 0 当且仅当 x=y  （Levenshtein距离为0 &lt;==&gt; 字符串相等）</li>
<li>d(x, y) = d(y, x)     （从x变到y的最少步数就是从y变到x的最少步数）</li>
<li>d(x, y) + d(y, z) &gt;= d(x, z)  （从x变到z所需的步数不会超过x先变成y再变成z的步数）</li>
</ol>
<h3 id="BK树"><a href="#BK树" class="headerlink" title="BK树"></a>BK树</h3><p>为了加速查找, 构建了这样一种树结构。</p>
<ol>
<li>任选一个节点当做根节点</li>
<li>插入节点的时候和根节点对比得到距离。如果该距离不存在则新建一个节点作为根节点的子节点。如果节点存在则获得节点作为根节点进行递归操作</li>
</ol>
<p>第二步的意义在于<strong>任何一个节点下面的元素对于该节点的距离都是相等的</strong>。构建就达到了这个效果。别的啥事没做。</p>
<p>查找过程。查找的原理主要依靠第三条性质<code>d(x, y) + d(y, z) &gt;= d(x, z)</code>.<br>假设我们有这样一个查询要求。需要查找字符串target距离不大于n的所有结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">设root为x, target为y</div><div class="line">d(root, target) + d(target, element) &gt;= d(root, element)</div><div class="line">d(target, element)的取值范围是[0, n]</div><div class="line">得到d(root, element) 的最大值是 n + d(root, target)</div></pre></td></tr></table></figure></p>
<p><strong>因此我们根据这个不等式实现了剪枝的效果</strong>。对于满足条件的元素。将其设置为根元素。递归得到所有满足条件的元素</p>
<h3 id="VP树"><a href="#VP树" class="headerlink" title="VP树"></a>VP树</h3><p>VP树和BK树原理差不多。优点是当需要查询的距离N更大的时候效率更高(具体原理我还不太了解。写的时候发现很多时候它的效率甚至是不及BK树的)。</p>
<p>BK树可以看出是一个多叉树。每个节点下面可以有多个节点。VP树不同，它是一个二叉树。根据我的需求。简单起见。每一个节点我设置了相同的阈值。距离小于阈值则放在左边，大于则放在右边。</p>
<p>查找的时候还挺尴尬的。根据上面说的<code>d(root, element) &lt;= n + d(root, target)</code>。当节点的阈值小于这个值的时候左右子节点都需要遍历。当节点阈值大于的时候就只需要遍历左边(达到剪枝的效果)</p>
<p>注意:  以上我都只考虑了添加，没有考虑修改和删除的事情。</p>
<p>Python版本代码实现如下</p>
<script src="//gist.github.com/ficapy/ed909648b184bc2fc1486ce90175d356.js?file=bk_tree.py"></script>
<script src="//gist.github.com/ficapy/ed909648b184bc2fc1486ce90175d356.js?file=vp_tree.py"></script>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.matrix67.com/blog/archives/333">编辑距离、拼写检查与度量空间：一个有趣的数据结构</a><br><a href="https://fribbels.github.io/vptree/writeup">VP Tree</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有一个项目需要用到simhash.获取图片的hash值并保存到数据库。在生成新的hash的时候和数据库进行比对。达到去重的效果。假如图片达到了一定数量级，那么每次查询会进行全表扫描，效率是比较低下的，而数据库默认的一些索引又无法达到这个需求，后来看到了BK树。记录一下&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>开始GitLab CI/CD</title>
    <link href="https://www.zoulei.net/2017/12/25/GitLabCICD_quickstart/"/>
    <id>https://www.zoulei.net/2017/12/25/GitLabCICD_quickstart/</id>
    <published>2017-12-25T12:38:35.000Z</published>
    <updated>2017-12-26T01:34:46.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitLabCI-CD流程"><a href="#GitLabCI-CD流程" class="headerlink" title="GitLabCI/CD流程"></a>GitLabCI/CD流程</h3><p>gitlab如果没有和Docker很好的结合。那么它会是一个很平凡的产品。但是有了CI对比其他产品Gogs、github等它还算可堪一用。上一篇文章写了gitlab_ci.yml配置文件的一些参数的含义。本篇文章记录一下如何从零在Gitlab上完成简单的CI/CD流程。基础流程如下Build流程构建我们需要的镜像上传到镜像仓库。部署的时候从镜像仓库直接拉取重启容器<br><img src="https://ficapy.b0.upaiyun.com/blogimg/GitlabCI.jpg" alt="GitlabCI"><br><a id="more"></a></p>
<h3 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h3><p>这个没什么好说的。无脑apt就好了。安装完毕后需要将本地用户加入到Docker用户组。方便命令的执行。在生产环境下需要注意的是最好修改它的默认配置，/etc/docker/daemon.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;data-root&quot;: &quot;/data/docker&quot;,</div><div class="line">    &quot;registry-mirrors&quot;: [&quot;https://xxx.mirror.aliyuncs.com&quot;],</div><div class="line">    &quot;log-opts&quot;: &#123;</div><div class="line">        &quot;max-size&quot;: &quot;50m&quot;,</div><div class="line">        &quot;max-file&quot;: &quot;3&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>现在云主机都是低容量系统盘外加高容量挂载盘组成。修改一下默认的根目录会比较好</li>
<li>没个镜像源下载dockerhub镜像不明智啊</li>
<li>限定一下最大日志量总没错。否则时间太长日志多了也很烦人</li>
</ol>
<h2 id="2-搭建Docker镜像仓库"><a href="#2-搭建Docker镜像仓库" class="headerlink" title="2. 搭建Docker镜像仓库"></a>2. 搭建Docker镜像仓库</h2><p>我使用的是Vmware出品的<a href="https://github.com/vmware/harbor">Harbor</a>。安装中遇到了以下几个坑</p>
<ol>
<li>按照文档从源码安装失败。直接下载八百多兆的离线安装包安装好歹算是成功了</li>
<li>我将HTTPS放到负载均衡上面。实际请求到后端的是http协议。所以我将配置修改为http。但是登陆失败。查了下将common/config/registry/config.yml的token由http改成https可以登陆了。解决了这个然后还不能push…没办法。我将负载均衡改成TCP端口转发。直接将证书放在harbor上。可算是没毛病了</li>
<li>以前配置过一次Harbor。导致了历史遗留文件。再次安装结果并不会覆盖掉以前的配置也不会做任何提示。</li>
<li>配置文件里面我改了一下secretkey_path地址。结果无法使用，无奈又改回来了</li>
</ol>
<p>总结。在Harbor作为宣称的企业级Docker镜像工具。杀手级功能是异地复制，镜像验证。安全扫描啥的。如果只是要搞个基础的镜像仓库。最后想了想还不如折腾Gitlab的Docker仓库。说不定在权限上和Gitlab结合的更好</p>
<h2 id="3-注册Gitlab-runner"><a href="#3-注册Gitlab-runner" class="headerlink" title="3. 注册Gitlab-runner"></a>3. 注册Gitlab-runner</h2><p>这应该算是CI强大的地方了。它和Gitlab本身松耦合。客户端建立长连接和Gitlab服务器保持通信。当满足条件的时候由Gitlab对Runner进行调度。Gitlab-runner是使用Go编写的，便于部署。当Runner接收到请求的时候它会执行shell脚本。想象一下python界的fabric。依次执行Bash命令。Runner也是差不多的套路。多条Bash命令间是没有相关性的。比如你上一条执行<code>cd demo</code>下一条<code>pwd</code>得到的还是本地用户目录，并不是demo。</p>
<ol>
<li>启动gitlab-runner Service</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker run -d --name gitlab-runner --restart always \</div><div class="line">  -v /var/gitlab-runner/config:/etc/gitlab-runner \</div><div class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</div><div class="line">  gitlab/gitlab-runner:latest</div></pre></td></tr></table></figure>
<p>顺便说一下。要是执行gitlab-runner看它的命令行参数还挺多。其实是自身设计的不太好。显得好像很复杂，很多命令需要被<a href="https://docs.gitlab.com/runner/commands/README.html#service-related-commands">废弃了</a>.它的使用其实还是很简单的。如果你需要看帮助。那么执行<code>gitlab-runner register -h</code>还有点用</p>
<ol>
<li>添加Runner</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker exec -it gitlab-runner gitlab-runner register -n --tag-list &quot;name&quot; \</div><div class="line">    -r &quot;token&quot; --name &quot;BigBrother&quot; -u https://gitlab.company.com \</div><div class="line">    --executor &quot;docker&quot; --docker-image &quot;default_image&quot; \</div><div class="line">    --docker-volumes /var/run/docker.sock:/var/run/docker.sock</div></pre></td></tr></table></figure>
<ul>
<li>n 表示非交互模式</li>
<li>tag-list表示该Runner的标签(单独的项目用单独的tag也挺好。互不干扰)</li>
<li>r 该项目的token</li>
<li>name 名称标识</li>
<li>u Gitlab地址</li>
<li>executor 和上面说的执行bash命令。有多种方式。无脑用docker挺好</li>
<li>docker-image executor选择了docker之后,需要选择默认的镜像</li>
<li>docker-volumes 这个是为了在docker里面<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html">使用Docker构建镜像</a></li>
</ul>
<p>以上两步完成后就能够在Gitlab后台看到正常状态的Runner了</p>
<h3 id="4-编写-gitlab-ci-yml文件"><a href="#4-编写-gitlab-ci-yml文件" class="headerlink" title="4. 编写.gitlab-ci.yml文件"></a>4. 编写.gitlab-ci.yml文件</h3><p>如果你有丰富的Docker使用经验，这一步实际上没有太大的问题。本例中我只是通过docker build构建了镜像。然后上传到仓库。需要部署的时候使用SSH连接到远程机器上使用<code>docker-compose up --build -d</code>更新程序<br>Demo项目目录如下。正常本地启动执行python main.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── README.md</div><div class="line">├── conf.py</div><div class="line">├── deploy</div><div class="line">│   ├── Dockerfile</div><div class="line">│   ├── prod_env</div><div class="line">│   ├── docker-compose.yml</div><div class="line">│   └── stage_env</div><div class="line">├── main.py</div><div class="line">├── .gitlab-ci.yml</div><div class="line">└── requirements.txt</div></pre></td></tr></table></figure>
<p>Dockerfile如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">FROM ficapy/python35_alpine</div><div class="line"></div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">ENV PYTHONPATH=/app</div><div class="line"></div><div class="line">COPY ./requirements.txt /app/requirements.txt</div><div class="line">RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</div><div class="line"></div><div class="line">COPY . /app</div><div class="line"></div><div class="line">CMD [&quot;python&quot;, &quot;main.py&quot;]</div></pre></td></tr></table></figure>
<p>docker-compose.yml如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line"></div><div class="line">services:</div><div class="line">  Name:</div><div class="line">    image: registry.company.com/repos/projectname:$&#123;TAG&#125;</div><div class="line">    restart: always</div><div class="line">    env_file:</div><div class="line">      - $&#123;ENV&#125;_env</div></pre></td></tr></table></figure>
<p>.gitlab-ci.yml如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">image: ficapy/docker:latest</div><div class="line"></div><div class="line">variables:</div><div class="line">  SSH: &quot;Host xxxxx&quot;</div><div class="line"></div><div class="line">stages:</div><div class="line">  - build</div><div class="line">  - deploy</div><div class="line"></div><div class="line">build:</div><div class="line">  stage: build</div><div class="line">  only:</div><div class="line">    - master</div><div class="line">  tags:</div><div class="line">    - tag</div><div class="line">  script:</div><div class="line">      - export DOCKER_TAG=$(env TZ=&apos;Asia/Shanghai&apos; date -d @$(git log -n1 $CI_COMMIT_SHA --format=&quot;%at&quot;) +%Y_%m_%d_%H%M%S)</div><div class="line">      - echo $DOCKER_TAG</div><div class="line">      - docker login -u deploy -p $DOCKER_PWD registry.company.com</div><div class="line">      - docker build -t registry.company.com/repos/must_lower_case:$DOCKER_TAG -f deploy/Dockerfile .</div><div class="line">      - docker push registry.company.com/repos/must_lower_case:$DOCKER_TAG</div><div class="line"></div><div class="line">prod_deploy:</div><div class="line">  stage: deploy</div><div class="line">  only:</div><div class="line">    - master</div><div class="line">  tags:</div><div class="line">    - tag</div><div class="line">  when: manual</div><div class="line">  variables:</div><div class="line">    SERVER: ssh_name</div><div class="line">  before_script:</div><div class="line">    - export DOCKER_TAG=$(env TZ=&apos;Asia/Shanghai&apos; date -d @$(git log -n1 $CI_COMMIT_SHA --format=&quot;%at&quot;) +%Y_%m_%d_%H%M%S)</div><div class="line">    - echo $DOCKER_TAG</div><div class="line">    - eval $(ssh-agent -s)</div><div class="line">    - bash -c &quot;ssh-add &lt;(echo &apos;$SSH_PRIVATE_KEY&apos;)&quot;</div><div class="line">    - mkdir -p ~/.ssh</div><div class="line">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;$SSH&quot; &gt; ~/.ssh/config&apos;</div><div class="line">  script:</div><div class="line">    - ssh $SERVER &quot;mkdir -p ~/$CI_PROJECT_NAME || true&quot;</div><div class="line">    - rsync -r deploy $SERVER:~/$CI_PROJECT_NAME</div><div class="line">    - ssh $SERVER &quot;docker login -u deploy -p $DOCKER_PWD registry.company.com&quot;</div><div class="line">    - ssh $SERVER &quot;cd $CI_PROJECT_NAME/deploy &amp;&amp; TAG=$DOCKER_TAG ENV=prod docker-compose up --build -d&quot;</div><div class="line">  environment:</div><div class="line">    name: PROD</div></pre></td></tr></table></figure>
<p>整个过程看配置文件应该还是比较容易理解的。如果有些参数不太明白请查看前一篇gitlabci yml笔记。因为它只是个Demo。所以我让他在每次master分支提交的时候都进行触发。整个部署流程实际上就是使用了SSH远程连接之后操作docker-compose进行更新。过程中感觉让我比较难以决断的是如何搞一个好的TAG方法</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完成上述过程之后我做一个自我总结。所谓CI/CD不过是将我们懒得输入的命令组合形成文件。让它依次执行Test-&gt;Build-&gt;Deploy。该方案几乎使用了全套Docker.从gitlab-runner、build到镜像仓库到生产环境的部署。在项目比较多的时候它是有好处的。比如有十个项目需要更新。每个项目需要更新到多个环境下。那么使用这种自动化还是有优势的。如果就一两个项目，而且只需要更新到测试和生产环境。个人觉得fabric就够了。而且该方案有一个缺点就是部署速度较慢。Gitlab每次执行任务速度并不是想象的那么快。最后生成镜像，上传，再拉取到正式环境。如果镜像过大就更慢了。而如果不使用Docker镜像的方式。直接git pull拉取源码。再supervisorctl更新程序。时间基本是秒级的。在频繁更新的测试环境它可能更高效。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;GitLabCI-CD流程&quot;&gt;&lt;a href=&quot;#GitLabCI-CD流程&quot; class=&quot;headerlink&quot; title=&quot;GitLabCI/CD流程&quot;&gt;&lt;/a&gt;GitLabCI/CD流程&lt;/h3&gt;&lt;p&gt;gitlab如果没有和Docker很好的结合。那么它会是一个很平凡的产品。但是有了CI对比其他产品Gogs、github等它还算可堪一用。上一篇文章写了gitlab_ci.yml配置文件的一些参数的含义。本篇文章记录一下如何从零在Gitlab上完成简单的CI/CD流程。基础流程如下Build流程构建我们需要的镜像上传到镜像仓库。部署的时候从镜像仓库直接拉取重启容器&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/blogimg/GitlabCI.jpg&quot; alt=&quot;GitlabCI&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>gitlabci yml 笔记</title>
    <link href="https://www.zoulei.net/2017/12/25/gitlabciyml_note/"/>
    <id>https://www.zoulei.net/2017/12/25/gitlabciyml_note/</id>
    <published>2017-12-25T04:17:56.000Z</published>
    <updated>2017-12-25T06:10:56.899Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容来自GitlabCI官方文档</p>
<h2 id="最基础的"><a href="#最基础的" class="headerlink" title="最基础的"></a>最基础的</h2><ul>
<li><p>jobs作为最顶级的元素。每个job至少包含一个script</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">job1:</div><div class="line">    script1: pwd</div></pre></td></tr></table></figure>
<p>  每个job的执行都是完全独立于其他的job</p>
</li>
</ul>
<a id="more"></a>
<h2 id="关于Docker-Image和Service的使用"><a href="#关于Docker-Image和Service的使用" class="headerlink" title="关于Docker Image和Service的使用"></a>关于Docker Image和Service的使用</h2><ul>
<li><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html">Using Docker Build</a>。主要讲述怎么在Docker里面使用Docker构建镜像。(最简单的是在注册Runner的时候共享/var/run/docker.sock)</li>
<li><p><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html">Using Docker images</a>。</p>
</li>
<li><p>注册的时候可以同时运行Services。这样在任务执行期间可以访问services</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo gitlab-runner register \</div><div class="line">    --url &quot;https://gitlab.example.com/&quot; \</div><div class="line">    --registration-token &quot;PROJECT_REGISTRATION_TOKEN&quot; \</div><div class="line">    --description &quot;docker-ruby-2.1&quot; \</div><div class="line">    --executor &quot;docker&quot; \</div><div class="line">    --docker-image ruby:2.1 \</div><div class="line">    --docker-postgres latest \</div><div class="line">    --docker-mysql latest</div></pre></td></tr></table></figure>
</li>
<li><p>service就是任务执行的时候能够访问到别的容器。比如Mysql、Postgresql、Redis、Rabbitmq啥的</p>
</li>
<li>访问service就和我们使用docker-compose差不多</li>
</ul>
<h2 id="其他的一些Top-Level设置"><a href="#其他的一些Top-Level设置" class="headerlink" title="其他的一些Top-Level设置"></a>其他的一些Top-Level设置</h2><ul>
<li>before_script: 在每个任务执行前执行.比如配置好ssh config</li>
<li>after_script: 在每个任务执行完成后执行.好像用处不大</li>
<li>stages: <span style="color:red"><strong> 每个任务都可以属于一个stage.同一个stage的job是并行的.但是只有一个stage所有都执行完毕才会执行下一个stage</strong></span></li>
<li>variables: 每个job都可以使用的环境变量。此处只能进行很简单的设置。比如我希望将当前日期用一个固定的格式表达(需要用date命令进行转换),在这里是行不通的</li>
<li>cache: </li>
</ul>
<h2 id="可选项最多的Jobs配置来了"><a href="#可选项最多的Jobs配置来了" class="headerlink" title="可选项最多的Jobs配置来了"></a>可选项最多的Jobs配置来了</h2><ul>
<li>jobs: 必须要有独立的名称</li>
</ul>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>script</td>
<td>定义shell脚本</td>
</tr>
<tr>
<td>image</td>
<td>使用的image.可以覆盖掉全局的</td>
</tr>
<tr>
<td>services</td>
<td>使用docker services,覆盖掉全局</td>
</tr>
<tr>
<td>stage</td>
<td>属于哪个阶段</td>
</tr>
<tr>
<td>variables</td>
<td>定义job的环境变量</td>
</tr>
<tr>
<td>only</td>
<td>只有满足某条件的时候才会被执行</td>
</tr>
<tr>
<td>except</td>
<td>满足某条件的时候不执行</td>
</tr>
<tr>
<td>tags</td>
<td>哪些Runners能够执行该任务</td>
</tr>
<tr>
<td>allow_failure</td>
<td>允许任务失败。正常情况下失败则会不进行后续步骤</td>
</tr>
<tr>
<td>when</td>
<td>定义任务什么时候执行。manual手动还挺有用┑(￣Д ￣)┍</td>
</tr>
<tr>
<td>artifacts</td>
<td>将构建生成的文件上传到gitlab。允许从gitlab后台进行下载</td>
</tr>
<tr>
<td>dependencies</td>
<td>配合artifacts使用。将生成的artifacts文件跨job使用    </td>
</tr>
<tr>
<td>cache</td>
<td>缓存文件给后续job使用</td>
</tr>
<tr>
<td>before_script</td>
<td>覆盖全局</td>
</tr>
<tr>
<td>after_script</td>
<td>覆盖全局</td>
</tr>
<tr>
<td>environment</td>
<td><a href="https://docs.gitlab.com/ee/ci/environments.html">文档</a></td>
</tr>
<tr>
<td>coverage</td>
<td>代码覆盖率设置</td>
</tr>
<tr>
<td>retry</td>
<td>如果失败则重试几次</td>
</tr>
</tbody>
</table>
<p>额外说明:</p>
<ol>
<li>environment配合deploy使用.部署的时候人为标记是部署到了哪个环境。方便在gitlab后台查看历史记录。同时方便错误的时候可以直接在gitlab后台回滚部署。其实这个参数不要也是可以的。添加上去只是更方便一点</li>
<li>artifacts和cache的区别.<ul>
<li>cache可以在全局使用也可以在job内部使用.但是artifacts只能在job内部使用</li>
<li><span style="color:red"><strong>特别注意</strong></span> cache跨越该项目的整个生命周期。跨越不同的pipeline.job开始之前会先解压已有的cache.而artifacts只会再单个pipeline周期。且某个stage创建之后。在后续的stage中才能够使用。artifacts会同时上传文件到gitlab(上传步骤还是必须的)。</li>
</ul>
</li>
</ol>
<h2 id="YAML特殊语法"><a href="#YAML特殊语法" class="headerlink" title="YAML特殊语法"></a>YAML特殊语法</h2><ul>
<li><p>用anchors(&amp;)、aliases(*)、merging(&lt;&lt;) 来简化编写(大多数情况下应该没啥用)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.job_template: &amp;job_definition  # Hidden key that defines an anchor named &apos;job_definition&apos;</div><div class="line">image: ruby:2.1</div><div class="line">services:</div><div class="line">    - postgres</div><div class="line">    - redis</div><div class="line"></div><div class="line">test1:</div><div class="line">&lt;&lt;: *job_definition           # Merge the contents of the &apos;job_definition&apos; alias</div><div class="line">script:</div><div class="line">    - test1 project</div><div class="line"></div><div class="line">test2:</div><div class="line">&lt;&lt;: *job_definition           # Merge the contents of the &apos;job_definition&apos; alias</div><div class="line">script:</div><div class="line">    - test2 project</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://docs.gitlab.com/ee/ci/yaml/README.html">Configuration of your jobs with .gitlab-ci.yml </a><br><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html">Using Docker images</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容来自GitlabCI官方文档&lt;/p&gt;
&lt;h2 id=&quot;最基础的&quot;&gt;&lt;a href=&quot;#最基础的&quot; class=&quot;headerlink&quot; title=&quot;最基础的&quot;&gt;&lt;/a&gt;最基础的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;jobs作为最顶级的元素。每个job至少包含一个script&lt;/p&gt;
  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;job1:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    script1: pwd&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  每个job的执行都是完全独立于其他的job&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>influxdb 专业术语</title>
    <link href="https://www.zoulei.net/2017/12/09/influxdb_glossary/"/>
    <id>https://www.zoulei.net/2017/12/09/influxdb_glossary/</id>
    <published>2017-12-09T00:02:41.000Z</published>
    <updated>2017-12-09T08:52:51.153Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基本全篇摘抄自v1.3的官方文档,先从理解下面这张两张图开始<br><img src="https://ficapy.b0.upaiyun.com/capture/influxdb_glossary.jpg" alt="influxdb_glossary"><br><img src="https://ficapy.b0.upaiyun.com/capture/influxdb_field.jpg" alt="influxdb"><br><a id="more"></a></p>
<h3 id="aggregation-聚合"><a href="#aggregation-聚合" class="headerlink" title="aggregation 聚合"></a>aggregation 聚合</h3><p>使用聚合函数对points中的set返回聚合结果</p>
<ul>
<li>count 返回非null的field values个数</li>
<li>distinct  返回唯一field values列表</li>
<li>integral 由过滤条件组成的积分</li>
<li>mean  返回field values的算术平均值</li>
<li>median 返回field values排序后的中位数</li>
<li>mode  从field values列表中返回最常用的值</li>
<li>spread 最大减去最小</li>
<li>stddev 标准差</li>
<li>sum 求和</li>
</ul>
<h3 id="batch-批量"><a href="#batch-批量" class="headerlink" title="batch 批量"></a>batch 批量</h3><p>为了减少influxdb的负载，建议对point的集合进行上传。使用\n做分割。建议每批包含五千到一万个point</p>
<h3 id="continuous-query-CQ-持续查询"><a href="#continuous-query-CQ-持续查询" class="headerlink" title="continuous query(CQ) 持续查询"></a>continuous query(CQ) 持续查询</h3><p>定期执行自动查询并将结果持久化到数据库</p>
<h3 id="database-数据库"><a href="#database-数据库" class="headerlink" title="database 数据库"></a>database 数据库</h3><p>和关系型数据库差不多吧。</p>
<table>
<thead>
<tr>
<th>关系型数据库</th>
<th>influxdb</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>database</td>
</tr>
<tr>
<td>table</td>
<td>measurement</td>
</tr>
<tr>
<td>row</td>
<td>point</td>
</tr>
</tbody>
</table>
<p>特别点的就是。influxdb有保留策略</p>
<h3 id="duration-持续时间"><a href="#duration-持续时间" class="headerlink" title="duration 持续时间"></a>duration 持续时间</h3><p>保留策略的一个属性表示数据会保存多久。数据过期会被执行自动删除</p>
<h3 id="field-字段"><a href="#field-字段" class="headerlink" title="field 字段"></a>field 字段</h3><p>对比tag来说field没有被索引。在一段时间范围内查询field的值需要扫描所有的point得到结果。性能没有tag好</p>
<h3 id="field-key-字段的key"><a href="#field-key-字段的key" class="headerlink" title="field key 字段的key"></a>field key 字段的key</h3><p>在key-value对中表示field字段的key.只能是string类型。存储到metadata中</p>
<h3 id="field-set-字段的集合"><a href="#field-set-字段的集合" class="headerlink" title="field set 字段的集合"></a>field set 字段的集合</h3><p>所有field key的集合</p>
<h3 id="field-value-字段的值"><a href="#field-value-字段的值" class="headerlink" title="field value 字段的值"></a>field value 字段的值</h3><p>field的value。类型可以是strings、float、integers、booleans。field的值始终与时间戳相关</p>
<h3 id="function-函数"><a href="#function-函数" class="headerlink" title="function 函数"></a>function 函数</h3><p>分三类，聚合、选择、转换</p>
<h3 id="identifier-标识"><a href="#identifier-标识" class="headerlink" title="identifier 标识"></a>identifier 标识</h3><p>emmm…持续查询名称、数据库名称、field字段、度量名称、保留策略名称、订阅名称、标签名称、用户名</p>
<h3 id="line-protocol-行协议"><a href="#line-protocol-行协议" class="headerlink" title="line protocol 行协议"></a>line protocol 行协议</h3><p>基于文本格式写入到influxdb</p>
<h3 id="measurement-度量"><a href="#measurement-度量" class="headerlink" title="measurement 度量"></a>measurement 度量</h3><p>emmm…可以类比到关系型数据库的table</p>
<h3 id="metastore-元数据存储"><a href="#metastore-元数据存储" class="headerlink" title="metastore  元数据存储"></a>metastore  元数据存储</h3><p>包含内部系统的状态信息。元素据存储包含了用户信息、数据库信息、保留侧列、分片元数据、持续查询和订阅</p>
<h3 id="node-节点"><a href="#node-节点" class="headerlink" title="node 节点"></a>node 节点</h3><p>一个独立的influxd进程</p>
<h3 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h3><p>本地的纳秒时间戳</p>
<h3 id="point-点"><a href="#point-点" class="headerlink" title="point 点"></a>point 点</h3><ul>
<li>在serises中由fields组成的单个数据。<code>每个point由它的series和时间戳组成唯一标识</code>(重点)</li>
<li>对于一个相同的时间戳和相同的series只能保存一个point.如果相同则新的field set覆盖掉旧的</li>
</ul>
<h3 id="query-查询"><a href="#query-查询" class="headerlink" title="query 查询"></a>query 查询</h3><p>从influxdb中查询到相关数据的操作</p>
<h3 id="replication-factor-复制因子"><a href="#replication-factor-复制因子" class="headerlink" title="replication factor 复制因子"></a>replication factor 复制因子</h3><p>对集群有用。O__O “…可是集群并不是免费功能,将一份数据保留到集群上多份</p>
<h3 id="retention-policy-RP-保留策略"><a href="#retention-policy-RP-保留策略" class="headerlink" title="retention policy(RP) 保留策略"></a>retention policy(RP) 保留策略</h3><p>以数据库作为单位，分三个方面。保留时长，数据多久进行一次分片操作。数据设置多少个副本。默认autogen表示永不删除、一个副本集(表示没副本)、七天进行一次分片</p>
<h3 id="schema-模式"><a href="#schema-模式" class="headerlink" title="schema 模式"></a>schema 模式</h3><p>如何组织数据到influxdb。包含databases、retention policies、series、measurements、tag keys、tag values、field keys</p>
<h3 id="selector-选择器"><a href="#selector-选择器" class="headerlink" title="selector 选择器"></a>selector 选择器</h3><p>一个函数，从特定范围的point中返回单个</p>
<ul>
<li>bottom 返回N个最小的field value</li>
<li>first  返回最开始时间的field value</li>
<li>last  返回最近时间的field value</li>
<li>max  返回最大的field value</li>
<li>min  返回最小的field value</li>
<li>percentile 根据百分比返回</li>
<li>sample  随机返回</li>
<li>top  返回最大的N个field value</li>
</ul>
<h3 id="series-序列"><a href="#series-序列" class="headerlink" title="series 序列"></a>series 序列</h3><p>由measurement、tag set、retention policy组成(<code>注意:field set不在里面</code>)</p>
<h3 id="series-cardinality-序列基数"><a href="#series-cardinality-序列基数" class="headerlink" title="series cardinality 序列基数"></a>series cardinality 序列基数</h3><p>唯一的series数，如果一个measurement有2个tag key。1个有三个唯一的值。另一个有两个。那么序列基数为6.因为tag集合是保存在内存中的。在配置里面也有默认的数量限制</p>
<h3 id="server-服务器"><a href="#server-服务器" class="headerlink" title="server 服务器"></a>server 服务器</h3><p>运行influxdb的环境。应该一台服务器只运行一个influxdb进程</p>
<h3 id="shard-分片"><a href="#shard-分片" class="headerlink" title="shard 分片"></a>shard 分片</h3><p>包含编码和压缩数据，作为TSM文件保存到磁盘。每个分片属于唯一的一个shard group。每个分片包含了特定的series</p>
<h3 id="shard-duration-分片持续时间"><a href="#shard-duration-分片持续时间" class="headerlink" title="shard duration 分片持续时间"></a>shard duration 分片持续时间</h3><p>由保留策略中的shard duration决定。</p>
<h3 id="shard-group-分片组"><a href="#shard-group-分片组" class="headerlink" title="shard group 分片组"></a>shard group 分片组</h3><p>分片组(保留策略)-&gt;shard-&gt;data.为了自动删除搞出了这么多概念┑(￣Д ￣)┍</p>
<h3 id="subscription-订阅"><a href="#subscription-订阅" class="headerlink" title="subscription 订阅"></a>subscription 订阅</h3><p>O__O “… 好像并没有什么用。搭配kapactior使用。订阅它的数据进行存储</p>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>对比field。tag是有索引的</p>
<h3 id="tag-key"><a href="#tag-key" class="headerlink" title="tag key"></a>tag key</h3><p>略</p>
<h3 id="tag-set"><a href="#tag-set" class="headerlink" title="tag set"></a>tag set</h3><p>略</p>
<h3 id="tag-value"><a href="#tag-value" class="headerlink" title="tag value"></a>tag value</h3><p>只能为数字。存储到metadata</p>
<h3 id="timestamp-时间戳"><a href="#timestamp-时间戳" class="headerlink" title="timestamp 时间戳"></a>timestamp 时间戳</h3><p>和point关联的时间戳，可以有多种时间格式存储和查询</p>
<h3 id="transformation-变换"><a href="#transformation-变换" class="headerlink" title="transformation 变换"></a>transformation 变换</h3><p>特定的点返回值和集合，得到的结果不能用来再次聚合</p>
<ul>
<li>ceiling 目前还不支持(ceil,floor)</li>
<li>cumulative_sum 将列表变成累加和列表(原有1,1,2,2变成1,2,4,6)  </li>
<li>derivative 导数</li>
<li>difference 和第一个结果相减得到不同</li>
<li>elapsed  得到时间戳的不同</li>
<li>floor  目前还不支持</li>
<li>histogram 目前还不支持</li>
<li>moving_average 滚动平均值(原有1,2,3得到1.5,2.5)</li>
<li>non_negative_derivative 非负导数</li>
<li>non_negative_difference 非负不同</li>
</ul>
<h3 id="tsm-Time-Structured-Merge-tree"><a href="#tsm-Time-Structured-Merge-tree" class="headerlink" title="tsm(Time Structured Merge tree)"></a>tsm(Time Structured Merge tree)</h3><p>influxdb的专用存储格式。允许高压缩和高速写入读取速度要高于已存在的B+树或者LSM树</p>
<h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><ul>
<li>admin用户具有读写所有数据库的权限并且可以管理用户</li>
<li>非admin有每个数据库的读写权限(被admin分配)</li>
</ul>
<h3 id="value-per-second"><a href="#value-per-second" class="headerlink" title="value per second"></a>value per second</h3><p>度量写入速度,比如每个point有四个field,每批有5000个point.写入速度为每秒10个。那么values per second速率为<code>4*5000*10</code></p>
<h3 id="WAL-write-ahead-log-预写日志"><a href="#WAL-write-ahead-log-预写日志" class="headerlink" title="WAL(write ahead log) 预写日志"></a>WAL(write ahead log) 预写日志</h3><p>略</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基本全篇摘抄自v1.3的官方文档,先从理解下面这张两张图开始&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/capture/influxdb_glossary.jpg&quot; alt=&quot;influxdb_glossary&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://ficapy.b0.upaiyun.com/capture/influxdb_field.jpg&quot; alt=&quot;influxdb&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记</title>
    <link href="https://www.zoulei.net/2017/12/07/ELK/"/>
    <id>https://www.zoulei.net/2017/12/07/ELK/</id>
    <published>2017-12-07T01:18:08.000Z</published>
    <updated>2017-12-07T01:34:28.783Z</updated>
    
    <content type="html"><![CDATA[<p>以下是看<a href="https://www.udemy.com/complete-elasticsearch-masterclass-with-kibana-and-logstash/">udemy的Elasticsearch入门教程</a>做的简短笔记</p>
<a id="more"></a>
<ol>
<li><p>基础知识、下载、配置(1-3)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">brew cask install java</div><div class="line">下载elasticsearch、kibana</div><div class="line">config/kibana 配置文件</div><div class="line">bin/elasticsearch   (9200)</div><div class="line">bin/kibana  启动(5601端口)</div></pre></td></tr></table></figure>
<p> Elasticsearch is Document Oriented</p>
<ul>
<li>insert Documents</li>
<li>Delete Documents</li>
<li>Retrieve Documents</li>
<li>Analyze Documents</li>
<li><p>Search Documents</p>
<h4 id="inverted-index"><a href="#inverted-index" class="headerlink" title="inverted index"></a>inverted index</h4><h4 id="JSON对象-经典数据库的Table模型转变为JSON模型"><a href="#JSON对象-经典数据库的Table模型转变为JSON模型" class="headerlink" title="JSON对象(经典数据库的Table模型转变为JSON模型)"></a>JSON对象(经典数据库的Table模型转变为JSON模型)</h4><p>ElasticSearch | Relational DB<br>— | —<br>Field   | Column<br>Document    | Row<br>Type    |   Table<br>Index   |   Database</p>
</li>
</ul>
</li>
<li><p>数据存储引擎、分布式工作引擎集群，shard(4-7)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</div><div class="line">&#123;</div><div class="line">    &quot;field1&quot;: &quot;value1&quot;,</div><div class="line">    &quot;field2&quot;: &quot;value2&quot;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">相同的id插入会生成不同的版本号</div><div class="line">更新数据的原理是读取数据合并再put.只支持row级别，不支持字段级别</div><div class="line">DELETE /vehicles/car/123</div><div class="line">&#123;</div><div class="line">    &quot;_index&quot;: &quot;vehicles&quot;,</div><div class="line">    &quot;_type&quot;: &quot;car&quot;,</div><div class="line">    &quot;_id&quot;: &quot;123&quot;,</div><div class="line">    &quot;_version&quot;: 13,</div><div class="line">    &quot;result&quot;: &quot;deleted&quot;,</div><div class="line">    &quot;_shards&quot;: &#123;</div><div class="line">        &quot;total&quot;: 2,</div><div class="line">        &quot;successful&quot;: 1,</div><div class="line">        &quot;failed&quot;: 0</div><div class="line">    &#125;,</div><div class="line">    &quot;_seq_no&quot;: 12,</div><div class="line">    &quot;_primary_term&quot;: 1</div><div class="line">&#125;</div><div class="line">即使删除同样也不会真的删除数据只会进行标记。磁盘空间不会立即释放</div></pre></td></tr></table></figure>
<p> mappings and settings.mappings类似与数据库中的schema</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&quot;settings&quot;: &#123;</div><div class="line">  &quot;index&quot;: &#123;</div><div class="line">    &quot;creation_date&quot;: &quot;1512370059209&quot;,</div><div class="line">    &quot;number_of_shards&quot;: &quot;5&quot;,</div><div class="line">    &quot;number_of_replicas&quot;: &quot;1&quot;,</div><div class="line">    &quot;uuid&quot;: &quot;Obppoj9yT4eQg5oq6Zv5IA&quot;,</div><div class="line">    &quot;version&quot;: &#123;</div><div class="line">      &quot;created&quot;: &quot;6000099&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;provided_name&quot;: &quot;vehicles&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>GET business/_search</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GET business/building/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;:&#123;</div><div class="line">        &quot;term&quot;:&#123;&quot;address&quot;:&quot;pen&quot;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">PUT数据后经过分析进行分词写入内存。到达一定数量后持久化写入磁盘。组成segment。且不可变</div><div class="line">tokenization -&gt; filter</div><div class="line">1. Remove Stop Words</div><div class="line">2. Lowercasing</div><div class="line">3. Stemming</div><div class="line">4. Synonyms</div></pre></td></tr></table></figure>
<p> Token | Exists in<br> — | —<br> token   |   1</p>
<p> <img src="https://ficapy.b0.upaiyun.com/capture/elasticsearch_analyzer.jpeg" alt="elasticsearch_analyzer"></p>
</li>
</ol>
<ol>
<li><p>inverted index(8-9)</p>
<p> Data Types for Document Fields</p>
<p> String Fields: text,keyword<br> Numeric Fields: long,integer,short,byte,double,float<br> Date Fields: text,keyword<br> True/False Fields: boolean<br> Binary Fields: binary</p>
<p> - 注意。和教程不一致了。教程使用的5版本，新版本6进行了破坏性升级。以前index/type/documents的概念后续会去掉type。在6里面单个index里面无法存储多个type。故也无法设置多个mapping</p>
<ul>
<li>关闭写入内容时自动生成mappings(dynamic:false/strict)</li>
<li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html">各种analyzer测试</a></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">POST _analyze</div><div class="line">&#123;</div><div class="line">&quot;analyzer&quot;: &quot;simple&quot;,</div><div class="line">&quot;text&quot;: &quot;The 2 QUICK Brown-Foxes jumped over the lazy dog&apos;s bone.&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>search DSL (10-14)</p>
<ul>
<li>Domain Specific Language</li>
<li><p>Query Context &amp; Filter Context</p>
<ol>
<li><p>Query</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">match_all</div><div class="line">&quot;match&quot;: &#123;&quot;name&quot;: &quot;computer&quot;&#125; </div><div class="line">这查询语法简直让人有种生不如死的感觉</div><div class="line">GET /courses/_search</div><div class="line">&#123;</div><div class="line">&quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">    &quot;must&quot;: [&#123;&quot;match&quot;: &#123;&quot;room&quot;: &quot;c8&quot;&#125;&#125;,</div><div class="line">        &#123;&quot;match&quot;: &#123;&quot;name&quot;: &quot;computer&quot;&#125;&#125;]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">must/must_not/should/minimun_should_match</div><div class="line">multi_match/match_phrase /match_phrase_prefix</div><div class="line">range</div></pre></td></tr></table></figure>
</li>
<li><p>Filter</p>
<ul>
<li>不能单独使用</li>
<li>不进行评分</li>
<li>ElasticSearch会对结果进行缓存</li>
<li>可以先常规查询得到评分。再使用filter对结果过滤</li>
</ul>
</li>
<li><p>Aggregation</p>
<ul>
<li>endpoint-&gt;_search/_count</li>
<li>bulk indexing</li>
<li>terms:field类似与group、aggs来聚合、avg、max、min函数(如果需要根据聚合的结果来排序怎么办)</li>
<li>先执行query。后面根据结果进行聚合</li>
<li>stats(min、max、avg、sum)</li>
<li>bucket和metric的概念。range  <ul>
<li>对于group by得到的结果再次使用range(from、to)进行二次分组。分组后可以嵌套使用agg聚合</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>logstash and kibana (15-17)</p>
<ol>
<li><p>logstash</p>
<ul>
<li>input、filter、output(ruby语法)</li>
</ul>
</li>
<li><p>Kibana</p>
<ul>
<li>kibana需要先设置默认index</li>
<li>Visualize新建单个视图、Dashboard组合它们</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是看&lt;a href=&quot;https://www.udemy.com/complete-elasticsearch-masterclass-with-kibana-and-logstash/&quot;&gt;udemy的Elasticsearch入门教程&lt;/a&gt;做的简短笔记&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>influxdb配置文件</title>
    <link href="https://www.zoulei.net/2017/12/01/influxdb_config/"/>
    <id>https://www.zoulei.net/2017/12/01/influxdb_config/</id>
    <published>2017-12-01T14:38:46.000Z</published>
    <updated>2017-12-08T23:59:26.538Z</updated>
    
    <content type="html"><![CDATA[<p>开始一个软件,从读懂它的配置文件开始。以下是读取<a href="https://docs.influxdata.com/influxdb/v1.3/administration/config/">3.1配置文档</a>的笔记<br>总结来说，influxdb的配置文件可配置的地方几乎没有。参数性能调优貌似不存在，其中是否开启，是否记录日志都占据了好多部分。额外需要关注的是data章节有一些关于fsync的设置默认是0，还有默认的max-series-per-database和max-value-per-tag默认都存在限制。暂时不太清楚原理是什么(更新:因为influxdb最大的软肋就在series的数量上。tag的数据都保存在内存。所以有极大的限制。可以看到<a href="https://docs.influxdata.com/influxdb/v1.3/guides/hardware_sizing/#general-hardware-guidelines-for-a-cluster">官方硬件要求</a>,100万的series需要4-6核心CPU,8-32GB内存，iops要求1000+。对比一下influxdb提供的<a href="https://cloud.influxdata.com/plan-picker">云服务</a>，100万的series需要每月1500刀!!!)。当保存大量数据的时候肯定会报错,另外默认的慢查询日志是没有打开的。对于请求。默认没有限制最大的返回内容数。以及限制单个查询响应的时间</p>
<a id="more"></a>
<h1 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h1><ul>
<li>使用<code>influxd config</code>查看默认的配置</li>
<li>使用<code>influxd -config config_path</code>或者<code>INFLUXDB_CONFIG_PATH</code>启动</li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>配置优先级为: 环境变量 &gt; 文件配置 &gt; 默认设置</p>
<h2 id="全局选项"><a href="#全局选项" class="headerlink" title="全局选项"></a>全局选项</h2><ol>
<li>reporting-disabled  发送数据统计给influxdb</li>
<li>bind-address        绑定监听地址(RPC)</li>
<li>GOMAXPROCS          最大进程数</li>
</ol>
<h2 id="meta"><a href="#meta" class="headerlink" title="[meta]"></a>[meta]</h2><ol>
<li>dir   meta数据保存地址(一般设置一个base_dir)</li>
<li>retention-autocreate 自动创建保留策略。默认永久保留</li>
<li>logging-enabled  开启meta日志记录</li>
</ol>
<h2 id="data"><a href="#data" class="headerlink" title="[data]"></a>[data]</h2><ol>
<li>dir  数据保存地址</li>
<li>index-version 决定分片索引保存内存还是磁盘</li>
<li>wal-dir  预写日志保存地址</li>
<li>wal-fsync-delay  预写日志刷新延迟(非ssd磁盘建议0-100ms)</li>
<li>trace-logging-enabled TSM引擎和WAL日志</li>
<li>query-log-enabled   是否记录查询日志</li>
<li>cache-max-memory-size    最大缓存容量,占满会拒绝写入</li>
<li>cache-snapshot-memory-size 缓存快照大小。满后会将内存内容写入到TSM文件</li>
<li>cache-snapshot-write-cold-duration 如果一个分片没有被写入或者删除会被写入到TSM文件的时间</li>
<li>compact-full-write-cold-duration 同上，没有写入或者删除的压缩时间</li>
<li>max-concurrent-compactions  并发压缩进程数</li>
<li>max-series-per-database   每个数据库最大的series数量。超过会500错误。0表示无限制(为什么需要限制呢？)</li>
<li>max-values-per-tag 每个tag索引的值个数(同疑问为什么限制为十万)</li>
</ol>
<h2 id="coordinator"><a href="#coordinator" class="headerlink" title="[coordinator]"></a>[coordinator]</h2><ol>
<li>write-timeout    写入超时时间10秒</li>
<li>max-concurrent-queries  最大并发查询数默认无限制</li>
<li>query-timeout   查询超时时间默认无限制</li>
<li>log-queries-after 慢查询检测。为慢查询则记录日志</li>
<li>max-select-point 最大的points数量。默认无限制</li>
<li>max-select-series  最大的series数量。默认无限制</li>
<li>max-select-buckets   最大的GROUP BY time()数量。默认无限制</li>
</ol>
<h2 id="retention"><a href="#retention" class="headerlink" title="[retention]"></a>[retention]</h2><ol>
<li>enable  设置为false则禁止删除数据</li>
<li>check-interval  检查周期默认三十分钟</li>
</ol>
<h2 id="shard-precreation"><a href="#shard-precreation" class="headerlink" title="[shard-precreation]"></a>[shard-precreation]</h2><ol>
<li>enable 开启数据到达前先创建shard</li>
<li>check-interval  检查周期</li>
<li>advance-period  预创建shard的最大时间</li>
</ol>
<h2 id="admin"><a href="#admin" class="headerlink" title="[admin]"></a>[admin]</h2><p>官方完全废弃，不可用。由xx替代(注:还是用grafana吧)</p>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="[monitor]"></a>[monitor]</h2><p>系统自身监控。默认数据会保存到_internal数据库</p>
<ol>
<li>store-enabled  是否存储监控信息</li>
<li>store-database 保存数据库的名称</li>
<li>store-interval  记录间隔。默认十秒</li>
</ol>
<h2 id="subscriber"><a href="#subscriber" class="headerlink" title="[subscriber]"></a>[subscriber]</h2><p>这个部分是控制Kapacitor如何接收数据。应该没什么用处</p>
<ol>
<li>enabled</li>
<li>http-timeout</li>
<li>insecure-skip-verify</li>
<li>ca-certs</li>
<li>write-concurrency</li>
<li>write-buffer-size</li>
</ol>
<h2 id="http"><a href="#http" class="headerlink" title="[http]"></a>[http]</h2><p>除了RPC调用。就是RESTFUL方式的api读写了</p>
<ol>
<li>enable  是否打开</li>
<li>bind-address 绑定地址</li>
<li>auth-enabled 打开验证</li>
<li>realm  JWT验证相关</li>
<li>log-enabled 记录日志</li>
<li>write-tracing 应该是调试使用。会记录写入的payload</li>
<li>pprof-enabled 开启性能记录</li>
<li>https-enabled  开启https</li>
<li>https-certificate https证书</li>
<li>https-private-key  https私钥</li>
<li>shared-secret  用于JWT的签名。想想单机应该是用不到的</li>
<li>max-row-limit  最大单次可以上传的point，默认无限制</li>
<li>max-connection-limit 最大可连接数，默认无限制</li>
<li>unix-socket-enabled  开启unix域连接</li>
<li>bind-socket  绑定socket域</li>
<li>max-body-size  最大body长度,默认25MB，超过大小返回http413请求实体过大错误</li>
</ol>
<h2 id="graphite"><a href="#graphite" class="headerlink" title="[[graphite]]"></a>[[graphite]]</h2><p>(service plugin)设置一个或多个graphite数据监听器</p>
<ol>
<li>enabled 启用graphite</li>
<li>database   数据库名称</li>
<li>retention-policy 保留策略</li>
<li>bind-address  绑定地址</li>
<li>protocol     协议tcp或udp</li>
<li>consistency-level   一致性级别</li>
<li>batch-size</li>
<li>batch-pending</li>
<li>batch-timeout</li>
<li>udp-read-buffer</li>
<li>separator</li>
</ol>
<h2 id="collectd"><a href="#collectd" class="headerlink" title="[[collectd]]"></a>[[collectd]]</h2><p>(service plugin)同上，设置监听collectd数据</p>
<ol>
<li>enabled</li>
<li>bind-address</li>
<li>database</li>
<li>retention-policy</li>
<li>typesdb</li>
<li>security-level</li>
<li>auth-file</li>
<li>batch-size</li>
<li>batch-pending</li>
<li>batch-timeout</li>
<li>read-buffer</li>
</ol>
<h2 id="opentsdb"><a href="#opentsdb" class="headerlink" title="[[opentsdb]]"></a>[[opentsdb]]</h2><p>(service plugin)同上，设置监听opentsdb数据</p>
<ol>
<li>enabled</li>
<li>bind-address</li>
<li>database</li>
<li>retention-policy</li>
<li>consistency-level</li>
<li>tls-enabled</li>
<li>certificate</li>
<li>log-point-errors</li>
<li>batch-size</li>
<li>batch-pending</li>
<li>batch-timeout</li>
</ol>
<h2 id="udp"><a href="#udp" class="headerlink" title="[[udp]]"></a>[[udp]]</h2><p>(service plugin)除了RPC、HTTP、附带UDP</p>
<ol>
<li>enabled</li>
<li>bind-address</li>
<li>database</li>
<li>retention-policy</li>
<li>batch-size</li>
<li>batch-pending</li>
<li>batch-timeout</li>
<li>read-buffer</li>
<li>precision</li>
</ol>
<h1 id="continuous-queries"><a href="#continuous-queries" class="headerlink" title="[continuous_queries]"></a>[continuous_queries]</h1><p>持续查询</p>
<ol>
<li>enabled  开启</li>
<li>query-stats-enabled  默认关闭，将执行统计写入到默认的监控数据库  </li>
<li>log-enabled  记录日志</li>
<li>run-interval  查找执行间隔</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始一个软件,从读懂它的配置文件开始。以下是读取&lt;a href=&quot;https://docs.influxdata.com/influxdb/v1.3/administration/config/&quot;&gt;3.1配置文档&lt;/a&gt;的笔记&lt;br&gt;总结来说，influxdb的配置文件可配置的地方几乎没有。参数性能调优貌似不存在，其中是否开启，是否记录日志都占据了好多部分。额外需要关注的是data章节有一些关于fsync的设置默认是0，还有默认的max-series-per-database和max-value-per-tag默认都存在限制。暂时不太清楚原理是什么(更新:因为influxdb最大的软肋就在series的数量上。tag的数据都保存在内存。所以有极大的限制。可以看到&lt;a href=&quot;https://docs.influxdata.com/influxdb/v1.3/guides/hardware_sizing/#general-hardware-guidelines-for-a-cluster&quot;&gt;官方硬件要求&lt;/a&gt;,100万的series需要4-6核心CPU,8-32GB内存，iops要求1000+。对比一下influxdb提供的&lt;a href=&quot;https://cloud.influxdata.com/plan-picker&quot;&gt;云服务&lt;/a&gt;，100万的series需要每月1500刀!!!)。当保存大量数据的时候肯定会报错,另外默认的慢查询日志是没有打开的。对于请求。默认没有限制最大的返回内容数。以及限制单个查询响应的时间&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://www.zoulei.net/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>ansible笔记</title>
    <link href="https://www.zoulei.net/2017/11/28/ansible-note/"/>
    <id>https://www.zoulei.net/2017/11/28/ansible-note/</id>
    <published>2017-11-28T03:28:42.000Z</published>
    <updated>2017-11-28T03:57:18.299Z</updated>
    
    <content type="html"><![CDATA[<p>以下为观看<a href="https://www.youtube.com/playlist?list=PL7hgvWUGJtUsT74AXZgVhr37riphKjzkD">Ansible-Configuration Management</a>的笔记。不适合初学者查看。可以作为温习使用</p>
<a id="more"></a>
<h2 id="Ansible总结"><a href="#Ansible总结" class="headerlink" title="Ansible总结"></a>Ansible总结</h2><ol>
<li>单个Module是基石，将机器分组，严重依靠变量</li>
<li>task组成任务</li>
<li>全部的task组成playbooks.将所有的机器定义到一个确定的状态</li>
<li>使用role对playbooks进行拆分.role有约定好的目录结构</li>
<li>ansible galaxy来分享role.使用时完全使用变量来覆盖原有变量,严重依赖社区水平(比如国情安装许多软件都需要使用镜像,而外国作者编写role并不会考虑这些)</li>
</ol>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>change management(定义一个特定的系统状态，change_event用于回调)</li>
<li>Provisioning(role。服务划分。比如一个webserver会依次执行某些步骤)</li>
<li>Automation(playbook同时设置上千台)</li>
<li>Orchestration(编排多个tasks让其协调coordinates执行。多个系统配置。解决task间的依赖性)</li>
</ul>
<h2 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h2><ul>
<li>No agents</li>
<li>No database</li>
<li>No residual software</li>
<li>No complex upgrades</li>
<li>题外话。使用yaml文件描述而无法使用编程控制。我认为迟早药丸。只不过目前还没找到更好的替代品</li>
<li>ssh/root/encrypted vault(共享到github仓库成标配了,几乎所有的软件都是这个套路)</li>
<li>easy to extend:http call、shell commands(挺有用)、scripts(暂时不太懂，感觉是扩充model)、Ansible-Galaxy</li>
</ul>
<h2 id="Ansible-架构"><a href="#Ansible-架构" class="headerlink" title="Ansible 架构"></a>Ansible 架构</h2><p><img src="https://ficapy.b0.upaiyun.com/capture/ansible_arch.jpg" alt="Ansible 架构"></p>
<p>Variables:</p>
<ul>
<li>Host Variables: 在资产中给host或者group设置的变量</li>
<li>Facts: ansible进行的第一步就是setup。获取机器的基础信息。比如内网ip</li>
<li>Dynamic Variables: 收集tasks数据或者运行时获取？比如将上一个task的结果作为参数</li>
</ul>
<p>执行过程中将model发送到远方机器临时目录执行。返回json结果。然后删除临时目录内容</p>
<h2 id="学习环境搭建-视频19"><a href="#学习环境搭建-视频19" class="headerlink" title="学习环境搭建(视频19)"></a>学习环境搭建(视频19)</h2><ul>
<li>Vagrant、Virtualbox、Ansible</li>
<li>Remote、Local(基本不使用Local模式。仅有一次无法远程ssh我用过)</li>
</ul>
<h2 id="Inventory-Features"><a href="#Inventory-Features" class="headerlink" title="Inventory Features"></a>Inventory Features</h2><ul>
<li>Behavioral Parameters</li>
<li>Groups</li>
<li>Groups of Groups</li>
<li>Assign Variables</li>
<li>Scaling out using multiple files</li>
<li>Static/Dynamic<br>分组、组合、赋予变量(和python里面变量作用域LEGB差不多)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[db]</div><div class="line">db1.company.com ansible_ssh_user=aarom xx=xx</div><div class="line">db2.company.com</div><div class="line"></div><div class="line">[datacenter-west:children]</div><div class="line">db</div><div class="line"></div><div class="line">[datacenter-west:vars]</div><div class="line">ansible_ssh_user=ansible_user</div><div class="line">xx=xx</div></pre></td></tr></table></figure>
<p>分组的套路(group_vars、host_vars下面的文件必须和inventory相对应)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">├── group_vars   # 全局</div><div class="line">│   ├── all</div><div class="line">│   ├── db</div><div class="line">├── host_vars   # 单个host</div><div class="line">│   └── web1</div><div class="line">├── inventory_prod</div><div class="line">├── inventory_test</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># variable file example</div><div class="line">---     # 标记</div><div class="line"># key-value pairs</div><div class="line">ntp:  ntp-west.company.com</div><div class="line">syslog: logger-west.company.com</div></pre></td></tr></table></figure>
<h2 id="Ad-Hoc-临时使用"><a href="#Ad-Hoc-临时使用" class="headerlink" title="Ad-Hoc 临时使用"></a>Ad-Hoc 临时使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ansible -m ping all</div><div class="line">ansible -m shell -a &quot;hostname&quot; all</div><div class="line">ansible -m shell -a &quot;getent passwd | grep deploy&quot; all</div><div class="line">ansible -b -K -m shell -a &quot;whoami&quot; all -vvv -T 30 -c paramiko</div></pre></td></tr></table></figure>
<p>参数注解</p>
<ul>
<li>-b become变成某用户一般是root</li>
<li>-K 配合-b输入密码</li>
<li>-m 使用某个模块</li>
<li>-vvv 和ssh -vvv一样查看详细日志</li>
<li>-T timeout 设置超时</li>
<li>-c 选择连接的模块. 3.5使用默认值搞sudo可能会有问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">使用变量(估计使用janja2模板引擎是会python的人使用ansible的唯一优势了-_-)</div><div class="line">ansible webservers -i inventory_prod -m user -a &quot;name=&#123;&#123;username&#125;&#125; password=1234 -b&quot;</div></pre></td></tr></table></figure>
<p>ansible-doc可以查看文档  </p>
<h2 id="Host-Group-Target-Patterns"><a href="#Host-Group-Target-Patterns" class="headerlink" title="Host/Group Target Patterns"></a>Host/Group Target Patterns</h2><ul>
<li>OR (group1:group2)</li>
<li>NOT (!group2)</li>
<li>Wildcard (web*.ex.com)</li>
<li>Regex (~web[0-9]+)</li>
<li>Complex Patterns AND (group1:&amp;group2) # 求交集、中间出现一个:有点奇葩</li>
</ul>
<h2 id="Anaible-Playbooks"><a href="#Anaible-Playbooks" class="headerlink" title="Anaible Playbooks"></a>Anaible Playbooks</h2><ul>
<li>组合ansible modules组成play,多个play组成playbooks</li>
<li>logic controls &amp; error handle</li>
<li>include 合并多个</li>
<li>Grab output of task for another task(register)</li>
<li>Debug Module(debug/msg or var)</li>
<li>Promptins for input(类似与input,vars_prompt)</li>
<li>Playbook Handlers(notify)<ol>
<li>Tasks with asynchronous execution</li>
<li>Only runs tasks when notified</li>
<li>Tasks Only notify when state=changed</li>
<li>Does not run until all playbook tasks have executed</li>
<li>Most common for restarting services to load changes(if changes are made)</li>
</ol>
</li>
<li>Contitional Clause(when: ansible_os_family == “Debian”,搭配register使用)</li>
<li>Jinja2 Template Module(template)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: webservres</div><div class="line">  sudo: yes</div><div class="line"></div><div class="line">  vars:</div><div class="line">    http_port: 80</div><div class="line">    doc_dir: /ansible/</div><div class="line">    doc_root: /var/www/html/ansible/</div><div class="line">    max_clients: 5</div><div class="line">  </div><div class="line">  vars_prompt:</div><div class="line">    - name: username</div><div class="line">      prompt: what is your name?</div><div class="line"></div><div class="line">  tasks:</div><div class="line">  - name: Ensure that Apache is installed</div><div class="line">    yum: name=httpd state=present</div><div class="line">    when: ansible_os_family == &quot;RedHat&quot;</div><div class="line"></div><div class="line">  - name: Start Apache Services</div><div class="line">    service: name=httpd enabled=yes state=started</div><div class="line"></div><div class="line">  - name: Deploy configuration File</div><div class="line">    template: src=templates/httpd.j2 dest=/etc/httpd/conf/httpd.conf</div><div class="line">    notify:</div><div class="line">      - Restart Apache</div><div class="line">    </div><div class="line">  - name: Copy Site Files</div><div class="line">      template: src=templates/index.j2 dest=&#123;&#123; doc_root &#125;&#125;/index.html</div><div class="line"></div><div class="line">  handlers:</div><div class="line">    - name: Restart Apache</div><div class="line">      service: name=httpd state=restarted</div><div class="line"></div><div class="line">- hosts: dbservers</div><div class="line">  sudo: yes</div><div class="line"></div><div class="line">  tasks:</div><div class="line">  - name: Ensure MySQL is installed</div><div class="line">    yum: name=mysql-server state=present</div><div class="line">  </div><div class="line">  - name: Start MySQL</div><div class="line">    service: name=mysqld state=started</div><div class="line"></div><div class="line">- hosts: webservers:dbservers</div><div class="line">  sudo: yes</div><div class="line"></div><div class="line">  tasks:</div><div class="line">  - name: Stop IPTABLES NOW!!!</div><div class="line">    service: name=iptables state=stopped</div></pre></td></tr></table></figure>
<p>ansible-playbook -i inventory web_db.yaml</p>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><ul>
<li>Predefined directory structure</li>
<li>defaults、files、handlers、meta、tasks、templates、vars</li>
<li>main.yml,使用include.vars除外</li>
<li>use tags to define categories within your playbooks</li>
<li><p>Adding Roles to Playbook</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    ---</div><div class="line">    - hosts: code-dev</div><div class="line">    roles:</div><div class="line">        - server-common</div><div class="line">        - builders</div><div class="line">    gather_facts: no</div><div class="line">    tasks:</div><div class="line">        # Build your extra tasks here like</div><div class="line">    ``` </div><div class="line">- Pre-tasks and Post-tasks(executes plays before or after roles)</div><div class="line">- ```ansible-playbook site.yml -tags &quot;web&quot; -limit atlanta</div></pre></td></tr></table></figure>
</li>
<li><p>ansible galaxy(ansible-galaxy install username.role)</p>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><a href="https://github.com/enginyoyen/ansible-best-practises">ansible-best-practises</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下为观看&lt;a href=&quot;https://www.youtube.com/playlist?list=PL7hgvWUGJtUsT74AXZgVhr37riphKjzkD&quot;&gt;Ansible-Configuration Management&lt;/a&gt;的笔记。不适合初学者查看。可以作为温习使用&lt;/p&gt;
    
    </summary>
    
      <category term="devops" scheme="https://www.zoulei.net/categories/devops/"/>
    
    
  </entry>
  
  <entry>
    <title>内网无网络环境初始化线上环境</title>
    <link href="https://www.zoulei.net/2017/08/13/when_no_network_setup_environment/"/>
    <id>https://www.zoulei.net/2017/08/13/when_no_network_setup_environment/</id>
    <published>2017-08-13T09:18:36.000Z</published>
    <updated>2017-08-13T09:46:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>遇到有人反映可能是内网环境。无法访问外部网络。安装初始化环境的时候好像颇为不便。其实只要能ssh上去。这一切都不是问题。就是各种转发，以下以内网使用pip安装第三方依赖包为例说明该如何操作</p>
<h2 id="1-本机开启一个临时的http代理"><a href="#1-本机开启一个临时的http代理" class="headerlink" title="1.本机开启一个临时的http代理"></a>1.本机开启一个临时的http代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install mitmproxy           # 安装</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mitmproxy -p 8899 --ignore .+               #  使用</div></pre></td></tr></table></figure>
<p>mitmproxy是一个python编写的http/https中间人框架。这里我们单独的使用它的http proxy功能。<br>参数p当然是port端口的意思了。监听8899端口<br>加上ignore是因为中间人https连接需要客户端安装信任证书才可以。此处我们只是单纯的使用一下proxy不需要中间人。所以所有流量使用HTTP Connection隧道方式就达成目的了。使用正则表达式<code>.+</code>忽略所有域名。至于为什么使用http不是用socks。因为http使用更广泛</p>
<h2 id="2-ssh使用远程端口转发-参考ssh端口映射"><a href="#2-ssh使用远程端口转发-参考ssh端口映射" class="headerlink" title="2.ssh使用远程端口转发(参考ssh端口映射)"></a>2.ssh使用远程端口转发(参考<a href="https://ficapy.com/2017/03/12/ssh-port-forward/">ssh端口映射</a>)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R 8899:localhost:8899 remote_server</div></pre></td></tr></table></figure>
<p>将远程主机上的8899端口映射到本机的8899端口</p>
<h2 id="3-远程主机使用本地的http代理进行环境初始化"><a href="#3-远程主机使用本地的http代理进行环境初始化" class="headerlink" title="3.远程主机使用本地的http代理进行环境初始化"></a>3.远程主机使用本地的http代理进行环境初始化</h2><p>可以使用如下命令进行测验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -x http://localhost:8899 ip.cn</div></pre></td></tr></table></figure>
<p>比如使用pypi安装tornado执行如下命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --proxy http://localhost:8899 tornado</div></pre></td></tr></table></figure>
<p>思路是这样。其它同理~~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到有人反映可能是内网环境。无法访问外部网络。安装初始化环境的时候好像颇为不便。其实只要能ssh上去。这一切都不是问题。就是各种转发，以下以内网使用pip安装第三方依赖包为例说明该如何操作&lt;/p&gt;
&lt;h2 id=&quot;1-本机开启一个临时的http代理&quot;&gt;&lt;a href=&quot;#1
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>开发环境中数据库快速回滚</title>
    <link href="https://www.zoulei.net/2017/07/15/develop_quick_restore_postgresql_database/"/>
    <id>https://www.zoulei.net/2017/07/15/develop_quick_restore_postgresql_database/</id>
    <published>2017-07-15T05:24:19.000Z</published>
    <updated>2017-07-15T07:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>开发中总会遇到一些测试需要回滚数据库。常规的单元测试的做法是在单个会话中不真正的写入到数据库。而是测试完成后进行数据库回滚。大多数情况下这样都是满足要求的。只是有的时候需要数据库真正的写入到数据库。此时rollback回滚就有些乏力了。此时给数据库做一个备份，测试完成后回滚是一种不错的主意。Postgresql数据库的常规备份我们会使用pg_dump和pg_restore进行导出和恢复。此时如何快速的进行这个操作是我们关注的话题</p>
<p>很幸运。很顺利的搜到了答案。6年前有人在stackexchange上提问同样的问题。得到了一些有用的回复。大概有这些</p>
<ul>
<li>使用文件系统级快照LVM</li>
<li>使用CREATE  DATABASE … TEMPLATE语法</li>
<li>将数据库放在虚拟机里面。使用虚拟机快照</li>
</ul>
<p>其中最有效的方案是二。因为LVM在个人笔记本上难以实施。虚拟机恢复时间较慢。依据方案二于是乎有人写了一个工具 <a href="https://github.com/fastmonkeys/stellar">stellar</a>。粗略读了一下源码。其具体原理大概如下图<br><img src="https://ficapy.b0.upaiyun.com/blogimg/backup_and_restore_flow.jpg" alt="backup_and_restore_flow"></p>
<p>备份的时候使用create database … template创建2个备份。恢复的时候删掉原有的数据库。将一个备份重命名为原有的名称。另外的一个备份再生成一个备份就完成了。另外删除新建数据库操作均会关闭所有已连接的数据库会话。</p>
<p>因为类似文件系统级快照，所以方法极快。我本机2G的数据库文件，创建一个快照大概十秒钟左右，恢复就更快了。当然缺点也是有的，你每创建一个快照都会新增2个一样大小的副本，相当的占据硬盘空间，可是为了速度这点缺陷也就微不足道了┑(￣Д ￣)┍</p>
<p>另外一个小缺点。因为它定位于测试环境下的数据库备份恢复。所以只连接一台机器。比如你一个数据库在机器A,一个数据库在机器B.赛高~~，那你只能在2个目录下使用2个配置文件来完成了。如果同一个机器上的多个数据库是可以直接备份的。再就是此工具比较专注于Postgresql。对于Mysql就不那么友好了。或许是Mysql的备份方案不一样</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><code>stellar init</code> 按照提示输入本机数据库访问路径生成配置文件</li>
<li><code>stellar snapshot</code> 生成一个快照</li>
<li><code>stellar restore &lt;snap1&gt;</code> 恢复</li>
<li>其他请看 <code>stellar --help</code></li>
</ol>
<p>( ⊙ o ⊙ )啊！ 多么爽快，世界真美妙</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://dba.stackexchange.com/questions/3394/is-it-possible-to-quickly-create-restore-database-snapshots-with-postgresql">Is it possible to quickly create/restore database snapshots with PostgreSQL?</a><br><a href="https://github.com/fastmonkeys/stellar">github stellar</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中总会遇到一些测试需要回滚数据库。常规的单元测试的做法是在单个会话中不真正的写入到数据库。而是测试完成后进行数据库回滚。大多数情况下这样都是满足要求的。只是有的时候需要数据库真正的写入到数据库。此时rollback回滚就有些乏力了。此时给数据库做一个备份，测试完成后回滚
    
    </summary>
    
      <category term="伪技术" scheme="https://www.zoulei.net/categories/%E4%BC%AA%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker CD初探-Drone</title>
    <link href="https://www.zoulei.net/2017/07/05/drone/"/>
    <id>https://www.zoulei.net/2017/07/05/drone/</id>
    <published>2017-07-05T13:51:26.000Z</published>
    <updated>2017-07-05T16:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有个小需求，我们公司写文档是通过<a href="https://github.com/lord/slate">slate</a>来的。每一次文档编写完成之后都需要执行<code>bundle exec middleman build --clean</code>生成静态文件。然后再使用rsync来进行上传操作。虽然只有2步。但是做的次数多了难免也让人觉得厌烦。萌生了自动化处理的想法。比较粗暴的方式有。每隔几分钟去检测一次git版本库是否有更新(以前本人真这样实现过)，自己写个小web程序。设置webhook。接收到webhook再拉取进行操作(我也实现过，目前一切运行良好)。现在尝试下使用可持续集成的套路去实现。</p>
<a id="more"></a>
<p>说一下第三种方案相对前两种方案的特点。</p>
<ul>
<li>集中化管理。第一二种方案都需要将脚本放在对应的应用机器上面。第三种不需要，它集中化了。所有的webhook都在可持续集成平台处理。由平台再来操控应用。而且每一次触发操作都有详尽的日志。集中在一起比较容易看出哪里出了什么问题</li>
<li>不需要在每一台应用机处理webhook(处理意味着每个应用机都需要绑定一个域名)，可能和上面的集中化管理的优点是一个意思吧</li>
<li>对于一个良好的架构。可持续集成平台比零散的脚本无疑更合适</li>
<li>算是一个缺点。单独写脚本独立处理webhook相对可持续集成更容易</li>
</ul>
<h3 id="Drone配置"><a href="#Drone配置" class="headerlink" title="Drone配置"></a>Drone配置</h3><p>docker-compose我都不大用了，直接用docker stack deploy替代。后者相对前者实际没有什么区别。或者说前者是因为docker网络配置欠发达的产物。docker-compose适合单机部署，docker-swarm适合多主机。开启docker-swarm只需要docker swarm init大概就可以了，更详细的知识请查看官方文档</p>
<p>drone.yml 文件大概如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">version: &apos;3&apos;</div><div class="line"></div><div class="line">services:</div><div class="line">  drone-server:</div><div class="line">    image: drone/drone:0.7</div><div class="line">    ports:</div><div class="line">      - 82:8000</div><div class="line">    volumes:</div><div class="line">      - /data/github_drone:/var/lib/drone/</div><div class="line">    environment:</div><div class="line">      - DRONE_OPEN=false</div><div class="line">      - DRONE_ADMIN=ficapy</div><div class="line">      - DRONE_GITLAB=true</div><div class="line">      - DRONE_GITHUB_CLIENT=xxxxxxxxx</div><div class="line">      - DRONE_GITHUB_SECRET=xxxxxxxxxx</div><div class="line">      - DRONE_SECRET=xxxpwdxxx</div><div class="line"></div><div class="line">  drone-agent:</div><div class="line">    image: drone/drone:0.7</div><div class="line">    command: agent</div><div class="line">    depends_on:</div><div class="line">      - drone-server</div><div class="line">    volumes:</div><div class="line">      - /var/run/docker.sock:/var/run/docker.sock</div><div class="line">    environment:</div><div class="line">      - DRONE_SERVER=ws://drone-server:8000/ws/broker</div><div class="line">      - DRONE_SECRET=xxxpwdxxx</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>然后执行<code>docker stack deploy --compose-file=drone.yml drone</code>，整个程序就运行起来了。此处是监听81端口。从配置文件中也可以猜一个大概。了解下drone的流程。service主要用来响应浏览器端的请求。接收到请求后使用websocket和agent通信用来下发任务获取结果。agent通过/var/run/docker.sock来和docker daemon进行通信。执行创建容器。执行命令等一系列过程。</p>
<p>有几点需要注意的</p>
<ul>
<li>最好指定管理员用户DRONE_ADMIN，因为有些操作需要admin权限</li>
<li>DRONE_OPEN设置为true的时候所有的用户都能授权后使用你的Drone进行集成测试。这往往是你不愿意的，个人的诉求往往是私有的</li>
<li>github和gitlab在一个drone不能同时使用，所以我部署了两套，使用了不同的域名</li>
<li>起码了解OAuth流程和webhook的过程，才能更好的理解整套流程</li>
<li>其他事宜可以查看Drone的<a href="http://docs.drone.io/installation/">安装文档</a></li>
</ul>
<p>之所以监听81端口，是因为我使用的Caddy当做前置web服务器。配置如下Caddyfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">drone.ficapy.com &#123;</div><div class="line">    proxy / dockerhost:81 &#123;</div><div class="line">        websocket</div><div class="line">        transparent</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的docker-compose文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">version: &quot;3&quot;</div><div class="line"></div><div class="line">services:</div><div class="line">  Caddy:</div><div class="line">    image: &quot;abiosoft/caddy&quot;</div><div class="line">    volumes:</div><div class="line">      - /root/caddy/Caddyfile:/etc/Caddyfile</div><div class="line">      - /root/.caddy:/root/.caddy</div><div class="line">    ports:</div><div class="line">      - &quot;80:80&quot;</div><div class="line">      - &quot;443:443&quot;</div><div class="line">    extra_hosts:</div><div class="line">      - &quot;dockerhost:$&#123;dockerhost&#125;&quot;</div></pre></td></tr></table></figure>
<p>此处使用了环境变量dockerhost，我将它写入了zshrc配置文件中<code>export dockerhost=&quot;172.17.0.1&quot;</code>,不难看出只是为了转发请求, 和drone一样。执行<code>docker stack deploy --compose-file=caddy_compose.yml caddy</code>启动</p>
<h3 id="持续集成部署"><a href="#持续集成部署" class="headerlink" title="持续集成部署"></a>持续集成部署</h3><p>当使用Drone，并授权之后。Drone会自动给你的项目加上webhook地址。我们在项目根目录放置.drone.yml文件后会使用docker自动构建</p>
<p>实现本文开头说的需求.drone.yml文件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">pipeline:</div><div class="line">  build:</div><div class="line">    image: ruby:2.3</div><div class="line">    commands:</div><div class="line">      - bundle config mirror.https://rubygems.org https://gems.ruby-china.org</div><div class="line">      - bundle install</div><div class="line">      - apt-get update &amp;&amp; apt-get install nodejs rsync -y &amp;&amp; bundle exec middleman build --clean</div><div class="line">      - rsync -r --rsh=&apos;ssh -o LogLevel=ERROR -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -i /data/id_rsa -p 22&apos; build/* user@host:~/docs --progress --delete</div><div class="line">    volumes:</div><div class="line">      - /data:/data</div><div class="line">    when:</div><div class="line">      branch: master</div></pre></td></tr></table></figure></p>
<p>在使用之前。我现在/data目录使用ssh-agent生成了密匙对。在目标主机上放上公钥，让我们能够ssh连接远端主机。然后容器创建的时候将密匙挂载到容器目录(此处需要管理员权限将项目设置为可信)。然后就顺理成章了。搭建环境，生成静态文件，rsync同步就完成了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有个小需求，我们公司写文档是通过&lt;a href=&quot;https://github.com/lord/slate&quot;&gt;slate&lt;/a&gt;来的。每一次文档编写完成之后都需要执行&lt;code&gt;bundle exec middleman build --clean&lt;/code&gt;生成静态文件。然后再使用rsync来进行上传操作。虽然只有2步。但是做的次数多了难免也让人觉得厌烦。萌生了自动化处理的想法。比较粗暴的方式有。每隔几分钟去检测一次git版本库是否有更新(以前本人真这样实现过)，自己写个小web程序。设置webhook。接收到webhook再拉取进行操作(我也实现过，目前一切运行良好)。现在尝试下使用可持续集成的套路去实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://www.zoulei.net/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>理解metaclass</title>
    <link href="https://www.zoulei.net/2017/03/24/python_metaclass/"/>
    <id>https://www.zoulei.net/2017/03/24/python_metaclass/</id>
    <published>2017-03-24T01:34:48.000Z</published>
    <updated>2017-05-31T08:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>metaclass一直被归类为比较高深的内容，写代码也很少会使用到metaclass。然而如果你看某些项目的源代码，还是会被绕到metaclass里面去。花一些时间理解下metaclass很有用的，因为它真的能把一条线串起来，环环相扣，所以有扎实的基础是掌握metaclass的前提，本文代码基于python3.5</p>
<a id="more"></a>
<p>你只需要理解以下2点</p>
<ol>
<li>metaclass和<code>__new__</code>、<code>__init__</code>并没有非常非常深的关系</li>
<li>type(name, bases, dict)生成了一个object类，了解三个参数分别指代了什么</li>
</ol>
<p>了解python中有这样一条关系链type-&gt;object-&gt;instance,通常我们写类默认会继承自object。从关系链就能知道type能够生成object。代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></div><div class="line">        attrs.pop(<span class="string">'e'</span>)</div><div class="line">        print(<span class="string">'1'</span>, cls, name, bases, attrs)</div><div class="line">        cls.a = <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, attrs)</div><div class="line"></div><div class="line">    <span class="comment"># def __call__(self, *args, **kwargs):</span></div><div class="line">    <span class="comment">#     print('3')</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attrs)</span>:</span></div><div class="line">        self.b = <span class="number">2</span></div><div class="line">        print(<span class="string">'2'</span>, self, name, bases, attrs)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(metaclass=A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line">        print(<span class="string">'4'</span>, args, kwargs)</div><div class="line">        cls.c = <span class="number">4</span></div><div class="line">        <span class="keyword">return</span> super().__new__(cls)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">e</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        print(<span class="string">'5'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d)</span>:</span></div><div class="line">        self.d = d</div><div class="line">        print(<span class="string">'6'</span>)</div><div class="line"></div><div class="line"></div><div class="line">b = B(<span class="number">6</span>)</div><div class="line">print(hasattr(b, <span class="string">'a'</span>))</div><div class="line">print(b.b)</div><div class="line">print(b.c)</div><div class="line">print(b.d)</div><div class="line">print(hasattr(b, <span class="string">'e'</span>))</div></pre></td></tr></table></figure>
<p>可以尝试注释掉B(12)，A依旧会被打印，观察args和kwargs的输出。对比A和B的不同，你会发现metaclass的用处，<strong>使用metaclass的时候，B的所有属性会被当做参数传递给A</strong>，那么我们能够将这些传过来的参数预处理然后挂在到类的属性上面返回。以供后续B使用。目前在我遇到的web开发中体现的最常见的就是ORM和表单验证。</p>
<p>我们知道<code>__new__</code>创建一个对象。<code>__init__</code>对创建后的对象进行赋值等初始化操作。他们的传参args和kwargs是没有区别的。但是在<code>__new__</code>阶段，能够对attrs进行修改从而hook对象的创建流程，除此之外感觉只能用new不能用init的场景是很少的。目前看到的例子记得的可能只有用new实现单例。对于内置不可变对象比如int用new变更初始化逻辑</p>
<p>最后例举一个ORM的例子(见参考)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, column_type)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.column_type = column_type</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringField</span><span class="params">(Field)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        super(StringField, self).__init__(name, <span class="string">'vachar(100)'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMetaclass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></div><div class="line">        <span class="keyword">if</span> name != <span class="string">'Model'</span>:</div><div class="line">            mappings = &#123;k: v.name <span class="keyword">for</span> k, v <span class="keyword">in</span> attrs.items() <span class="keyword">if</span> isinstance(v, Field)&#125;</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> mappings.keys():</div><div class="line">                attrs.pop(k)</div><div class="line">            attrs[<span class="string">'__mappings__'</span>] = mappings</div><div class="line">            attrs[<span class="string">'__table__'</span>] = name</div><div class="line"></div><div class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(dict, metaclass=ModelMetaclass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></div><div class="line">        super().__init__(**kwargs)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self[key]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">r"'Model' object has no attribute &#123;key&#125;"</span>.format(key=key))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self[key] = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></div><div class="line">        fields, params, args = [], [], []</div><div class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__mappings__.items():</div><div class="line">            fields.append(v)</div><div class="line">            params.append(<span class="string">'?'</span>)</div><div class="line">            args.append(getattr(self, k, <span class="keyword">None</span>))</div><div class="line">        sql = <span class="string">'insert into &#123;table_name&#125; (&#123;fields&#125;) values (&#123;values&#125;)'</span>.format(table_name=self.__table__,</div><div class="line">                                                                             fields=<span class="string">','</span>.join(fields),</div><div class="line">                                                                             values=<span class="string">','</span>.join(params))</div><div class="line">        print(<span class="string">'SQL: &#123;sql&#125;'</span>.format(sql=sql))</div><div class="line">        print(<span class="string">'ARGS: &#123;args&#125;'</span>.format(args=args))</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span><span class="params">(Model)</span>:</span></div><div class="line">    user_name = StringField(<span class="string">'username'</span>)</div><div class="line">    email = StringField(<span class="string">'email'</span>)</div><div class="line">    password = StringField(<span class="string">'password'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    user = UserModel(user_id=<span class="number">123</span>, user_name=<span class="string">'hhh'</span>, email=<span class="string">'a@a.a'</span>, password=<span class="string">'asdfa'</span>, x=<span class="string">'y'</span>)</div><div class="line">    user.save()</div><div class="line">    </div></pre></td></tr></table></figure>    </p>
<p>下篇会分析metaclass在WTForms中的应用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/">Understanding Python metaclasses 更详细的介绍</a><br><a href="http://www.jianshu.com/p/9dfa40bf2a62">python实现ORM</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;metaclass一直被归类为比较高深的内容，写代码也很少会使用到metaclass。然而如果你看某些项目的源代码，还是会被绕到metaclass里面去。花一些时间理解下metaclass很有用的，因为它真的能把一条线串起来，环环相扣，所以有扎实的基础是掌握metaclass的前提，本文代码基于python3.5&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>tornado表单验证</title>
    <link href="https://www.zoulei.net/2017/03/23/tornado_wtforms/"/>
    <id>https://www.zoulei.net/2017/03/23/tornado_wtforms/</id>
    <published>2017-03-23T12:17:29.000Z</published>
    <updated>2017-03-23T12:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作中看到有一些不好的代码，想了个办法优化了一下，于是有了这篇博文。本文主要讲tornado的表单验证，使用的是wtforms。本文最终达到的效果是使用self.xx获取post传递过来的值。</p>
<a id="more"></a>
<p>首先是将wtforms嵌入tornado。做法可以参考<a href="https://github.com/truemped/tornadotools/blob/master/tornadotools/forms.py">https://github.com/truemped/tornadotools/blob/master/tornadotools/forms.py</a>，我的做法类似，可以看最下面的代码。这样继承一下就能够使用wtforms的表单验证了。能够使用的结果是很多人写这样的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.xx1 = self.form.xx1.data</div><div class="line">self.xx2 = self.form.xx2.data</div><div class="line">self.xx3 = self.form.xx3.data</div><div class="line">:</div><div class="line">:</div></pre></td></tr></table></figure>
<p>然后这样写了20行(不黑，项目里真有这样的)。写的人也确实是很认真啊！，改进的方法很简单。调用self.xx1的时候自动取值self.form.xx1.data。能做成这样的方法挺多。很多时候会导致self.xxx使用IDE无法补全。我个人认为好的代码肯定能够方便的补全和提示，毕竟这样能实打实的提升码代码的心情，试想一下你要输入20个单词，很可能一不小心就输入错误了。改进的方法就是使用<code>__getattribute__</code>,配合类继承，兼顾自动补全也不用跑去写self.form.xxx.data了</p>
<ol>
<li><code>__getattr__</code>，当属性不存在的时候会调用</li>
<li><code>__getattribute__</code>,无论属性是否存在都会被调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">import tornado.ioloop</div><div class="line">import tornado.web</div><div class="line"></div><div class="line">from wtforms import validators, fields</div><div class="line">from wtforms import Form</div><div class="line">from wtforms.fields.core import UnboundField</div><div class="line"></div><div class="line"></div><div class="line">class MultiDict(dict):</div><div class="line">    def getlist(self, key):</div><div class="line">        return self[key]</div><div class="line"></div><div class="line">    def setlist(self, key, value):</div><div class="line">        self[key] = value</div><div class="line"></div><div class="line"></div><div class="line">class BaseForm(Form):</div><div class="line">    def __init__(self, handler=None, obj=None, prefix=&apos;&apos;, **kwargs):</div><div class="line">        if handler is None:</div><div class="line">            return</div><div class="line">        formdata = MultiDict()</div><div class="line">        if handler.request.method == &apos;POST&apos;:</div><div class="line">            for name in handler.request.arguments.keys():</div><div class="line">                formdata.setlist(name, handler.get_arguments(name))</div><div class="line">        else:</div><div class="line">            for name in handler.request.query_arguments.keys():</div><div class="line">                formdata.setlist(name, handler.request.query_arguments[name])</div><div class="line">        Form.__init__(self, formdata, obj=obj, prefix=prefix, **kwargs)</div><div class="line"></div><div class="line"></div><div class="line">class LoginForm(BaseForm):</div><div class="line">    email = fields.StringField(</div><div class="line">        validators=[validators.Email(), validators.required(), validators.length(min=5, max=64)])</div><div class="line">    password = fields.PasswordField(validators=[validators.required()])</div><div class="line"></div><div class="line"></div><div class="line">class MainHandler(tornado.web.RequestHandler, LoginForm):</div><div class="line">    def __getattribute__(self, item):</div><div class="line">        ret = object.__getattribute__(self, item)</div><div class="line">        if isinstance(ret, UnboundField):</div><div class="line">            form = object.__getattribute__(self, &apos;form&apos;)</div><div class="line">            return getattr(form, item).data</div><div class="line">        return ret</div><div class="line"></div><div class="line">    def post(self):</div><div class="line">        self.form = LoginForm(self)</div><div class="line">        print(self.email)</div><div class="line">        self.write(&quot;Hello, world&quot;)</div><div class="line"></div><div class="line"></div><div class="line">def make_app():</div><div class="line">    return tornado.web.Application([</div><div class="line">        (r&quot;/&quot;, MainHandler),</div><div class="line">    ])</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    app = make_app()</div><div class="line">    app.listen(8888)</div><div class="line">    tornado.ioloop.IOLoop.current().start()</div></pre></td></tr></table></figure>
<p>完美解决问题,心情瞬间舒畅了┑(￣Д ￣)┍</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中看到有一些不好的代码，想了个办法优化了一下，于是有了这篇博文。本文主要讲tornado的表单验证，使用的是wtforms。本文最终达到的效果是使用self.xx获取post传递过来的值。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.zoulei.net/categories/python/"/>
    
    
  </entry>
  
</feed>
